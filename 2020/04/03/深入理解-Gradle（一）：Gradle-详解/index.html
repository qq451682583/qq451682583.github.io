<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="BLCJ" />





  <link rel="alternate" href="/atom.xml" title="ZHBlog" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/img/site.png?v=5.0.1" />






<meta name="description" content="[TOC]">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解 Gradle（一）：Gradle 详解">
<meta property="og:url" content="http://qq451682583.github.io/2020/04/03/深入理解-Gradle（一）：Gradle-详解/index.html">
<meta property="og:site_name" content="ZHBlog">
<meta property="og:description" content="[TOC]">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle_ant_eclipse.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle_maven_retrofit.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/black_face.jpeg">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle_xrk_crm.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/Groovy关系图.png">
<meta property="og:image" content="http://wanghaoxun.com/img/Groovy-GDK.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/groovy-basic-data-type.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle-groovy-sdk-range.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle-groovy-closure-hello.png">
<meta property="og:image" content="http://wanghaoxun.com/img/groovy-defaultmethods-each.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/groovy-defaultmethods-findall.jpg">
<meta property="og:image" content="http://wanghaoxun.com/img/gradlephant@2x.png">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle-xrk-project.jpg">
<meta property="og:image" content="http://wanghaoxun.com/gradle%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://wanghaoxun.com/img/Gradle 执行流程.jpg">
<meta property="og:image" content="http://wanghaoxun.com/gradle-lifecycle.png">
<meta property="og:image" content="http://wanghaoxun.com/img/gradle-agp-version.jpg">
<meta property="og:updated_time" content="2020-04-03T15:02:25.614Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解 Gradle（一）：Gradle 详解">
<meta name="twitter:description" content="[TOC]">
<meta name="twitter:image" content="http://wanghaoxun.com/img/gradle_ant_eclipse.jpg">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'BLCJ'
    }
  };
</script>




  <link rel="canonical" href="http://qq451682583.github.io/2020/04/03/深入理解-Gradle（一）：Gradle-详解/"/>

  <title> 深入理解 Gradle（一）：Gradle 详解 | ZHBlog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">ZHBlog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            留言
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                深入理解 Gradle（一）：Gradle 详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2020-04-03T23:01:10+08:00" content="2020-04-03">
              2020-04-03
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2020/04/03/深入理解-Gradle（一）：Gradle-详解/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/04/03/深入理解-Gradle（一）：Gradle-详解/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]<br><a id="more"></a></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-1-什么是构建？"><a href="#1-1-什么是构建？" class="headerlink" title="1.1 什么是构建？"></a>1.1 什么是构建？</h2><p>构建，叫 build 也好，叫 make 也行，根绝外部输入的信息然后干一堆事情，最后得到几个产出物（Artifact）。</p>
<p>Gradle 是当前非常「劲爆」的构建工具，介绍 Gradle 之前，先说说一些之前使用过的构建工具们。在 Gradle 爆红之前，常用的构建工具是 Ant，然后进化到 Maven。Ant 和 Maven 这两个工具在出来时也算方便，但是二者都有些缺点。比如，编译规则是用 XML 来编写的，XML 虽然通俗易懂，但是很难在其中描述 if/else 这样有不同条件的任务。</p>
<h2 id="1-2-构建历程"><a href="#1-2-构建历程" class="headerlink" title="1.2 构建历程"></a>1.2 构建历程</h2><ul>
<li>Ant </li>
</ul>
<p><img desc="gradle_ant_eclipse" src="http://wanghaoxun.com/img/gradle_ant_eclipse.jpg" width="60%"></p>
<ul>
<li>Maven</li>
</ul>
<p><img desc="gradle_maven_retrofit" src="http://wanghaoxun.com/img/gradle_maven_retrofit.jpg" width="60%"></p>
<p>你会发现 Ant 和 Maven 配置复杂，依赖混乱，几十人的团队协作开发编辑不敢想象，甚至都怀疑这玩意是给人用的？（黑人脸，what？？？）</p>
<p><img src="http://wanghaoxun.com/img/black_face.jpeg" alt="Nick Young"></p>
<p><strong>怎么办？怎么办？自然是编程来解决。。。</strong></p>
<ul>
<li>Gradle </li>
</ul>
<p><img desc="gradle_xrk_crm" src="http://wanghaoxun.com/img/gradle_xrk_crm.jpg" width="60%"></p>
<p>Gradle 作为一种很方便的构建工具，可以轻松解决多版本配置、构建依赖等问题，最主要它支持用 Grooovy、Java、Kotlin 来编写，可以书写自己的变量、函数。在使用 Gradle 之前，我们可能还有几个小要求：</p>
<ol>
<li>这种编程不要搞得太复杂，几行代码就轻松把要做的事情描述出来就最好不过了。所以 Gradle 选择了 Groovy，Groovy 基于 Java 并拓展了 Java，Groovy 说白了就是把写 Java 程序变得像写脚本一样简单。写完就可以执行，Groovy 内部会将其编译成 Java class 然后启动虚拟机来执行。</li>
<li>除了可以用灵活的语言来写构建规则外，Gradle 另外一个特点就是它是一种 DSL，即 Domain Specific Language，领域相关语言。什么是 DSL？说白了它是某个行业中的行话。类似徐克导演的《智取威虎山》中就很有典型的 DSL 使用描述，例如：</li>
</ol>
<blockquote>
<p>土匪：天王盖地虎！（你好大的胆！敢来气你的祖宗？）<br>杨子荣：宝塔镇河妖！（要是那样，叫我从山上摔死，掉河里淹死。）<br>土匪：野鸡闷头钻，哪能上天王山！（你不是正牌的。）<br>杨子荣：地上有的是米，喂呀，有根底！（老子是正牌的，老牌的。）</p>
</blockquote>
<p>Gradle 中也有类似的行话，比如 sourceSet 代表源文件的集合等… 太多了，记不住？没关系，后面我们会通过手册来慢慢了解一些常用的。</p>
<p><strong>一句行话可以包含很多意思，在这个行当里的人一听就懂，不用解释。另外，基于外行，我们甚至可以建立一个模板，使用者只要往这个模板里填必须的内容，Gradle 就可以非常漂亮的完成工作，得到我们想要的东西。</strong></p>
<h2 id="1-3-Gradle-小总结"><a href="#1-3-Gradle-小总结" class="headerlink" title="1.3 Gradle 小总结"></a>1.3 Gradle 小总结</h2><p>至此，大家应该明白要真正学会 Gradle 怕是离不开下面两个基础知识：</p>
<ol>
<li>Groovy，基于 Java，了解 Groovy 语言是掌握 Gradle 的基础</li>
<li>Gradle 作为一个工具，它的行话和它的「为人处事」的原则</li>
</ol>
<h1 id="二、Groovy-介绍"><a href="#二、Groovy-介绍" class="headerlink" title="二、Groovy 介绍"></a>二、Groovy 介绍</h1><p>Groovy 是一种动态语言，它和 Java 一样，也运行在 Java 虚拟机中。恩？？对，你没听错，你可以认为 Groovy 拓展了 Java 语言，比如，Groovy 对自己的定义就是：Groovy 是在 Java 平台上，具有像 Python，Ruby 和 Smalltalk 语言特性的灵活动态语言，Groovy 保证了这些特性像 Java 语法一样被 Java 开发者使用。</p>
<p>除了语言和 Java 相通外，Groovy 有时候又像一种脚本语言，当你执行 Groovy 脚本时，Groovy 会先将其编译成 Java 类字节码，然后通过 JVM 来执行这个 Java 类，图示展示了 Java、Groovy和 JVM 之间的关系。</p>
<p><img src="http://wanghaoxun.com/img/Groovy关系图.png" alt="Groovy 和 Java 关系图"></p>
<p><strong>实际上，在 Groovy Code 在真正执行的时候已经变成了 Java 字节码，所以 JVM 根本不知道自己运行的是 Groovy 代码。</strong></p>
<p>下面将集中讲解 Groovy 和 Gradle 打交道时一些常用的知识点。</p>
<h2 id="2-1-Groovy-开发环境"><a href="#2-1-Groovy-开发环境" class="headerlink" title="2.1 Groovy 开发环境"></a>2.1 Groovy 开发环境</h2><p>根据 <a href="http://www.groovy-lang.org/download.html#gvm" target="_blank" rel="external">Groovy 官网</a> 介绍部署 Groovy 开发环境。</p>
<p>macOS 安装</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install groovy</div></pre></td></tr></table></figure>
<p>Groovy 也有一套 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">GDK</a></p>
<p><img desc="Groovy-GDK" src="http://wanghaoxun.com/img/Groovy-GDK.jpg" width="60%"></p>
<p><a href="https://github.com/gradle/gradle" target="_blank" rel="external">Gradle 源代码地址</a></p>
<h2 id="2-2-一些前提知识"><a href="#2-2-一些前提知识" class="headerlink" title="2.2 一些前提知识"></a>2.2 一些前提知识</h2><ul>
<li>Groovy 注释标记和 Java 一样，支持 // 或者 /**/</li>
<li>Groovy 语句可以不用分号结尾</li>
<li>Groovy 中支持动态类型，即定义变量的时候可以不指定其类型。Groovy 中，变量定义可以使用关键字 def。注意，虽然 def 不是必须的，但是为了代码清晰，建议还是使用 def 关键字</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> variable1 = <span class="number">1</span>   <span class="comment">// 可以不使用分号结尾 </span></div><div class="line"><span class="keyword">def</span> varable2 = <span class="string">"I am a person"</span></div><div class="line"><span class="keyword">def</span> <span class="keyword">int</span> x = <span class="number">1</span>   <span class="comment">// 变量定义时，也可以直接指定类型</span></div></pre></td></tr></table></figure>
<ul>
<li>函数定义时，参数的类型也可以不指定</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String testFunction(arg1,arg2)&#123;<span class="comment">// 无需指定参数类型 </span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>除了变量定义可以不指定类型外，Groovy 中函数的返回值也可以是无类型的</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 无类型的函数定义，必须使用 def 关键字</span></div><div class="line"></div><div class="line"><span class="keyword">def</span> nonReturnTypeFunc()&#123;</div><div class="line">    last_line   <span class="comment">// 最后一行代码的执行结果就是本函数的返回值 </span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 如果指定了函数返回类型，则可不必加 def 关键字来定义函数 </span></div><div class="line">String getString()&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"I am a string"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回 Object 类型来处理的。毕竟，Groovy 是基于 Java 的，而且最终会转成 Java Code 运行在 JVM 上</p>
<ul>
<li>函数返回值：Groovy 的函数里，可以不使用 return xxx 来设置 xxx 为函数返回值。如果不使用 return 语句的话，则函数里最后一句代码的执行结果被设置成返回值。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面这个函数的返回值是字符串"getSomething return value"</span></div><div class="line"><span class="keyword">def</span> getSomething() &#123;</div><div class="line"> </div><div class="line">    <span class="string">"getSomething return value"</span> <span class="comment">// 如果这是最后一行代码，则返回类型为 String</span></div><div class="line"> </div><div class="line">    <span class="number">1000</span> <span class="comment">// 如果这是最后一行代码，则返回类型为 Integer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型，否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。</p>
<ul>
<li>Groovy 对字符串支持相当强大，充分吸收了一些脚本语言的优点：</li>
</ul>
<ol>
<li>单引号’’中的内容严格对应 Java 中的 String，不对 $ 符号进行转义</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> singleQuote=<span class="string">'I am $ dolloar'</span>  <span class="comment">// 输出就是 I am $ dolloar</span></div></pre></td></tr></table></figure>
<ol>
<li>双引号””的内容则和脚本语言的处理有点像，如果字符中有 $ 号的话，则它会$ 表达式先求值</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> doubleQuoteWithoutDollar = <span class="string">"I am one dollar"</span> <span class="comment">// 输出 I am one dollar</span></div><div class="line"><span class="keyword">def</span> x = <span class="number">1</span></div><div class="line"><span class="keyword">def</span> doubleQuoteWithDollar = <span class="string">"I am $x dolloar"</span> <span class="comment">// 输出 I am 1 dolloar</span></div></pre></td></tr></table></figure>
<ol>
<li>三个引号’’’xxx’’’中的字符串支持随意换行 比如</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> multieLines = <span class="string">''' begin</span></div><div class="line">  line  1 </div><div class="line">  line  2</div><div class="line">  end '''</div></pre></td></tr></table></figure>
<ul>
<li>最后，除了每行代码不用加分号外，Groovy 中函数调用的时候还可以不加括号。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">println(<span class="string">"test"</span>) ---&gt; println <span class="string">"test"</span></div></pre></td></tr></table></figure>
<p><strong>注意，虽然写代码的时候，对于函数调用可以不带括号，但是 Groovy 经常把属性和函数调用混淆。比如</strong></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> getSomething()&#123;</div><div class="line">   <span class="string">"hello"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getSomething()   // 如果不加括号的话，Groovy 会误认为 getSomething 是一个变量。</p>
<p>所以，调用函数要不要带括号，我个人意见是如果这个函数是 Groovy API 或者 Gradle API 中比较常用的，比如 println，就可以不带括号。否则还是带括号。Groovy 自己也没有太好的办法解决这个问题，只能兵来将挡水来土掩了。</p>
<h2 id="2-3-Groovy-中的数据类型"><a href="#2-3-Groovy-中的数据类型" class="headerlink" title="2.3 Groovy 中的数据类型"></a>2.3 Groovy 中的数据类型</h2><p>Groovy 中的数据类型我们就介绍三种和 Java 不太一样的：</p>
<ul>
<li>一个是 Java 中的基本数据类型</li>
<li>另外一个是 Groovy 中的容器类</li>
<li>最后一个非常重要的是闭包</li>
</ul>
<h3 id="2-3-1-基本数据类型"><a href="#2-3-1-基本数据类型" class="headerlink" title="2.3.1 基本数据类型"></a>2.3.1 基本数据类型</h3><p>作为动态语言，Groovy 世界中的所有事物都是对象。所以，int，boolean 这些 Java 中的基本数据类型，在 Groovy 代码中其实对应的是它们的包装数据类型。比如 int 对应为 Integer，boolean 对应为 Boolean。比如下图中的代码执行结果：</p>
<p><img desc="基本数据类型" src="http://wanghaoxun.com/img/groovy-basic-data-type.jpg" width="60%"></p>
<h3 id="2-3-2-容器类"><a href="#2-3-2-容器类" class="headerlink" title="2.3.2 容器类"></a>2.3.2 容器类</h3><p>Groovy 中的容器类很简单，就三种：</p>
<ul>
<li>List：链表，其底层对应 Java 中的 List 接口，一般用 ArrayList 作为真正的实现类</li>
<li>Map：键 - 值表，其底层对应 Java 中的 LinkedHashMap</li>
<li>Range：范围，它其实是 List 的一种拓展</li>
</ul>
<p>了解容器简单例子：</p>
<ol>
<li>List 类</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">变量定义：List 变量由 [] 定义，比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aList = [<span class="number">5</span>,<span class="string">'string'</span>,<span class="literal">true</span>] <span class="comment">//List 由 [] 定义，其元素可以是任何对象 </span></div><div class="line"></div><div class="line">变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List 会自动 </div><div class="line">往该索引添加元素 </div><div class="line"></div><div class="line"><span class="keyword">assert</span> aList[<span class="number">1</span>] == <span class="string">'string'</span></div><div class="line"><span class="keyword">assert</span> aList[<span class="number">5</span>] == <span class="literal">null</span> <span class="comment">// 第 6 个元素为空 </span></div><div class="line">aList[<span class="number">100</span>] = <span class="number">100</span>  <span class="comment">// 设置第 101 个元素的值为 100</span></div><div class="line"><span class="keyword">assert</span> aList[<span class="number">100</span>] == <span class="number">100</span></div><div class="line"></div><div class="line">那么，aList 到现在为止有多少个元素呢？</div><div class="line"></div><div class="line">println aList.size  ===&gt; 结果是 <span class="number">101</span></div></pre></td></tr></table></figure>
<ol>
<li>Map 类</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">容器变量定义 </div><div class="line"></div><div class="line">变量定义：Map 变量由 [:] 定义，比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aMap = [<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="literal">true</span>] </div><div class="line"></div><div class="line">Map 由 [:] 定义，注意其中的冒号。冒号左边是 key，右边是 Value。key 必须是字符串，value 可以是任何对象。另外，key 可以用<span class="string">''</span>或<span class="string">""</span>包起来，也可以不用引号包起来。比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aNewMap = [<span class="string">key1:</span><span class="string">"value"</span>,<span class="string">key2:</span><span class="literal">true</span>] <span class="comment">// 其中的 key1 和 key2 默认被 </span></div><div class="line">处理成字符串<span class="string">"key1"</span>和<span class="string">"key2"</span></div><div class="line"></div><div class="line">不过 Key 要是不使用引号包起来的话，也会带来一定混淆，比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> key1 = <span class="string">"wowo"</span></div><div class="line"><span class="keyword">def</span> aConfusedMap = [<span class="string">key1:</span><span class="string">"who am i?"</span>]</div><div class="line"></div><div class="line">aConfuseMap 中的 key1 到底是<span class="string">"key1"</span>还是变量 key1 的值“wowo”？显然，答案是字符串<span class="string">"key1"</span>。如果要是<span class="string">"wowo"</span>的话，则 aConfusedMap 的定义必须设置成：</div><div class="line"></div><div class="line"><span class="keyword">def</span> aConfusedMap = [(key1):<span class="string">"who am i?"</span>]</div><div class="line"></div><div class="line">Map 中元素的存取更加方便，它支持多种方法：</div><div class="line"></div><div class="line">println aMap.keyName    &lt;== 这种表达方法好像 key 就是 aMap 的一个成员变量一样 </div><div class="line">println aMap[<span class="string">'keyName'</span>] &lt;== 这种表达方法更传统一点 </div><div class="line">aMap.anotherkey = <span class="string">"i am map"</span>  &lt;== 为 map 添加新元素</div></pre></td></tr></table></figure>
<ol>
<li>Range 类</li>
</ol>
<p>Range 是 Groovy 对 List 的一种扩展，变量定义和大体的使用方法如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">def</span> aRange = <span class="number">1.</span><span class="number">.5</span>  &lt;==Range 类型的变量 由 begin 值 + 两个点 +end 值表示 </div><div class="line">                      左边这个 aRange 包含 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> 这 <span class="number">5</span> 个值 </div><div class="line"></div><div class="line">如果不想包含最后一个元素，则 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aRangeWithoutEnd = <span class="number">1.</span>.&lt;<span class="number">5</span>  &lt;== 包含 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> 这 <span class="number">4</span> 个元素 </div><div class="line">println aRange.from</div><div class="line">println aRange.to</div></pre></td></tr></table></figure>
<h3 id="2-3-3-Groovy-API-的一些秘笈"><a href="#2-3-3-Groovy-API-的一些秘笈" class="headerlink" title="2.3.3 Groovy API 的一些秘笈"></a>2.3.3 Groovy API 的一些秘笈</h3><p>了解 Groovy 的语法，是离不开 SDK 的，Groovy 是动态语言，所以要使用它的 SDK 也需要掌握一些小诀窍。</p>
<p>Groovy 的 API 文档地址：<a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></p>
<p>以上面介绍的 Range 为例，我们该如何查阅 SDK 更好的使用它呢？</p>
<ul>
<li>先找到 Range 类，它位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">groovy.lang</a> 包中：</li>
</ul>
<p>有了 API 文档，你可以使用里面的函数了，不过，细心地你可以发现我们刚才代码中用到的 Range.from/to 属性值，在 Range API 文档中并没有这两个成员变量。</p>
<p><img desc="gradle-groovy-sdk-range" src="http://wanghaoxun.com/img/gradle-groovy-sdk-range.jpg" width="60%"></p>
<p>文档中没有说明 Range 有 from 和 to 这两个属性，但是却有 getFrom 和 getTo 两个函数，What？？？原来：</p>
<p>根据 Groovy 的原则，如果一个类中有名为 xxyyzz 这样的属性（其实就是成员变量），Groovy 会自动为它添加 getXX 和 setXX 两个函数，用于获取和设置 xxyyzz 属性值。</p>
<p><strong>注意：get 和 set 后第一个字母是大写的！</strong></p>
<p>所以，当你看到 Range 中有 getFrom 和 getTo 这两个函数时候，就得知道潜规则下，Range 有 from 和 to 这两个属性。当然，由于它们不可以被外界设置，所以没有公开 setFrom 和 setTo 函数。</p>
<h2 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h2><h3 id="2-4-1-闭包的样子"><a href="#2-4-1-闭包的样子" class="headerlink" title="2.4.1 闭包的样子"></a>2.4.1 闭包的样子</h3><p>闭包，英文叫 Closure，是 Groovy 中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！</p>
<p><strong>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def aClosure = &#123;// 闭包是一段代码，所以需要用花括号括起来..  </div><div class="line">    Stringparam1, int param2 -&gt;  // 这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </div><div class="line">    println &quot;this is code&quot; // 这是代码，最后一句是返回值，  </div><div class="line">   // 也可以使用 return，和 Groovy 中普通函数一样  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简而言之，Closure 的定义格式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def xxx = &#123;paramters -&gt; code&#125;  // 或者  </div><div class="line">def xxx = &#123;无参数，纯 code&#125;  这种 case 不需要 -&gt; 符号</div></pre></td></tr></table></figure>
<p>补充一点，有没有想到我分享 Java8 时提到的 Lambda 表达式呢？哈哈。。。</p>
<p><strong>从 C/C++ 语言的角度看，闭包和函数指针很像</strong>。闭包定义好，要调用它的方法就是：</p>
<p>闭包对象.call(参数)  或者更像函数指针调用的方法：</p>
<p>闭包对象 (参数)</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">aClosure.call(&quot;this is string&quot;,100)  或者  </div><div class="line">aClosure(&quot;this is string&quot;, 100)</div></pre></td></tr></table></figure>
<p>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫 it，和 this 的作用类似。it 代表闭包的参数。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def greeting = &#123; &quot;Hello, $it!&quot; &#125;</div><div class="line">assert greeting(&apos;Nelson&apos;) == &apos;Hello, Nelson!&apos;</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def greeting = &#123; it -&gt; &quot;Hello, $it!&quot; &#125;</div><div class="line">assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;</div></pre></td></tr></table></figure>
<h3 id="2-4-2-Closure-使用中的注意点"><a href="#2-4-2-Closure-使用中的注意点" class="headerlink" title="2.4.2 Closure 使用中的注意点"></a>2.4.2 Closure 使用中的注意点</h3><ol>
<li>省略圆括号</li>
</ol>
<p>闭包在 Groovy 中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</div></pre></td></tr></table></figure>
<p>上面这个函数表示针对 List 的每一个元素都会调用 closure 做一些处理。这里的 closure，就有点回调函数的感觉。但是，在使用这个 each 函数的时候，我们传递一个怎样的 Closure 进去呢？比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def iamList = [1,2,3,4,5]  // 定义一个 List</div><div class="line">iamList.each &#123;  // 调用它的 each，这段代码的格式看不懂了吧？each 是个函数，圆括号去哪了？</div><div class="line">      println it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码，有 2个知识点：</p>
<ul>
<li><strong>each 函数调用的圆括号不见了！</strong>原来，Groovy 中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def  testClosure(int a1,String b1, Closure closure) &#123;</div><div class="line">      //do something</div><div class="line">      closure() // 调用闭包 </div><div class="line">&#125;</div><div class="line">那么调用的时候，就可以免括号！</div><div class="line">testClosure (4, &quot;test&quot;, &#123;</div><div class="line">   println &quot;i am in closure&quot;</div><div class="line">&#125; )  // 外层的括号可以不写..</div><div class="line">// 简写</div><div class="line">testClosure 4,&quot;test&quot;,&#123;println &quot;i am in closure&quot;&#125;</div></pre></td></tr></table></figure>
<p>注意，这个特点非常重要，因为以后在 Gradle 中经常出现如下这样的代码：</p>
<p><img desc="Gradle 简单闭包示例" src="http://wanghaoxun.com/img/gradle-groovy-closure-hello.png"></p>
<p>经常碰见图示这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我疑惑，以 doLast 为例，完整的代码应该按下面这种写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doLast(&#123;</div><div class="line">   println &apos;Hello world!&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>有了圆括号，你会知道 doLast 只是把一个 Closure 对象传了进去。很明显，它不代表这段脚本解析到 doLast 的时候就会调用 println ‘Hello world!’ 。</p>
<p>但是把圆括号去掉后，就感觉好像 println ‘Hello world!’ 立即就会被调用一样！</p>
<ol>
<li>如何确定 Closure 的参数</li>
</ol>
<p>另外一个比较让人头疼的地方是，closure 的参数该怎么搞？还是刚才的 each 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def iamList = [1,2,3,4,5]  // 定义一个 List 变量 </div><div class="line">iamList.each&#123;  // 调用它的 each 函数，只要传入一个 Closure 就可以了。</div><div class="line">  println it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>对于 each 所需要的 Closure，它的参数是什么？有多少个参数？返回值是什么？</strong></li>
</ul>
<p>Closure 虽然方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，该如何知道调用者传递什么参数给 Closure 呢？</p>
<p>此问题如何破解？只能通过查询 <a href="http://docs.groovy-lang.org/latest/html/gapi/index.html?org/codehaus/groovy/runtime/DefaultGroovyMethods.html" target="_blank" rel="external">API</a>  文档才能了解上下文语义。如下图：</p>
<p>从整体上知道 groovy SDK 对 JDK 做了扩展，这些都是 GDK 提供的新类，这些方法并没有加到 JDK 中对应的类中，那是如何直接调用它扩展的那些方法呢？例如，Class DefaultGroovyMethods 类中为我们任意对象都提供了一个 each 方法。</p>
<p><img desc="each 方法" src="http://wanghaoxun.com/img/groovy-defaultmethods-each.jpg" width="60%"></p>
<p><img desc="findAll 方法" src="http://wanghaoxun.com/img/groovy-defaultmethods-findall.jpg" width="60%"></p>
<ul>
<li>each 函数说明中，将给指定的 closure 传递 Set 中的每一个 item。所以，closure 的参数只有一个。</li>
<li>findAll 中，绝对抓瞎了。一个是没说明往 Closure 里传什么。另外没说明 Closure 的返回值是什么…..</li>
</ul>
<p><strong>对 Map 的 findAll 而言，Closure 可以有两个参数。findAll 会将 Key 和 Value 分别传进去。并且，Closure 返回 true，表示该元素是自己想要的。返回 false 表示该元素不是自己要找的。</strong> 示意代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def aMap = [k1:&apos;value1&apos;,k2:true]</div><div class="line">def results = aMap.findAll &#123;</div><div class="line">    key, value -&gt; </div><div class="line">    println &quot;key=$key, value=$value&quot;</div><div class="line">    if(key == &apos;k1&apos;) </div><div class="line">        return true</div><div class="line">    return false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Closure 的使用有点坑，很大程度上依赖你对 API 的熟悉程度，so，最初阶段，SDK 查询是少不了的！</p>
</blockquote>
<h2 id="2-5-脚本类、文件-I-O-和-XML-操作"><a href="#2-5-脚本类、文件-I-O-和-XML-操作" class="headerlink" title="2.5 脚本类、文件 I/O 和 XML 操作"></a>2.5 脚本类、文件 I/O 和 XML 操作</h2><p>最后，来看一下 Groovy 中比较高级的用法。</p>
<h3 id="2-5-1-脚本类"><a href="#2-5-1-脚本类" class="headerlink" title="2.5.1 脚本类"></a>2.5.1 脚本类</h3><ol>
<li>脚本中 import 其他类</li>
</ol>
<p>Groovy 中可以像 Java 那样写 package，然后写类。比如在文件夹 com/nelson/groovy/chap2 目录中放一个文件，叫 Article.groovy，如代码所示（演示-chap2 代码）：</p>
<p>创建了 Article.groovy 文件，ArticleTest.groovy 再 import 了 Article 类，然后创建了 Article 类型的对象，接着调用它的 print 函数。</p>
<p>在 groovy 中，系统自带会加载当前目录 / 子目录下的 xxx.groovy 文件。所以，当执行 groovy ArticleTest.groovy 的时候，ArticleTest.groovy import 的 Article 类能被自动搜索并加载到。</p>
<ol>
<li>脚本到底是什么</li>
</ol>
<p>Java 中，我们最熟悉的是类。但是我们在 Java 的一个源码文件中，不能不写 class（interface 或者其他….），而 Groovy 可以像写脚本一样，把要做的事情都写在 xxx.groovy 中，而且可以通过 groovy xxx.groovy 直接执行这个脚本。这到底是怎么搞的？</p>
<p>既然是基于 Java 的，Groovy 会先把 xxx.groovy 中的内容转换成一个 Java 类。比如：chap2/Inner.groovy 文件</p>
<p><strong>执行 groovyc -d classes Inner.groovy</strong>，groovyc 是 groovy 的编译命令， -d classes 用于将编译得到的 class 文件拷贝到 classes 文件夹下，Inner.groovy 脚本转换得到的 java class，可以用 jd-gui 反编译它的代码，也可以用 IEA 直接查看。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">import groovy.lang.Binding;</div><div class="line">import groovy.lang.Script;</div><div class="line">import org.codehaus.groovy.runtime.InvokerHelper;</div><div class="line">import org.codehaus.groovy.runtime.callsite.CallSite;</div><div class="line"></div><div class="line">public class Inner extends Script &#123;</div><div class="line">    public Inner() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Inner(Binding context) &#123;</div><div class="line">        CallSite[] var2 = $getCallSiteArray();</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String... args) &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        var1[0].call(InvokerHelper.class, Inner.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object run() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        return var1[1].callCurrent(this, &quot;Hello Groovy!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Inner.groovy 被转换成了一个 Script 类，它从 script 派生。</li>
<li>每一个脚本都会生成一个 static main 函数。这样，当我们 groovy Inner.groovy 的时候，其实就是用 java 去执行这个 main 函数</li>
<li>脚本中的所有代码都会放到 run 函数中。比如，println ‘Hello Groovy’，这句代码实际上是包含在 run 函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在 Inner 类中</li>
</ul>
<ol>
<li>脚本中的变量和作用域</li>
</ol>
<p>上面说了脚本的代码其实都会被放到 run 函数中去执行，那么在 Groovy 的脚本中，很重要的一点就是脚本中定义的变量和它的作用域。举例：</p>
<p>Field.groovy 文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 2.5.1 脚本中的变量和作用域</div><div class="line"> */</div><div class="line">def x = 1</div><div class="line"></div><div class="line">def printx() &#123;</div><div class="line">    println x</div><div class="line">&#125;</div><div class="line"></div><div class="line">printx()</div></pre></td></tr></table></figure>
<p><strong>运行脚本会报错，groovy.lang.MissingPropertyException: No such property: x for class: Field</strong></p>
<p>反编译后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">public class Field extends Script &#123;</div><div class="line">    public Field() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Field(Binding context) &#123;</div><div class="line">        CallSite[] var2 = $getCallSiteArray();</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String... args) &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        var1[0].call(InvokerHelper.class, Field.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object run() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        Object x = 1;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object printx() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        return var1[1].callCurrent(this, var1[2].callGroovyObjectGetProperty(this));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>printx 被定义成 Field 类的成员函数</li>
<li>def x = 1，这句话是在 run 中创建的。所以，x = 1 从代码上看好像是在整个脚本中定义的，但实际上 printx 访问不了它。printx 是 test 成员函数，除非 x 也被定义成 test 的成员函数，否则 printx 不能访问它。</li>
</ul>
<p>那么，如何使得 printx 能访问 x 呢？很简单，定义的时候不要加类型和 def。演示 chap2/Field2.groovy 源文件和反编译文件</p>
<p>x 也没有被定义成 Field2 的成员函数，而是在 run 的执行过程中，将 x 作为一个属性添加到 Field2 <strong>实例对象</strong>中了。然后在 printx 中，先获取这个属性。</p>
<p><strong>注意，Groovy 文档说 x = 1 这种定义将使得 x 变成 Filed2 的成员变量，但从反编译情况来看，这是不对的。。。</strong></p>
<p>虽然 printx 可以访问 x 变量了，但是假如有其他脚本却无法访问 x 变量。因为它不是 Field2 的成员变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class Field3 extends Script &#123;</div><div class="line">    Object x;</div><div class="line"></div><div class="line">    public Field3() &#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String... args) &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        var1[0].call(InvokerHelper.class, Field3.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object run() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        Object var10000 = null;</div><div class="line">        return !__$stMC &amp;&amp; !BytecodeInterface8.disabledStandardMetaClass() ? this.printx() : var1[1].callCurrent(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object printx() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        return var1[2].callCurrent(this, this.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Field3.groovy 中的 x 已经变成了 Field3 类的成员属性了。如此，我们可以在 script 中定义那些需要输出给外部脚本或类使用的变量了！</p>
<blockquote>
<p>这里演示 Field2.groovy，Field3.groovy，InvokeField.groovy 文件来说明成员属性！</p>
</blockquote>
<h3 id="2-5-2-文件-I-O"><a href="#2-5-2-文件-I-O" class="headerlink" title="2.5.2 文件 I/O"></a>2.5.2 文件 I/O</h3><p>本节介绍 Groovy 的文件 I/O 操作。虽然比 Java 看起来简单，但要理解起来其实比较难。尤其是当你要自己查 SDK 并编写代码的时候。</p>
<p>整体说来，Groovy 的 I/O 操作是在原有 Java I/O 操作上进行了更为简单方便的封装，并且使用 Closure 来简化代码编写。主要封装了如下一些类：</p>
<ul>
<li>java.io.File class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></li>
<li>java.io.InputStream class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></li>
<li>java.io.OutputStream class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></li>
<li>java.io.Reader class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a></li>
<li>java.io.Writer class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a></li>
<li>java.nio.file.Path class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a></li>
</ul>
<ol>
<li>读文件</li>
</ol>
<p>Groovy 中，文件读操作简单到令人发指：</p>
<p>def targetFile = new File(文件名)  &lt;==File 对象还是要创建的</p>
<p>看看 Groovy 定义的 API：</p>
<ul>
<li>读该文件中的每一行：eachLine 的唯一参数是一个 Closure。Closure 的参数是文件每一行的内容</li>
</ul>
<p>内部实现肯定是 Groovy 打开这个文件，然后读取文件的一行，然后调用 Closure…</p>
<p>演示 File.groovy 文件</p>
<ul>
<li>直接得到文件内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">targetFile.getBytes() // 文件内容一次性读出，返回类型为 byte[]</div></pre></td></tr></table></figure>
<p>注意前面提到的 getter 和 setter 函数，这里可以直接使用 targetFile.bytes //…</p>
<ul>
<li>使用 InputStream </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def ism = targetFile.newInputStream()</div><div class="line"></div><div class="line">ism.close()</div></pre></td></tr></table></figure>
<ul>
<li>使用闭包操作 inputStream，以后会在 Gradle 里经常看到这种写法。。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">targetFile.withInputStream &#123; ism -&gt;</div><div class="line">    // 操作 ism，不用 close，groovy 会自动替你 close</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>确实简单到发指，一开始也死活不理解 withInputStream 是个啥意思。所以，请再看的各位老铁牢记 Groovy I/O 操作相关类的 SDK 地址~</p>
<ol>
<li>写文件</li>
</ol>
<p>和读文件差不多，不再啰嗦，这里举个例子，告诉你如何 copy 文件，演示 Copy.groovy 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def srcFile = new File(&apos;src/com/nelson/groovy/chap2/source.txt&apos;)</div><div class="line">def targetFile = new File(&apos;src/com/nelson/groovy/chap2/dest.txt&apos;)</div><div class="line">targetFile.withOutputStream &#123; os -&gt;</div><div class="line">    srcFile.withInputStream &#123; ins -&gt;</div><div class="line">        // 利用 OutputStream 的 &lt;&lt; 操作符重载，完成从 Inputstream 到 OutputStream 的输出</div><div class="line">        os &lt;&lt; ins</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 OutputStream 的 &lt;&lt; 操作符重载，查看 SDK 文档之后才知道：</p>
<p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></p>
<p>再一次向极致简单致敬。以后，怕是 SDK 离不开手了，各位。。。</p>
<h3 id="2-5-3-XML-操作"><a href="#2-5-3-XML-操作" class="headerlink" title="2.5.3 XML 操作"></a>2.5.3 XML 操作</h3><p>除了 I/O 异常简单之外，Groovy 中的 XML 操作也极致得很。Groovy 中，XML 的解析提供了和 XPath 类似的方法，名为 GPath。这是一个类，提供相应 API。关于 XPath，请看 <a href="https://en.wikipedia.org/wiki/XPath" target="_blank" rel="external">WIKI</a>。</p>
<p>演示 Xml.groovy 文件</p>
<p>详细操作就不在这展开了，用到了各位在查 SDK 完成吧~</p>
<h3 id="2-6-更多"><a href="#2-6-更多" class="headerlink" title="2.6 更多"></a>2.6 更多</h3><p>作为一门语言，Groovy 是复杂的，是需要深入学习和钻研的。一本厚书都无法描述 Groovy 的方方面面。</p>
<p>从使用的角度看，尤其是又限定在 Gradle 这个领域内，能用到的 Groovy 中一些简单的知识。</p>
<h1 id="三、Gradle-介绍"><a href="#三、Gradle-介绍" class="headerlink" title="三、Gradle 介绍"></a>三、Gradle 介绍</h1><p><img src="http://wanghaoxun.com/img/gradlephant@2x.png" align="right" width="280"></p>
<p>现在正式进入 Gradle。Gradle 是一个工具，同时它也是一个编程框架。前面也提到过，使用这个工具可以完成 app 的编译打包等工作。当然你也可以用它干其他的事情。</p>
<p>Gradle 是什么？学习它到什么地步就可以了？</p>
<p>看待问题的时候，所站的角度非常重要！</p>
<p>-&gt; 当你把 Gradle 当工具看的时候，我们只想着如何用好它。会写、写好配置脚本就 OK<br>-&gt; 当你把它当做编程框架看的时候，你可能需要学习很多更深入的内容。</p>
<p>今天我们把它当工具看，明天因为需求发生变化，我们可能又得把它当编程框架看。</p>
<h2 id="3-1-Gradle-开发环境部署"><a href="#3-1-Gradle-开发环境部署" class="headerlink" title="3.1 Gradle 开发环境部署"></a>3.1 Gradle 开发环境部署</h2><p>Gradle 官网：<a href="http://gradle.org/，最新" target="_blank" rel="external">http://gradle.org/，最新</a> Gradle 6.0.1</p>
<p>文档：<a href="https://docs.gradle.org/current/release-notes.html，其中的" target="_blank" rel="external">https://docs.gradle.org/current/release-notes.html，其中的</a> User Guide 和 DSL Reference 很关键，User Guide 就是介绍 Gradle 的一本书，而 DSL Reference 是 Gradle API 的说明。</p>
<p>MacOs 安装：</p>
<ul>
<li>下载 Gradle：<a href="http://gradle.org/gradle-download/" target="_blank" rel="external">http://gradle.org/gradle-download/</a>  选择Complete distribution和Binary only distribution都行。然后解压到指定目录</li>
<li>设置 ~/.bashrc 把 Gradle 加到 PATH 里</li>
<li>执行 source ~/.bashrc 初始化环境</li>
<li>执行 gradle –version 显示 Gradle 版本号</li>
</ul>
<p>注意，为什么说 Gradle 是一个编程框架？来看它提供的 API 文档：</p>
<p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></p>
<p>原来，我们编写所谓的编译脚本，其实就是玩 Gradle 的 API…. 所以它从更底层意义上看，是一个编程框架！</p>
<p>既然是编程框架，我在讲解 Gradle 的时候，尽量会从 API 的角度来介绍。有些读者肯定会不耐烦，为嘛这么费事？</p>
<p><strong>从我个人的经历来看：因为我从网上学习到的资料来看，几乎全是从脚本的角度来介绍 Gradle，结果学习一通下来，只记住参数怎么配置，却不知道它们都是函数调用，都是严格对应相关 API 的。</strong></p>
<p>而从 API 角度来看待 Gradle 的话，有了 SDK 文档，你就可以编程。编程是靠记住一行行代码来实现的吗？不是，是在你掌握大体流程，然后根据 SDK + API 来完成的！</p>
<p>其实，Gradle 自己的 User Guide 也明确说了：</p>
<p><strong>Build scripts are code</strong></p>
<h2 id="3-2-基本组件"><a href="#3-2-基本组件" class="headerlink" title="3.2 基本组件"></a>3.2 基本组件</h2><p>Gradle 是一个框架，它定义一套自己的游戏规则。我们要玩转 Gradle，必须要遵守它设计的规则。下面我们来讲讲 Gradle 的基本组件：</p>
<p>Gradle 中，每一个待编译的工程都叫一个 Project。每一个 Project 在构建的时候都包含一系列的 Task。比如一个 Android APK 的编译可能包含：<strong>Java 源码编译 Task、资源编译 Task、JNI 编译 Task、lint 检查 Task、打包生成 APK 的 Task、签名 Task 等。</strong></p>
<p>一个 Project 到底包含多少个 Task，其实是由编译脚本指定的插件决定。插件是什么呢？插件就是用来定义 Task，并具体执行这些 Task 的东西。</p>
<p>Gradle 是一个框架，作为框架，它负责定义流程和规则。而具体的编译工作则是通过插件的方式来完成的。比如<strong>编译 Java 有 Java 插件，编译 Groovy 有 Groovy 插件，编译 Android APP 有 Android APP 插件，编译 Android Library 有 Android Library 插件</strong></p>
<p>到现在为止，你知道 Gradle 中每一个待编译的工程都是一个 Project，一个具体的编译过程是由一个一个的 Task 来定义和执行的。</p>
<h3 id="3-2-1-一个重要的例子"><a href="#3-2-1-一个重要的例子" class="headerlink" title="3.2.1 一个重要的例子"></a>3.2.1 一个重要的例子</h3><p>演示向日葵项目</p>
<p><img desc="向日葵工程目录结构" src="http://wanghaoxun.com/img/gradle-xrk-project.jpg" width="60%"></p>
<ul>
<li>BIZ(biz-task,biz-transfer)、BIZService(biz-core,biz-form,biz-lego) 是 Android Library。其中，BIZ 下面的 library 依赖 BIZService library</li>
<li>CRMApp 和 MiniApp 是 Android APP。这些 App 和 SDK 有依赖关系。CRMApp 依赖所有的 BIZ library。</li>
</ul>
<p>问题1：请回答问题，在上面这个例子中，有多少个 Project？</p>
<p>答案是：每一个 Library 和每一个 App 都是单独的 Project。根据 Gradle 的要求，每一个 Project 在其根目录下都需要有一个 build.gradle。build.gradle 文件就是该 Project 的编译脚本，类似于 Makefile。</p>
<p>问题2：这么多 project，我们要独立编译他们的话，得 cd 某个 project，然后执行 gradle xxx，这会很麻烦，这么多 project，每个都得重复执行。可不可以在工程下执行 gradle assemble 把这些 Project 的东西都编译出来呢？</p>
<p>答案自然是可以。在 Gradle 中，这叫 Multi-Projects Build。在项目下添加个 settings.gradle 文件，名字必须是 settings.gradle。它里边用来告诉 Gradle，这个 multiprojects 包含多少个子 Project。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include ModuleA,ModuleB...</div></pre></td></tr></table></figure>
<h3 id="3-2-2-Gradle-命令介绍"><a href="#3-2-2-Gradle-命令介绍" class="headerlink" title="3.2.2 Gradle 命令介绍"></a>3.2.2 Gradle 命令介绍</h3><ol>
<li>gradle projects 查看工程信息</li>
</ol>
<p><code>./gradlew projects</code> 可以查看 multi projects 到底包含多少个子 Project</p>
<ol>
<li>gradle tasks 查看任务信息</li>
</ol>
<p><code>./gradlew project-path:tasks</code> 查看某个 Project 包含哪些 Task 信息。</p>
<p>Android Library 对应的插件定义了好多 Task。每种插件定义的 Task 都不尽相同，这就是所谓的 Domain Specific，需要我们对相关领域有比较多的了解。</p>
<ol>
<li>gradle task-name 执行任务</li>
</ol>
<p>上面列出了好多任务，这时候就可以通过 gradle 任务名来执行某个任务。这和 make xxx 很像。比如：</p>
<ul>
<li>gradle clean 是执行清理任务，和 make clean 类似。</li>
<li>gradle properites 用来查看所有属性信息。</li>
</ul>
<p>这里要强调一点：Task 和 Task 之间往往是有关系的，这就是所谓的依赖关系。比如，assemble task 就依赖其他 task 先执行，assemble 才能完成最终的输出。</p>
<p>大家先了解这么多，等后面介绍如何写 gradle 脚本的时候，这就是调用几个函数的事情，Nothing Special!</p>
<h2 id="3-3-Gradle-工作流程"><a href="#3-3-Gradle-工作流程" class="headerlink" title="3.3 Gradle 工作流程"></a>3.3 Gradle 工作流程</h2><p>Gradle 的工作流程其实蛮简单，用一个图来表示：</p>
<p><img src="http://wanghaoxun.com/gradle%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Gradle 工作流程"></p>
<p>Gradle 工作包含三个阶段：</p>
<ul>
<li>首先是初始化阶段。对我们前面的 multi-project build 而言，就是执行 settings.gradle</li>
<li>Initiliazation phase 的下一个阶段是 Configration 阶段</li>
<li>Configration 阶段的目标是解析每个 project 中的 build.gradle。比如 multi-project build 例子中，解析每个子目录中的 build.gradle。在这两个阶段之间，我们可以加一些定制化的 Hook。这当然是通过 API 来添加的</li>
<li>Configuration 阶段完了后，整个 build 的 project 以及内部的 Task 关系就确定了。恩？前面说过，一个 Project 包含很多 Task，每个 Task 之间有依赖关系。Configuration 会建立一个有向图来描述 Task 之间的依赖关系。所以，我们可以添加一个 HOOK，即当 Task 关系图建立好后，执行一些操作</li>
<li>最后一个阶段就是执行任务了。当然，任务执行完后，我们还可以加 Hook</li>
</ul>
<p>关于 Gradle 的工作流程，你只要记住：</p>
<ul>
<li>Gradle 有一个初始化流程，这个时候 settings.gradle 会执行。</li>
<li>在配置阶段，每个 Project 都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。</li>
<li>然后才是执行阶段。你在 gradle xxx 中指定什么任务，gradle 就会将这个 xxx 任务链上的所有任务全部按依赖顺序执行一遍！</li>
</ul>
<p>Gradle 对应项目执行流程图：</p>
<p><img src="http://wanghaoxun.com/img/Gradle 执行流程.jpg" width="60%"></p>
<p><strong>接下来告诉你怎么写代码！！！</strong></p>
<h2 id="Gradle-编程模型及-API-实例详解"><a href="#Gradle-编程模型及-API-实例详解" class="headerlink" title="Gradle 编程模型及 API 实例详解"></a>Gradle 编程模型及 API 实例详解</h2><p><strong><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a> 这个文档很重要，在强调一遍~</strong></p>
<p>Gradle 基于 Groovy，Groovy 又基于 Java。所以，Gradle 执行的时候和 Groovy 一样，会把脚本转换成 Java 对象。Gradle 主要有三种对象，这三种对象和三种不同的脚本文件对应，在 gradle 执行的时候，会将脚本转换成对应的对端：</p>
<ul>
<li>Gradle 对象：当我们执行 gradle xxx 或者什么的时候，gradle 会从默认的配置脚本中构造出一个 Gradle 对象。在整个执行过程中，只有这么一个对象。Gradle 对象的数据类型就是 Gradle。我们一般很少去定制这个默认的配置脚本。</li>
<li>Project 对象：每一个 build.gradle 会转换成一个 Project 对象。</li>
<li>Settings 对象：显然，每一个 settings.gradle 都会转换成一个 Settings 对象。</li>
</ul>
<p>注意，对于其他 gradle 文件，除非定义了 class，否则会转换成一个实现了 Script 接口的对象。这一点和 Groovy 的脚本类相似。</p>
<p>当我们执行 gradle 的时候，gradle 首先是按顺序解析各个 gradle 文件。这里边就有所所谓的生命周期的问题，即先解析谁，后解析谁。图示是 Gradle 文档中对生命周期的介绍：结合上一节的内容，相信大家都能看明白了。现在只需要看红框里的内容：</p>
<p><img src="http://wanghaoxun.com/gradle-lifecycle.png" alt="Gradle-Lifecycle"></p>
<p>文档地址：<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Project.html</a></p>
<h2 id="3-4-1-Gradle-对象"><a href="#3-4-1-Gradle-对象" class="headerlink" title="3.4.1 Gradle 对象"></a>3.4.1 Gradle 对象</h2><p>我们先来看 Gradle 对象，它有哪些属性呢？跳转到文档，看看：<a href="https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html</a></p>
<p>可以尝试在 Setting.gradle 和 CRMApp build.gradle 中打印查看 gradle 详细信息：</p>
<ul>
<li>可发现 gradle 对象的 hashCode 一样</li>
<li>HomeDir 是在哪个目录存储的 gradle 可执行程序 </li>
<li>User Home Dir：是 gradle 自己设置的目录，里边存储了一些配置文件，以及编译过程中的缓存文件，生成的类文件，编译中依赖的插件等等。~/.gradle 目录</li>
</ul>
<h2 id="3-4-2-Project-对象"><a href="#3-4-2-Project-对象" class="headerlink" title="3.4.2 Project 对象"></a>3.4.2 Project 对象</h2><p>每一个 build.gradle 文件都会转换成一个 Project 对象。在 Gradle 术语中，Project 对象对应的是 Build Script。</p>
<p>Project 包含若干 Tasks。另外，由于 Project 对应具体的工程，所以需要为 Project 加载所需要的插件，比如为 Java 工程加载 Java 插件。其实，一个 Project 包含多少 Task 往往是插件决定的。</p>
<p>所以，在 Project 中，我们要：</p>
<ul>
<li>加载插件</li>
<li>不同插件有不同的行话，即不同的配置。例如我们要在 Project 中配置好 code 目录，这样插件就知道从哪里读取源文件等</li>
<li>设置属性</li>
</ul>
<ol>
<li>加载插件</li>
</ol>
<p>Project 的 API 位于 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a> 加载插件是调用它的 apply 函数。apply 其实是 Project 实现的</p>
<p>PluginAware 接口定义的：</p>
<p>apply 的用法：</p>
<p>apply 是一个函数，此处调用的是一个 apply 重载函数。注意，Groovy 支持函数调用的时候通过 参数名 1: 参数值 1，参数名 2：参数值 2 的方式来传递参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Project implements PluginAware #apply(..) 函数生命</div><div class="line">void apply(Map&lt;String, ?&gt; options)</div><div class="line"></div><div class="line">// 使用</div><div class="line">apply plugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure>
<p>问题：除了加载二进制的插件（上面的插件其实都是下载了对应的 jar 包，这也是通常意义上我们所理解的插件），还可以加载一个 gradle 文件。为什么要加载 gradle 文件呢？</p>
<p>其实这和代码的模块划分有关。一般而言，我会把一些通用的函数放到一个名叫 utils.gradle 文件里。然后在其他工程的 build.gradle 来加载这个 utils.gradle。这样，通过一些处理，我就可以调用 utils.gradle 中定义的函数了。</p>
<p>加载 utils.gradle 插件的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply from: rootProject.getRootDir().getAbsolutePath() + &quot;/utils.gradle&quot;</div></pre></td></tr></table></figure>
<p>utils.gradle 是我封装的一个 gradle 脚本，里边定义了一些方便函数，比如读取 AndroidManifest.xml 中的 versionName，或者是 copy jar 包/APK<br>包到指定的目录。</p>
<p>问题：那么，apply 最后一个函数到底支持哪些参数呢？</p>
<p>还得查阅文档来看说明，我这里不遗余力的列出 API 图片，就是希望大家在写脚本的时候，碰到不会的，一定要去查看 API 文档！这点很重要！！！</p>
<ol>
<li>设置属性</li>
</ol>
<p>如果是单个脚本，则不需要考虑属性的跨脚本传播，但是 Gradle 往往包含不止一个 build.gradle 文件，比如我设置的 utils.gradle，settings.gradle。如何在多个脚本中设置属性呢？</p>
<p>Gradle 提供了一种名为 extra property 的方法。extra property 是额外属性的意思，在第一次定义该属性的时候需要通过 ext 前缀来标示它是一个额外的属性。定义好之后，后面的存取就不需要 ext 前缀了。ext 属性支持 Project 和 Gradle 对象。即 Project 和 Gradle 对象都可以设置 ext 属性。</p>
<p>举个栗子：</p>
<ul>
<li>在 setting.gradle 文件为 Gradle 对象设置一些外置属性，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">def initGradleEnvironment()&#123;  </div><div class="line">    // 属性值从 local.properites 中读取  </div><div class="line">    Propertiesproperties = new Properties()  </div><div class="line">    File propertyFile = new File(rootDir.getAbsolutePath() +&quot;/local.properties&quot;)  </div><div class="line">    properties.load(propertyFile.newDataInputStream())  </div><div class="line">    //gradle 就是 gradle 对象。它默认是 Settings 和 Project 的成员变量。可直接获取  </div><div class="line">   //ext 前缀，表明操作的是外置属性。api 是一个新的属性名。前面说过，只在  </div><div class="line">   // 第一次定义或者设置它的时候需要 ext 前缀  </div><div class="line">    gradle.ext.api = properties.getProperty(&apos;sdk.api&apos;)  </div><div class="line">     </div><div class="line">    println gradle.api  // 再次存取 api 的时候，就不需要 ext 前缀了  </div><div class="line">    ......  </div><div class="line">&#125; </div><div class="line"></div><div class="line">// 调用初始化</div><div class="line">initGradleEnvironment()</div></pre></td></tr></table></figure>
<ul>
<li>再强化栗子，utils.gradle 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// utils.gradle 中定义了一个获取 AndroidManifests.xmlversionName 的函数  </div><div class="line">def  getVersionName()&#123;  </div><div class="line">   // 问题1：下面这行代码中的 project 是谁？  </div><div class="line">   defxmlFile = project.file(&quot;AndroidManifest.xml&quot;)  </div><div class="line">   defrootManifest = new XmlSlurper().parse(xmlFile)  </div><div class="line">   returnrootManifest[&apos;@android:versionName&apos;]    </div><div class="line">&#125;  </div><div class="line">// 现在，想把这个 API 输出到各个 Project。由于这个 utils.gradle 会被每一个 Project Apply，所以  </div><div class="line">// 我可以把 getVersionName 定义成一个 closure，然后赋值到一个外部属性  </div><div class="line"></div><div class="line">// 问题2：下面的 ext 是谁的 ext？  </div><div class="line">ext&#123; // 此段花括号中代码是闭包  </div><div class="line">    // 除了 ext.xxx=value 这种定义方法外，还可以使用 ext&#123;&#125;这种书写方法。  </div><div class="line">    //ext&#123;&#125;不是 ext(Closure) 对应的函数调用。但是 ext&#123;&#125;中的&#123;&#125;确实是闭包。  </div><div class="line">    getVersionName = this.&amp;getVersionName  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>先来理清楚一个问题，Project 和 utils.gradle 对于的 Script 的对象的关系是：</p>
<ul>
<li>当一个 Project apply 一个 gradle 文件的时候，这个 gradle 文件会转换成一个 Script 对象。这个，相信大家都已经知道了。</li>
<li>Script 中有一个 delegate 对象，这个 delegate 默认是加载（即调用 apply）它的 Project 对象。但是，在 apply 函数中，有一个 from 参数，还有一个 to 参数。通过 to 参数，你可以把 delegate 对象指定为别的东西。</li>
<li>delegate 对象是什么意思？当你在 Script 中操作一些不是 Script 自己定义的变量，或者函数时候，gradle 会到 Script 的 delegate 对象去找，看看有没有定义这些变量或函数。</li>
</ul>
<p>现在你知道问题 1,2 和答案了：</p>
<ul>
<li>问题 1：project 就是加载 utils.gradle 的 project。由于 b_sales_android 有多个 project，所以 utils.gradle 会分别加载到 project 中。所以，getVersionName 才不用区分到底是哪个 project。反正一个 project 有一个 utils.gradle 对应的 Script。</li>
<li>问题 2：ext：自然就是 Project 对应的 ext 了。此处为 Project 添加了一些 closure。那么，在 Project 中就可以调用 getVersionName 函数了</li>
</ul>
<p>一些思考：</p>
<ul>
<li>Java 和 Groovy 中：我们会把常用的函数放到一个辅助类和公共类中，然后在别的地方 import 并调用它们。</li>
<li>但是在 Gradle，更正规的方法是在 xxx.gradle 中定义插件。然后通过添加 Task 的方式来完成工作。gradle 的 user guide 有详细介绍如何实现自己的插件。</li>
</ul>
<ol>
<li>Task 介绍</li>
</ol>
<p>Task 是 Gradle 中的一种数据类型，它代表了一些要执行或者要干的工作。不同的插件可以添加不同的 Task。每一个 Task 都需要和一个 Project 关联。</p>
<p>Task 的 API 文档位于 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</a> 关于 Task，我这里简单介绍下 build.gradle 中怎么写它，以及 Task 中一些常见的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//Task 是和 Project 关联的，所以，我们要利用 Project 的 task 函数来创建一个 Task  </div><div class="line">task myTask  &lt;==myTask 是新建 Task 的名字  </div><div class="line">task myTask &#123; configure closure &#125;  </div><div class="line">task myType &lt;&lt; &#123; task action &#125; &lt;== 注意，&lt;&lt; 符号是 doLast 的缩写  </div><div class="line">task myTask(type: SomeType)  </div><div class="line">task myTask(type: SomeType) &#123; configure closure &#125;</div></pre></td></tr></table></figure>
<p>上述代码中都用了 Project 的一个函数，名为 task，注意：</p>
<ul>
<li>一个 Task 包含若干 Action。所以，Task 有 doFirst 和 doLast 两个函数，用于添加需要最先执行的 Action 和需要和需要最后执行的 Action。Action 就是一个闭包。</li>
<li>Task 创建的时候可以指定 Type，通过type: 名字表达。这是什么意思呢？其实就是告诉 Gradle，这个新建的 Task 对象会从哪个基类 Task 派生。比如，Gradle 本身提供了一些通用的 Task，最常见的有 Copy 任务。Copy 是 Gradle 中的一个类。当我们：task myTask(type:Copy)的时候，创建的 Task 就是一个 Copy Task。</li>
<li>当我们使用 task myTask{ xxx}的时候。花括号是一个 closure。这会导致 gradle 在创建这个 Task 之后，返回给用户之前，会先执行 closure 的内容。</li>
<li>当我们使用 task myTask &lt;&lt; {xxx}的时候，我们创建了一个 Task 对象，同时把 closure 做为一个 action 加到这个 Task 的 action 队列中，并且告诉它“最后才执行这个 closure”（注意，&lt;&lt; 符号是 doLast 的代表）。</li>
</ul>
<p><strong>讲了这么多东西，都有点烦了。是的，Gradle 用一整本书来讲都嫌不够呢！</strong></p>
<h2 id="3-4-3-b-sales-android-实例"><a href="#3-4-3-b-sales-android-实例" class="headerlink" title="3.4.3 b_sales_android 实例"></a>3.4.3 b_sales_android 实例</h2><p>现在正是开始通过例子来介绍怎么玩 gradle。这里要特别强调一点，根据 Gradle 的哲学。gradle 文件中包含一些所谓的 Script Block（姑且这么称它）。Script Block 作用是让我们来配置相关的信息。不同的 SB 有不同的需要配置的东西。这也是我最早说的行话。比如，源码对应的 SB，就需要我们配置源码在哪个文件夹里。关于 SB，我们后面将见识到！</p>
<p>b_sales_android 是一个 multi project。下面包含多个 Project。对于这种 Project，请大家回想下我们该创建哪些文件？</p>
<ul>
<li>settings.gradle 是必不可少的</li>
<li>根目录下的 build.gradle。这个我们没讲过，因为 b_sales_android 的根目录本身不包含代码，而是包含其他子 project。</li>
<li>每个 project 目录下包含对于的 build.gradle</li>
<li>另外，我把常用的函数封装到一个名为 utils.gradle 的脚本里了。</li>
</ul>
<p>马上一个一个来看它们：</p>
<ol>
<li>utils.gradle</li>
</ol>
<p>用来放一些获取版本号、拷贝文件等公共函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">import groovy.util.XmlSlurper  // 解析 XML 时候要引入这个 groovy 的 package  </div><div class="line"> </div><div class="line">def getVersionName() &#123;</div><div class="line">   defxmlFile = project.file(&quot;AndroidManifest.xml&quot;)  </div><div class="line">   defrootManifest = new XmlSlurper().parse(xmlFile)  </div><div class="line">   returnrootManifest[&apos;@android:versionName&apos;]    </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 对于 android library 编译，我会 disable 所有的 debug 编译任务  </div><div class="line">def disableDebugBuild() &#123;  </div><div class="line">  //project.tasks 包含了所有的 tasks，下面的 findAll 是寻找那些名字中带 debug 的 Task。  </div><div class="line">  // 返回值保存到 targetTasks 容器中  </div><div class="line">  def targetTasks = project.tasks.findAll&#123;task -&gt;  </div><div class="line">     task.name.contains(&quot;Debug&quot;)  </div><div class="line">  &#125;  </div><div class="line">  // 对满足条件的 task，设置它为 disable。如此这般，这个 Task 就不会被执行  </div><div class="line"> targetTasks.each&#123;  </div><div class="line">     println&quot;disable debug task  :$&#123;it.name&#125;&quot;  </div><div class="line">    it.setEnabled false  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line">// 将函数设置为 extra 属性中去，这样，加载 utils.gradle 的 Project 就能调用此文件中定义的函数了  </div><div class="line">ext&#123;  </div><div class="line">   getVersionName = this.&amp;getVersionName </div><div class="line">   disableDebugBuild = this.&amp;disableDebugBuild  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>setting.gradle</li>
</ol>
<p>这个文件中我们该干什么？调用 include 把需要包含的子 Project 加进来。代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">// 添加子 Project 信息  </div><div class="line">include &apos;:CRMApp&apos;</div><div class="line">include &apos;:biz-dev&apos;</div><div class="line">include &apos;:biz-test&apos;</div><div class="line">...</div><div class="line"></div><div class="line">/**</div><div class="line">  这个函数的目的是 </div><div class="line">  1  解析一个名为 local.properties 的文件，读取 AndroidSDK 和 NDK 的路径 </div><div class="line">  2  获取最终产出物目录的路径。这样，编译完的 apk 或者 jar 包将拷贝到这个最终产出物目录中 </div><div class="line">  3 获取 Android SDK 指定编译的版本 </div><div class="line">*/  </div><div class="line">def initXRKGradleEnvironment() &#123;   </div><div class="line">   println&quot;initialize xrk Gradle Environment .....&quot;  </div><div class="line">   Properties properties = new Properties()  </div><div class="line">   //local.properites 也放在 posdevice 目录下  </div><div class="line">   File propertyFile = new File(rootDir.getAbsolutePath()+ &quot;/local.properties&quot;)  </div><div class="line">   properties.load(propertyFile.newDataInputStream())  </div><div class="line">    /* </div><div class="line">      根据 Project、Gradle 生命周期的介绍，settings 对象的创建位于具体 Project 创建之前 </div><div class="line">      而 Gradle 底对象已经创建好了。所以，我们把 local.properties 的信息读出来后，通过 </div><div class="line">     extra 属性的方式设置到 gradle 对象中 </div><div class="line">      而具体 Project 在执行的时候，就可以直接从 gradle 对象中得到这些属性了！ </div><div class="line">    */  </div><div class="line">    gradle.ext.api =properties.getProperty(&apos;sdk.api&apos;)  </div><div class="line">    gradle.ext.sdkDir =properties.getProperty(&apos;sdk.dir&apos;)  </div><div class="line">     gradle.ext.ndkDir =properties.getProperty(&apos;ndk.dir&apos;)  </div><div class="line">     gradle.ext.localDir =properties.getProperty(&apos;local.dir&apos;)  </div><div class="line">    // 指定 debugkeystore 文件的位置，debug 版 apk 签名的时候会用到  </div><div class="line">    gradle.ext.debugKeystore= properties.getProperty(&apos;debug.keystore&apos;)  </div><div class="line">     ......  </div><div class="line">    println&quot;initialize xrk Gradle Environment completed...&quot;  </div><div class="line">&#125;  </div><div class="line">// 初始化  </div><div class="line">initXRKGradleEnvironment()</div></pre></td></tr></table></figure>
<p>注意，对于 Android 来说，local.properties 文件是必须的，它的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 注意，根据 Android Gradle 的规范，只有下面两个属性是必须的，其余都是我自己加的  </div><div class="line">sdk.dir=/Users/Nelson/Library/Android/sdk</div><div class="line">ndk.dir=/Users/Nelson/Library/Android/android-ndk-r16b</div><div class="line">sdk.api=android-21</div><div class="line">// 本地签名绝对地址</div><div class="line">debug.keystore=/Users/Nelson/Downloads/guazi/tools/mykeystore.jks  </div><div class="line">// 生成 library artifact 对应目录地址</div><div class="line">local.dir=/Users/Nelson/Downloads/guazi/xrk-flat-dir/</div></pre></td></tr></table></figure>
<ol>
<li>b_sales_android build.gradle </li>
</ol>
<p>作为 multi-project 根目录，一般情况下，它的 build.gradle 是做一些全局配置。来看我们的 build.gradle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 下面这个 subprojects&#123;&#125;就是一个 Script Block  </div><div class="line">subprojects &#123;  </div><div class="line">  println&quot;Configure for $project.name&quot; // 遍历子 Project，project 变量对应每个子 Project  </div><div class="line">  buildscript &#123;  // 这也是一个 SB  </div><div class="line">    repositories &#123;//repositories 是一个 SB  </div><div class="line">       ///jcenter 是一个函数，表示编译过程中依赖的库，所需的插件可以在 jcenter 仓库中  </div><div class="line">       // 下载。  </div><div class="line">       jcenter()  </div><div class="line">    &#125;  </div><div class="line">    dependencies &#123; //SB  </div><div class="line">        //dependencies 表示我们编译的时候，依赖 android 开发的 gradle 插件。插件对应的  </div><div class="line">       //class path 是 com.android.tools.build。版本是 3.1.4  </div><div class="line">        classpath&apos;com.android.tools.build:gradle:3.1.4&apos;  </div><div class="line">    &#125;  </div><div class="line">   // 为每个子 Project 加载 utils.gradle 。当然，这句话可以放到 buildscript 花括号之后  </div><div class="line">   applyfrom: rootProject.getRootDir().getAbsolutePath() + &quot;/utils.gradle&quot;  </div><div class="line"> &#125;//buildscript 结束  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>SB 在 Gradle 的 API 文档中也是有的。先来看 Gradle 定义了哪些 SB。</strong></p>
<p><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Project.html</a></p>
<p>你看，subprojects、dependencies、repositories 都是 SB。那么 SB 到底是什么？它是怎么完成所谓配置的呢？</p>
<p>仔细研究，你会发现 SB 后面都需要跟一个花括号，而花括号，恩，我们感觉里边可能一个 Closure。由于文档中这些 SB 的 Description 都有“Configure xxx for this project”，所以很可能 subprojects 是一个函数，然后其参数是一个 Closure。是这样的吗？</p>
<p>Absolutely right。只是这些函数你直接到 Project API 里不一定能找全。不过要是你好奇心重，不妨到 <a href="https://docs.gradle.org/current/javadoc/" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/</a> 选择 Index 这一项，然后 ctrl+f，输入任何一个 Block，你都会找到对应的函数。比如我替你找了几个 API：演示去文档查找，例如 buildscript <a href="https://docs.gradle.org/current/javadoc/index-all.html#I:B" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/index-all.html#I:B</a></p>
<p><strong>特别提示：当你下次看到一个不认识的 SB 的时候，就去看 API 吧。</strong></p>
<p>下面来解释代码中的各个 SB：</p>
<ul>
<li>subprojects：它会遍历 b_sales_android 中的每个子 Project。在它的 Closure 中，默认参数是子 Project 对应的 Project 对象。由于其他 SB 都在 subprojects 花括号中，所以相当于对每个 Project 都配置了一些信息。</li>
<li>buildscript：它的 closure 是在一个类型为 ScriptHandler 的对象上执行的。主要用来所依赖的 classpath 等信息。通过查看 ScriptHandler API 可知，在 buildscript SB 中，你可以调用 ScriptHandler 提供的 repositories(Closure )、dependencies(Closure) 函数。这也是为什么 repositories 和 dependencies 两个 SB 为什么要放在 buildscript 的花括号中的原因。明白了？这就是所谓的行话，得知道规矩。不知道规矩你就乱了。记不住规矩，又不知道查 SDK，那么就彻底抓瞎，只能到网上到处找答案了！</li>
<li>关于 repositories 和 dependencies，大家直接看 API 吧。后面碰到了具体代码我们再来介绍</li>
</ul>
<ol>
<li>BIZ-xxx build.gradle</li>
</ol>
<p>BIZ-xxx 是一个 Android Library。按 Google 的想法，Android Library 编译出来的应该是一个 AAR 文件。但是加入这时我们的项目有些特殊，我需要发布 xxx.jar 包给其他人使用。jar 在编译过程中会生成，但是它不属于 Android Library 的标准输出。在这种情况下，我需要在编译完成后，主动 copy jar 包到我自己设计的产出物目录中。</p>
<p>BIZ 下的工程都是一个个 Android Library。按 Google 的想法，Android Library 编译出来的应该是一个 AAR 文件。</p>
<p>问题：我现在需要发布 biz-xxx.jar 包给其他人使用，怎么办？</p>
<p>jar 在编译过程中会生成，但是它不属于 Android Library 的标准输出。在这种情况下，需要在编译完成后，主动 copy jar 包到我自己设计的产出目录中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">// Library 工程必须加载此插件。注意，加载了 Android 插件就不要加载 Java 插件了。因为 Android  </div><div class="line">// 插件本身就是拓展了 Java 插件  </div><div class="line">apply plugin: &apos;com.android.library&apos;   </div><div class="line">//android 的编译，增加了一种新类型的 ScriptBlock--&gt;android  </div><div class="line">android &#123;  </div><div class="line">       // 我在 local.properties 中设置的 API 版本号，就可以一次设置，多个 Project 使用了  </div><div class="line">      // 借助我特意设计的 gradle.ext.api 属性  </div><div class="line">       compileSdkVersion = gradle.api </div><div class="line">       sourceSets&#123; // 配置源码路径。这个 sourceSets 是 Java 插件引入的  </div><div class="line">           main&#123; //main：Android 也用了  </div><div class="line">               manifest.srcFile &apos;AndroidManifest.xml&apos; // 这是一个函数，设置 manifest.srcFile  </div><div class="line">               aidl.srcDirs=[&apos;src&apos;] // 设置 aidl 文件的目录  </div><div class="line">               java.srcDirs=[&apos;src&apos;] // 设置 java 文件的目录  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">        dependencies &#123;  // 配置依赖关系  </div><div class="line">          // compile 表示编译和运行时候需要的 jar 包，fileTree 是一个函数，  </div><div class="line">         // dir:&apos;libs&apos;，表示搜索目录的名称是 libs。include:[&apos;*.jar&apos;]，表示搜索目录下满足 *.jar 名字的 jar  </div><div class="line">         // 包都作为依赖 jar 文件  </div><div class="line">           compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  </div><div class="line">       &#125;  </div><div class="line">&#125;  //android SB 配置完了  </div><div class="line"></div><div class="line">// 前面说了，我要把 jar 包拷贝到指定的目录。对于 Android 编译，我一般指定 gradle assemble  </div><div class="line">// 它默认编译 debug 和 release 两种输出。所以，下面这个段代码表示：  </div><div class="line">//tasks 代表一个 Projects 中的所有 Task，是一个容器。getByName 表示找到指定名称的任务。  </div><div class="line">// 我这里要找的 assemble 任务，然后我通过 doLast 添加了一个 Action。这个 Action 就是 copy  </div><div class="line">// 产出物到我设置的目标目录中去  </div><div class="line"></div><div class="line">tasks.getByName(&quot;assemble&quot;)&#123;  </div><div class="line">   it.doLast&#123;  </div><div class="line">       println &quot;$project.name: After assemble, jar libs are copied tolocal repository&quot;  </div><div class="line">        copyOutput(true)</div><div class="line">        </div><div class="line">        // 具体函数内部如下：</div><div class="line">        from(&apos;build/intermediates/bundles/release/&apos;)</div><div class="line">        into(&apos;build/outputs/&apos;)</div><div class="line">        include(&apos;classes.jar&apos;)</div><div class="line">        rename (&apos;classes.jar&apos;, &apos;myLib.jar&apos;)</div><div class="line">        into(&apos;release/&apos;) //you can change this directory where you want to copy your .jar</div><div class="line">     &#125;  </div><div class="line">&#125;  </div><div class="line">/* </div><div class="line">  因为我的项目只提供最终的 release 编译出来的 Jar 包给其他人，所以不需要编译 debug 版的东西 </div><div class="line">  当 Project 创建完所有任务的有向图后，我通过 afterEvaluate 函数设置一个回调 Closure。在这个回调 </div><div class="line">  Closure 里，我 disable 了所有 Debug 的 Task </div><div class="line">*/  </div><div class="line">project.afterEvaluate&#123;  </div><div class="line">    disableDebugBuild()  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android 自己定义了很多 ScriptBlock，Android 定义的 DSL 参考文档在：</p>
<p><strong>Android Gradle Plugin release notes</strong></p>
<p><a href="https://developer.android.com/studio/releases/gradle-plugin" target="_blank" rel="external">https://developer.android.com/studio/releases/gradle-plugin</a></p>
<p>这条很重要，请惠存！里面包含了：<a href="http://google.github.io/android-gradle-dsl/current/" target="_blank" rel="external">Android Plugin DSL Reference</a>、<a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="external">Configure Your Build</a>、<a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Reference</a></p>
<p>AGP-Android Gradle Plugin 版本号</p>
<p><img desc="AGP 版本对比" src="http://wanghaoxun.com/img/gradle-agp-version.jpg" width="60%"></p>
<ol>
<li>CRMApp build.gradle</li>
</ol>
<p>再来看看 APK 的 build，它内部包含了编译（class，NDK），还有签名。</p>
<p>问题：根据项目需求，我们开发只能签 debug 版本的，而 release 版的签名得发布 unsigned 包给 leader 签名，怎么办？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;  //APK 编译必须加载这个插件  </div><div class="line">android &#123;  </div><div class="line">    compileSdkVersion gradle.api  </div><div class="line">    buildToolsVersion &quot;22.0.1&quot;  </div><div class="line">    sourceSets&#123; </div><div class="line">        main&#123;  </div><div class="line">            // 设置 jni 和 java 目录</div><div class="line">            jni.srcDirs = []  </div><div class="line">            java.srcDirs=[&apos;src&apos;]  </div><div class="line">               </div><div class="line">        &#125;  </div><div class="line">    &#125;//main 结束  </div><div class="line">    signingConfigs &#123; // 设置签名信息配置  </div><div class="line">        debug &#123;  // 如果我们在 local.properties 设置使用特殊的 keystore，则使用它  </div><div class="line">           // 下面这些设置，无非是函数调用.... 请务必阅读 API 文档  </div><div class="line">           if(project.gradle.debugKeystore != null)&#123;  </div><div class="line">              storeFile file(&quot;file://$&#123;project.gradle.debugKeystore&#125;&quot;)  </div><div class="line">              storePassword &quot;android&quot;  </div><div class="line">              keyAlias &quot;androiddebugkey&quot;  </div><div class="line">              keyPassword &quot;android&quot;  </div><div class="line">           &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;//signingConfigs 结束  </div><div class="line">    </div><div class="line">    buildTypes &#123;  </div><div class="line">        debug &#123;  </div><div class="line">            signingConfig signingConfigs.debug  </div><div class="line">            jniDebuggable false  </div><div class="line">        &#125;  </div><div class="line">    &#125;//buildTypes 结束  </div><div class="line">    </div><div class="line">    repositories &#123;  </div><div class="line">        flatDir &#123;//flatDir：告诉 gradle，编译中依赖的 jar 包存储在 dirs 指定的目录  </div><div class="line">           name &quot;minsheng-gradle-local-repository&quot; dirs gradle.LOCAL_JAR_OUT //LOCAL_JAR_OUT 是我存放编译出来的 jar 包的位置  </div><div class="line">        &#125;  </div><div class="line">    &#125;//repositories 结束  </div><div class="line">&#125;//android 结束  </div><div class="line">/* </div><div class="line">   创建一个 Task，类型是 Exec，这表明它会执行一个命令。我这里让他执行 ndk 的 </div><div class="line">   ndk-build 命令，用于编译 ndk。关于 Exec 类型的 Task，请自行脑补 Gradle 的 API </div><div class="line">*/  </div><div class="line">// 注意此处创建 task 的方法，是直接&#123;&#125;喔，那么它后面的 tasks.withType(JavaCompile)  </div><div class="line">// 设置的依赖关系，还有意义吗？Think！如果你能想明白，gradle 掌握也就差不多了  </div><div class="line">task buildNative(type: Exec, description: &apos;CompileJNI source via NDK&apos;) &#123;  </div><div class="line">       if(project.gradle.ndkDir == null) // 看看有没有指定 ndk.dir 路径  </div><div class="line">          println &quot;CANNOT Build NDK&quot;  </div><div class="line">       else&#123;  </div><div class="line">            commandLine &quot;/$&#123;project.gradle.ndkDir&#125;/ndk-build&quot;,  </div><div class="line">               &apos;-C&apos;, file(&apos;jni&apos;).absolutePath,  </div><div class="line">               &apos;-j&apos;, Runtime.runtime.availableProcessors(),  </div><div class="line">               &apos;all&apos;, &apos;NDK_DEBUG=0&apos;  </div><div class="line">        &#125;  </div><div class="line">  &#125;  </div><div class="line"> tasks.withType(JavaCompile) &#123;  </div><div class="line">       compileTask -&gt; compileTask.dependsOn buildNative  </div><div class="line">  &#125;  </div><div class="line">  .....</div></pre></td></tr></table></figure>
<ol>
<li>再来个实例演示</li>
</ol>
<p>问题：现在 App 有个特点，有三个版本，分别是 debug、release 和 demo。这三个版本对应的代码都一样，但是在运行的时候会跳转到 debug、release 或者 demo 的逻辑上。</p>
<p>办法：在编译 build、release 和 demo 版本前，在 build.gradle 中自动设置 runtime_config 的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;  // 加载 APP 插件  </div><div class="line"></div><div class="line">    signingConfigs &#123;</div><div class="line">        debug &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* </div><div class="line">     最关键的内容来了： buildTypes ScriptBlock。</div><div class="line">     buildTypes 和上面的 signingConfigs，当我们在 build.gradle 中通过&#123;&#125;配置它的时候， </div><div class="line">     其背后的所代表的对象是 NamedDomainObjectContainer&lt;BuildType&gt; 和 </div><div class="line">     NamedDomainObjectContainer&lt;SigningConfig&gt; </div><div class="line">     注意，NamedDomainObjectContainer&lt;BuildType 或者 SigningConfig&gt; 是一种容器， </div><div class="line">     容器的元素是 BuildType 或者 SigningConfig。我们在 debug&#123;&#125;要填充 BuildType 或者 </div><div class="line">    SigningConfig 所包的元素，比如 storePassword 就是 SigningConfig 类的成员。而 proguardFile 等 </div><div class="line">    是 BuildType 的成员。 </div><div class="line">    那么，为什么要使用 NamedDomainObjectContainer 这种数据结构呢？因为往这种容器里 </div><div class="line">    添加元素可以采用这样的方法： 比如 signingConfig 为例 </div><div class="line">    </div><div class="line">    signingConfigs &#123;// 这是一个 NamedDomainObjectContainer&lt;SigningConfig&gt; </div><div class="line">       test1&#123;// 新建一个名为 test1 的 SigningConfig 元素，然后添加到容器里 </div><div class="line">         // 在这个花括号中设置 SigningConfig 的成员变量的值 </div><div class="line">       &#125; </div><div class="line">      test2&#123;// 新建一个名为 test2 的 SigningConfig 元素，然后添加到容器里 </div><div class="line">         // 在这个花括号中设置 SigningConfig 的成员变量的值 </div><div class="line">      &#125; </div><div class="line">    &#125; </div><div class="line">    在 buildTypes 中，Android 默认为这几个 NamedDomainObjectContainer 添加了 </div><div class="line">    debug 和 release 对应的对象。如果我们再添加别的名字的东西，那么 gradle assemble 的时候 </div><div class="line">    也会编译这个名字的 apk 出来。比如，我添加一个名为 test 的 buildTypes，那么 gradle assemble </div><div class="line">    就会编译一个 xxx-test-yy.apk。在此，test 就好像 debug、release 一样。 </div><div class="line">   */  </div><div class="line">   buildTypes&#123;  </div><div class="line">        debug&#123; // 修改 debug 的 signingConfig 为 signingConfig.debug 配置  </div><div class="line">            signingConfig signingConfigs.debug  </div><div class="line">        &#125;  </div><div class="line">        demo&#123; //demo 版需要混淆  </div><div class="line">            proguardFile &apos;proguard-project.txt&apos;  </div><div class="line">            signingConfig signingConfigs.debug  </div><div class="line">        &#125;  </div><div class="line">       // release 版没有设置，所以默认没有签名，没有混淆  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    // 来看如何动态生成 runtime_config 文件  </div><div class="line">   def runtime_config_file = &apos;assets/runtime_config&apos;  </div><div class="line">   /* </div><div class="line">   我们在 gradle 解析完整个任务之后，找到对应的 Task，然后在里边添加一个 doFirst Action </div><div class="line">   这样能确保编译开始的时候，我们就把 runtime_config 文件准备好了。 </div><div class="line">   注意，必须在 afterEvaluate 里边才能做，否则 gradle 没有建立完任务有向图，你是找不到 </div><div class="line">   什么 preDebugBuild 之类的任务的 </div><div class="line">   */  </div><div class="line">   project.afterEvaluate&#123;  </div><div class="line">      // 找到 preDebugBuild 任务，然后添加一个 Action   </div><div class="line">      tasks.getByName(&quot;preDebugBuild&quot;)&#123;  </div><div class="line">           it.doFirst&#123;  </div><div class="line">               println &quot;generate debug configuration for $&#123;project.name&#125;&quot;  </div><div class="line">               def configFile = new File(runtime_config_file)  </div><div class="line">               configFile.withOutputStream&#123;os-&gt;  </div><div class="line">                   os &lt;&lt; I am Debug\n&apos;  // 往配置文件里写 I am Debug  </div><div class="line">                &#125;  </div><div class="line">           &#125;  </div><div class="line">        &#125;  </div><div class="line">       // 找到 preReleaseBuild 任务  </div><div class="line">       tasks.getByName(&quot;preReleaseBuild&quot;)&#123;  </div><div class="line">           it.doFirst&#123;  </div><div class="line">               println &quot;generate release configuration for $&#123;project.name&#125;&quot;  </div><div class="line">               def configFile = new File(runtime_config_file)  </div><div class="line">               configFile.withOutputStream&#123;os-&gt;  </div><div class="line">                   os &lt;&lt; I am release\n&apos;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">        &#125;  </div><div class="line">       // 找到 preDemoBuild。这个任务明显是因为我们在 buildType 里添加了一个 demo 的元素  </div><div class="line">      // 所以 Android APP 插件自动为我们生成的  </div><div class="line">       tasks.getByName(&quot;preDemoBuild&quot;)&#123;  </div><div class="line">           it.doFirst&#123;  </div><div class="line">               println &quot;generate offlinedemo configuration for$&#123;project.name&#125;&quot;  </div><div class="line">               def configFile = new File(runtime_config_file)  </div><div class="line">               configFile.withOutputStream&#123;os-&gt;  </div><div class="line">                   os &lt;&lt; I am Demo\n&apos;  </div><div class="line">               &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"> .....//copyOutput</div></pre></td></tr></table></figure>
<p>why？为什么我知道有 preXXXBuild 这样的任务？</p>
<p><strong>./gradlew tasks –all 查看所有任务。然后，多尝试几次，直到成功</strong></p>
<h1 id="四、锦囊文档集合"><a href="#四、锦囊文档集合" class="headerlink" title="四、锦囊文档集合"></a>四、锦囊文档集合</h1><h2 id="所有文档集合"><a href="#所有文档集合" class="headerlink" title="所有文档集合"></a>所有文档集合</h2><ol>
<li><p>Groovy-最新版本 v2.5.8</p>
<ul>
<li><a href="http://www.groovy-lang.org/download.html#gvm" target="_blank" rel="external">Groovy 官网</a> </li>
<li><p><a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">Groovy 的 API 文档地址</a></p>
<p>Groovy I/O</p>
</li>
<li><p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">java.io.File class</a></p>
</li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">java.io.InputStream class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">java.io.OutputStream class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" target="_blank" rel="external">java.io.Reader class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" target="_blank" rel="external">java.io.Writer class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" target="_blank" rel="external">java.nio.file.Path class</a></li>
</ul>
</li>
<li><p>Gradle–最新版本 v6.0.1</p>
<ul>
<li><a href="http://gradle.org/" target="_blank" rel="external">Gradle 官网</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Reference</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">Gradle-Project</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">Gradle-Task</a></li>
<li><a href="https://docs.gradle.org/current/javadoc/" target="_blank" rel="external">Gradle javadoc</a></li>
</ul>
</li>
<li><p>AGP-Android Gradle Plugin</p>
<ul>
<li><a href="https://developer.android.com/studio/releases/gradle-plugin" target="_blank" rel="external">Android Gradle Plugin release notes-Google Gradle 总入口</a></li>
<li><a href="http://google.github.io/android-gradle-dsl/current/" target="_blank" rel="external">Android Plugin DSL Reference</a></li>
<li><a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="external">Configure Your Build</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Reference</a></li>
</ul>
</li>
</ol>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>啰里啰嗦的讲了这么多 Gradle 知识，解开了它神秘的面纱，回想以前配置项目 Gradle 一直是我的心病，不知道如何下手，只能网上搜索，碰运气。走了不少弯路，直到完整学习了下 Gradle 框架，了解了套路，现在求解问题的思路也和以前不一样了：</p>
<ul>
<li>最开始的时候，我一直把 gradle 当做脚本看。然后到处到网上找怎么配置 gradle。可能能编译成功，但是完全不知道为什么。比如 NameDomainObjectContainer，为什么有 debug、release。能自己加别的吗？不知道怎么加，没有章法，没有参考。出了问题只能 google，找到一个解法，试一试，成功就不管。这么搞，心里不踏实。</li>
<li>另外，对语法不熟悉，尤其是 Groovy 语法，虽然看了下快速教材，但总感觉一到 gradle 就看不懂。主要问题还是闭包，比如 Groovy 那一节写得文件拷贝的例子中的 withOutputStream，还有 gradle 中的 withType，都是些啥玩意啊？</li>
<li>所以后来下决心先把 Groovy 学会，主要是把自己暴露在闭包里边。另外，Groovy 是一门语言，总得有 SDK 说明吧。写了几个例子，慢慢体会到 Groovy 的好处，也熟悉 Groovy 的语法了。</li>
<li>接着开始看 Gradle。Gradle 有几本书，我看过 Gradle in Action。说实话，看得非常痛苦。现在想起来，Gradle 其实比较简单，知道它的生命周期，知道它怎么解析脚本，知道它的 API，几乎很快就能干活。而 Gradle In Action 一上来就很细，而且没有从 API 角度介绍。说个很有趣的事情，书中有个类似下面的例子。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">task myTask  &lt;&lt;  &#123;</div><div class="line">   println &apos; I am myTask&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>书中说，如果代码没有加 &lt;&lt;，则这个任务在脚本 initialization（也就是你无论执行什么任务，这个任务都会被执行，I am myTask都会被输出）的时候执行，如果加了&lt;&lt;，则在 gradle myTask 后才执行。</p>
<p>换成现在我们理解的：</p>
<p>这和我们调用 task 这个函数的方式有关！如果没有 &lt;&lt;，则闭包在 task 函数返回前会执行，而如果加了 &lt;&lt;，则变成调用 myTask.doLast 添加一个 Action 了，自然它会等到 grdle myTask 的时候才会执行！</p>
<p><strong>API 说清楚了，如果你把 Gradle 当做编程框架来看，对于我们这些程序猿来说，写这几百行代码，那还算事嘛？？？</strong></p>
<p>完结~ 下一篇我们讲解项目实战 Gradle 编译那些事，敬请等候。。。</p>
<hr>
<p><strong>备注：Groovy 章节对应的代码在我本地，GitHub repo，嗯.. 先安全检查下再传上去吧，你懂的。。。</strong></p>
<h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><p>Blog</p>
<ul>
<li><a href="https://cn.udacity.com/course/gradle-for-android-and-java--ud867" target="_blank" rel="external">用 Gradle 构建 Android 和 Java by Google</a></li>
<li><a href="https://www.infoq.cn/article/android-in-depth-gradle/?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">邓平凡 | 深入理解 Android（一）：Gradle 详解</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Version 6.0.1</a></li>
</ul>
<p>UDACITY</p>
<ul>
<li><a href="https://cn.udacity.com/course/gradle-for-android-and-java--ud867" target="_blank" rel="external">Udacity | 用 Gradle 构建 Android 和 Java</a></li>
</ul>
<p>API</p>
<ul>
<li><a href="https://www.imooc.com/article/44169" target="_blank" rel="external">Groovy核心类源码讲解(下)</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持原创分享，您的支持将鼓励我继续创作！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/images/wechatpay.png" alt="LZH WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/images/alipay.jpg" alt="LZH Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/03/流程图/" rel="next" title="流程图">
                <i class="fa fa-chevron-left"></i> 流程图
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/04/04/性能优化之卡顿优化/" rel="prev" title="性能优化之卡顿优化">
                性能优化之卡顿优化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2020/04/03/深入理解-Gradle（一）：Gradle-详解/"
           data-title="深入理解 Gradle（一）：Gradle 详解" data-url="http://qq451682583.github.io/2020/04/03/深入理解-Gradle（一）：Gradle-详解/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/img/site.png"
               alt="LZH" />
          <p class="site-author-name" itemprop="name">LZH</p>
          <p class="site-description motion-element" itemprop="description">ZHBlog</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">31</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">12</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/qq451682583" target="_blank" title="GitHub">
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/your-user-name" target="_blank" title="Twitter">
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/5446495923/home?wvr=5" target="_blank" title="微博">
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/people/your-user-name" target="_blank" title="豆瓣">
                  
                  豆瓣
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/your-user-name" target="_blank" title="知乎">
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LZH</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ZHBlog"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
