<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ProtocolBuffer浅析</title>
    <url>/2020/04/11/ProtocolBuffer%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="ProtocolBuffer浅析"><a href="#ProtocolBuffer浅析" class="headerlink" title="ProtocolBuffer浅析"></a>ProtocolBuffer浅析</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>ProtocolBuffer是google 定义的一种数据交换的格式，它独立于语言，独立于平台。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。ProtocolBuffer类似于xml、json,不过它更小、更快、也更简单。</p>
<h4 id="与Json对比"><a href="#与Json对比" class="headerlink" title="与Json对比"></a>与Json对比</h4><p>目前使用最广泛的数据传输协议为JSON，JSON是一种轻量级的数据交换格式而且层次和结构比较简单和清晰，这里主要对比一下Protocol Buffer和JSON的对比，给出优势和劣势：</p>
<p><strong>优势</strong></p>
<ul>
<li>传输数据更小</li>
<li>序列化和反序列化更快</li>
<li>由于传输的过程中使用的是二进制，没有结构描述文件，无法解析内容，安全性更高</li>
</ul>
<p><strong>劣势</strong> </p>
<ul>
<li>由于传输过程使用的是二进制，自解释性较差，需要原有的结构描述文件才能解析</li>
</ul>
<p><strong>实际数据对比</strong></p>
<ul>
<li>序列化速度：比JSON快20-100倍</li>
<li>数据大小：序列化后体积小3倍</li>
</ul>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><hr>
<p>Protocol Buffer的使用流程总体可以分为三步，如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/9/16e4e03d98a97d18?imageslim" alt="image"></p>
<ol>
<li>根据业务创建并定义proto文件</li>
<li>使用Google Protocol Buffer 提供的工具生成对应语言的源文件</li>
<li>将源文件拷贝到工程中，使用Protocol Buffer提供的库序列化或反序列化数据</li>
</ol>
<h4 id="Android中使用"><a href="#Android中使用" class="headerlink" title="Android中使用"></a>Android中使用</h4><ol>
<li><p>在项目根目录的build.gradle中添加依赖：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    classpath <span class="string">'com.google.protobuf:protobuf-gradle-plugin:0.8.8'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>在app的gradle中添加插件</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">apply <span class="string">plugin:</span> <span class="string">'com.google.protobuf'</span><span class="comment">//添加插件</span></div></pre></td></tr></table></figure>
</li>
<li><p>在app的build.gradle添加如下代码</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">protobuf &#123;</div><div class="line">    protoc &#123;</div><div class="line">        artifact = <span class="string">'com.google.protobuf:protoc:3.7.1'</span> <span class="comment">// 也可以配置本地编译器路径</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    generateProtoTasks &#123;</div><div class="line">        all().each &#123; task -&gt;</div><div class="line">            task.builtins &#123;</div><div class="line">                java &#123;&#125;<span class="comment">// 生产java源码</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>添加proto文件的路径</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">    main &#123;</div><div class="line">        proto &#123;</div><div class="line">            srcDir <span class="string">'src/main/proto'</span></div><div class="line">        &#125;</div><div class="line">        java &#123;</div><div class="line">            srcDir <span class="string">'src/main/java'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>添加protobuf-java和protoc的依赖，其中protoc的依赖很重要，lite版中不需要添加</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">implementation <span class="string">'com.google.protobuf:protobuf-java:3.7.1'</span></div><div class="line">implementation <span class="string">'com.google.protobuf:protoc:3.7.1'</span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>google推荐在Android项目中使用lite版，lite版本生成的java文件更加轻量，其配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">protobuf &#123;</div><div class="line">    <span class="comment">//配置protoc编译器</span></div><div class="line">    protoc &#123;</div><div class="line">        artifact = <span class="string">'com.google.protobuf:protoc:3.8.0'</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里配置生成目录，编译后会在build的目录下生成对应的java文件</span></div><div class="line">    generateProtoTasks &#123;</div><div class="line">        all().each &#123; task -&gt;</div><div class="line">            task.builtins &#123;</div><div class="line">                java &#123;</div><div class="line">                    option <span class="string">"lite"</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">dependencies &#123;</div><div class="line">  implementation <span class="string">'com.google.protobuf:protobuf-javalite:3.8.0'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h2><hr>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>首先创建一个.proto文件，并且在文件中声明如下内容:</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line">syntax = <span class="string">"proto3"</span>;		<span class="comment">//标明当前proto使用的版本为proto3</span></div><div class="line"></div><div class="line"><span class="keyword">option</span> java_package = <span class="string">"com.jon.protocol.protobuf"</span>;  <span class="comment">//输出的java文件包名</span></div><div class="line"><span class="keyword">option</span> java_outer_classname = <span class="string">"Test"</span>;               <span class="comment">//输出的java文件名称</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">TestRequest</span></span>&#123;</div><div class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;    <span class="comment">//名称</span></div><div class="line">    <span class="built_in">int32</span> count = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>在整个proto文件中数据类型分为基本类型和结构类型，其中结构类型主要为:</p>
<ul>
<li>message</li>
<li>enum</li>
<li>map</li>
</ul>
<p>下面分别介绍一下不同结构的作用及规定：</p>
<h5 id="message"><a href="#message" class="headerlink" title="message"></a>message</h5><p>message表示一个结构，类似于java中类，一个proto文件中可以声明多个message结构：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</div><div class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</div><div class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</div><div class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</div><div class="line"> ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>message可以引用不同proto文件中的message，只要在proto文件中的最上面声明import即可，如下所示：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> <span class="string">"test.proto"</span>;</div></pre></td></tr></table></figure>
<h4 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h4><p>enum使用很简单，直接在message中声明enum结构体并且将属性声明为对应的enum即可：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">EnumRequest</span> </span>&#123;</div><div class="line">    Corpus corpus = <span class="number">1</span>;</div><div class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</div><div class="line">        UNIVERSAL = <span class="number">0</span>;</div><div class="line">        WEB = <span class="number">1</span>;</div><div class="line">        IMAGES = <span class="number">2</span>;</div><div class="line">        LOCAL = <span class="number">3</span>;</div><div class="line">        NEWS = <span class="number">4</span>;</div><div class="line">        PRODUCTS = <span class="number">5</span>;</div><div class="line">        VIDEO = <span class="number">6</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在proto3中，enum第一个值必须为0，主要是为了和基础类型的默认值保持一致</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map是proto3新加的，使用也很简单：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line">map&lt;key_type, value_type&gt; map_field = N;</div><div class="line"><span class="comment">//示例如下</span></div><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">MapRequest</span> </span>&#123;</div><div class="line">    map&lt;<span class="built_in">string</span>, TestRequest&gt; map = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><p>如下</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Python Type[2]</th>
<th>Go Type</th>
<th>Ruby Type</th>
<th>C# Type</th>
<th>PHP Type</th>
<th>Dart Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>float64</td>
<td>Float</td>
<td>double</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>float32</td>
<td>Float</td>
<td>float</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>int32</td>
<td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum or Bignum (as required)</td>
<td>int</td>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>int64</td>
<td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td>
<td>int64</td>
<td>long</td>
<td>int/long[3]</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string[5]</td>
<td>Int64</td>
</tr>
<tr>
<td>uint32</td>
<td>Uses variable-length encoding.</td>
<td>uint32</td>
<td>int[1]</td>
<td>int/long[3]</td>
<td>uint32</td>
<td>Fixnum or Bignum (as required)</td>
<td>uint</td>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>uint64</td>
<td>Uses variable-length encoding.</td>
<td>uint64</td>
<td>long[1]</td>
<td>int/long[3]</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string[5]</td>
<td>Int64</td>
</tr>
<tr>
<td>sint32</td>
<td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum or Bignum (as required)</td>
<td>int</td>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>sint64</td>
<td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td>
<td>int64</td>
<td>long</td>
<td>int/long[3]</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string[5]</td>
<td>Int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>Always four bytes. More efficient than uint32 if values are often greater than 228.</td>
<td>uint32</td>
<td>int[1]</td>
<td>int/long[3]</td>
<td>uint32</td>
<td>Fixnum or Bignum (as required)</td>
<td>uint</td>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>fixed64</td>
<td>Always eight bytes. More efficient than uint64 if values are often greater than 256.</td>
<td>uint64</td>
<td>long[1]</td>
<td>int/long[3]</td>
<td>uint64</td>
<td>Bignum</td>
<td>ulong</td>
<td>integer/string[5]</td>
<td>Int64</td>
</tr>
<tr>
<td>sfixed32</td>
<td>Always four bytes.</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>int32</td>
<td>Fixnum or Bignum (as required)</td>
<td>int</td>
<td>integer</td>
<td>int</td>
</tr>
<tr>
<td>sfixed64</td>
<td>Always eight bytes.</td>
<td>int64</td>
<td>long</td>
<td>int/long[3]</td>
<td>int64</td>
<td>Bignum</td>
<td>long</td>
<td>integer/string[5]</td>
<td>Int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>bool</td>
<td>TrueClass/FalseClass</td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
</tr>
<tr>
<td>string</td>
<td>A string must always contain UTF-8 encoded or 7-bit ASCII text, and cannot be longer than 232.</td>
<td>string</td>
<td>String</td>
<td>str/unicode[4]</td>
<td>string</td>
<td>String (UTF-8)</td>
<td>string</td>
<td>string</td>
<td>String</td>
</tr>
<tr>
<td>bytes</td>
<td>May contain any arbitrary sequence of bytes no longer than 232.</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>[]byte</td>
<td>String (ASCII-8BIT)</td>
<td>ByteString</td>
<td>strin</td>
</tr>
</tbody>
</table>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><ul>
<li>string：空串</li>
<li>bytes：空字节</li>
<li>bool：false</li>
<li>数字类型：0</li>
<li>enum：默认值是第一个元素，且值必须为0</li>
</ul>
<h4 id="repeated"><a href="#repeated" class="headerlink" title="repeated"></a>repeated</h4><p>repeated修饰的属性类似于jsonArray,也类似于java中的List，该修饰符在格式正确的消息中可以重复任意次（包括0次）</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">RepeatRequest</span> </span>&#123;</div><div class="line">    <span class="keyword">repeated</span> TestRequest requests = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字段编号"><a href="#字段编号" class="headerlink" title="字段编号"></a>字段编号</h4><ol>
<li>字段编号从1开始，不可重复定义</li>
<li>字段编号1-15尽量保持经常访问的字段使用，因为1-15编号在传输的过程中只占用1个字节</li>
</ol>
<h4 id="字段扩充"><a href="#字段扩充" class="headerlink" title="字段扩充"></a>字段扩充</h4><p>日常开发过程中，由于需求的变更，往往需要增加字段，这就涉及到字段的扩充，字段扩充需要达到一个目的：<strong>兼容</strong></p>
<p>所以Protocol Buffer在字段扩充中定义了如下规则：</p>
<ol>
<li><p>不要修改已经存在的字段标号</p>
</li>
<li><p>不用的字段，可以删除，但是编号一定不可以再次使用，建议将字段标为废弃，如加前缀：”OBSOLETE_”, 或者标记该字段为reserved</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line">reserved <span class="number">2</span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>只要记住上述规则，就能完成字段扩充且老版本也能兼容</p>
<h3 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h3><p>Protocol Buffer 更快更小的主要原因如下：</p>
<ol>
<li>数据在序列化的时候不会传输字段名，只会传输字段标号，并且没有被设置值的字段是不会序列化和传输</li>
<li>采用可变长度编码，优化数据占用</li>
</ol>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">TestRequest</span></span>&#123;</div><div class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;    <span class="comment">//名称</span></div><div class="line">    <span class="built_in">int32</span> count = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个例子中，在序列化时，”name” 、”count”的key值不会参与，由编号1、2代替，这样在反序列化的时候直接通过编号找到对应的key就可以。需要注意的是编号一旦确定就不可以更改，服务端和客户端通过proto通信的时候需要提前定义号数据格式。</p>
<ul>
<li>没有赋值的key，不参与序列化<br> 序列化时只会对赋值的key进行序列化，没有赋值的不参与，在反序列化的时候直接给默认值即可</li>
<li>可变长度编码<br> 可变长度编码，主要缩减整数占用字节实现，例如java中int占用4个字节，但是大多数情况下，我们使用的数字都比较小，使用1个字节就够了，这就是可变长度编码完成的事</li>
<li>TLV<br> TLV全称为Tag-Length-Value，其中Tag表示后面数据的类型，Length不一定有，根据Tag的值确定，Value就是数据了，TLV表示数据时，减少分隔符的使用，更加紧凑</li>
</ul>
<h4 id="T-L-V的数据存储方式"><a href="#T-L-V的数据存储方式" class="headerlink" title="T-L-V的数据存储方式"></a><strong>T-L-V</strong>的数据存储方式</h4><p><img src="https://i.postimg.cc/CKJzqfwJ/a-HR0c-Dov-L3-Vwb-G9h-ZC1pb-WFn-ZXMuamlhbn-Nod-S5pby91c-Gxv-YWRfa-W1h-Z2-Vz-Lzk0.png" alt=""></p>
<p>其中Length不一定有，依据Tag确定，例如int类型的数据就只有Tag-Value，string类型的数据就必须是Tag-Length-Value。</p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Protocol Buffer定义了如下的数据类型，其中部分数据类型已经不再使用：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>释义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>可变长度编码</td>
<td>int32 int64 uint32 uint64 sint32 sint64 bool enum</td>
</tr>
<tr>
<td>1</td>
<td>64位长度</td>
<td>fixed64 sfixed64 double</td>
</tr>
<tr>
<td>2</td>
<td>value 的长度</td>
<td>string bytes message packed repeated fiels</td>
</tr>
<tr>
<td>3</td>
<td>Start Group</td>
<td>废弃</td>
</tr>
<tr>
<td>4</td>
<td>End Group</td>
<td>废弃</td>
</tr>
<tr>
<td>5</td>
<td>32位长度</td>
<td>fixed32 sfixed32 float</td>
</tr>
</tbody>
</table>
<h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><p>上面已经介绍了Protocol Buffer的数据结构及Tag的类型，但是Tag块并不是只表示数据类型，其中数据编号也在Tag块中，Tag的生成规则如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line">(field_number &lt;&lt; <span class="number">3</span>) | wire_type</div></pre></td></tr></table></figure>
<p>其中Tag块的后3位表示数据类型，其他位表示数据编号</p>
<h3 id="可变长度编码"><a href="#可变长度编码" class="headerlink" title="可变长度编码"></a>可变长度编码</h3><p>Java中整数类型的长度都是确定的，如int类型的长度为4个字节，可表示的整数范围为-2^31——2^31-1，但是实际开发中用到的数字均比较小，会造成字节浪费，可变长度编码就能很好的解决这个问题，可变长度编码规则如下：</p>
<ul>
<li>字节最高位表示数据是否结束，如果最高位为1，则表示后面的字节也是该数据的一部分</li>
</ul>
<p>举个例子：</p>
<p><img src="https://i.postimg.cc/BvtX2nt0/16e69876dd1d471a-imageslim.png" alt="image"></p>
<p>其中第一个字节由于最高位为1，则后面的字节也是前面的数据的一部分，第二个字节最高位为0，则表示数据计算终止，由于Protocol Buffer是低位在前，整体的转换过程如下：</p>
<p><img src="https://i.postimg.cc/hjWchDdM/16e6997eb773d308-imageslim.png" alt="image"></p>
<p>10000001 00000011 ——&gt; 00000110000001 表示的10进制数为：2^0 + 2^7 + 2^8 = 385<br> 通过上面的例子可以知道一个字节表示的数的范围0-128，上面介绍的Tag生成算法中由于后3位表示数据类型，所以Tag中1-15编号只占用1个字节，所以确保编号中1-15为常用的，减少数据大小。</p>
<p>可变长度编码唯一的缺点就是当数很大的时候int32需要占用5个字节，但是从统计学角度来说，一般不会有这么大的数.</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>上面介绍了Protocol Buffer的原理，现在通过实例来展示分析过程，我们定义的proto文件如下：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">message</span> <span class="title">TestRequest</span></span>&#123;</div><div class="line">    <span class="built_in">string</span> name = <span class="number">1</span>;    <span class="comment">//名称</span></div><div class="line">    <span class="built_in">int32</span> count = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其序列化后的字节数据如下：</p>
<p><img src="https://i.postimg.cc/QCpV0ttL/testproto.png" alt="testproto.png"></p>
<p>前面介绍过Protocol Buffer的<strong>数据结构为TLV，其中L不是必须的，根据T的类型来确定</strong><br>先看下第一个字节：</p>
<p><img src="https://i.postimg.cc/BQs5H23f/16e69c909d30c944-imageslim.png" alt="image1"></p>
<p>这里字节最高位为0，所以该Tag就用这一个字节表示，其中后3位表示类型，前面表示字段编号，所以:</p>
<p>这里字节最高位为0，所以该Tag就用这一个字节表示，其中后3位表示类型，前面表示字段编号，所以:<br> file_num = 0001 = 1<br> type = 010 = 2<br> 上面介绍过type=2，则后面有Length，按照可变长度编码规则，知道表示长度的字节为：</p>
<p><img src="https://i.postimg.cc/WbC2xw1Q/16e69cd62541fa3a-imageslim.png" alt="image2"></p>
<p>所以Length=4,则value的长度是4个字节，直接取出后面4个字节：</p>
<p><img src="https://i.postimg.cc/ncyJ3Vdx/16e69cf670400a24-imageslim.png" alt="image3"></p>
<p>这4个字节对应的就是test<br> 再看下一组：</p>
<p><img src="https://i.postimg.cc/zfp4YqkV/16e69d19847ddfcf-imageslim.png" alt="image4"></p>
<p>由上面的Tag知道： file_num=2  type=0<br> 前面介绍过type=0，后面没有Length，直接就是value，</p>
<p><img src="https://i.postimg.cc/PfLfy7tm/16e69d3c5893f001-imageslim.png" alt="image5"></p>
<p>value=1，通过上面的解析可以知道</p>
<ol>
<li>file_num=1 value=test</li>
<li>file_num=2 value=1<br> 这样解析就结束了</li>
</ol>
<p>上面介绍了Protocol Buffer的原理，解释了为什么Protocol Buffer更快，更小，这里再总结一下：</p>
<ol>
<li>序列化的时候，不序列化key的name，只序列化key的编号</li>
<li>序列化的时候，没有赋值的key，不参与序列化，反序列化的时候直接使用默认值填充</li>
<li>可变长度编码，减小字节占用</li>
<li>TLV编码，去除没有的符号，使数据更加紧凑</li>
</ol>
<h2 id="长链接相关浅析"><a href="#长链接相关浅析" class="headerlink" title="长链接相关浅析"></a>长链接相关浅析</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>长连接，指在一个连接上可以连续发送多个<a href="https://baike.baidu.com/item/数据包/489739" target="_blank" rel="external">数据包</a>，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。</p>
<h3 id="http长链接"><a href="#http长链接" class="headerlink" title="http长链接"></a>http长链接</h3><p>HTTP协议本身是应用层协议，其长连接和短连接本质上是TCP长连接和短连接。 HTTP1.1规定了默认保持长连接（HTTP persistent connection ，也有翻译为持久连接），数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据。</p>
<h3 id="http协议里的keep-alive"><a href="#http协议里的keep-alive" class="headerlink" title="http协议里的keep-alive"></a>http协议里的keep-alive</h3><p>http1.1 协议里增加了 keepalive的支持， 并且默认开启。</p>
<p>客户端和服务端在建立连接并完成request后并不会立即断开TCP连接，而是在下次request来临时复用这次TCP连接。但是这里也必须要有TCP连接的timeout时间限制。不然会造成服务端端口被长期占用释放不了。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1967392-8335feea68acc6a2.png" alt="keepalive示意"></p>
<p>客户端和服务端在建立连接并完成request后并不会立即断开TCP连接，而是在下次request来临时复用这次TCP连接。但是这里也必须要有TCP连接的timeout时间限制。不然会造成服务端端口被长期占用释放不了。</p>
<p>对于不适用keepalive的request来说，不管是客户端还是服务端都是通过TCP的链接的断开知道request的结束（TCP 挥手时会check 数据包的 seq， 保证数据完整性）。<br> 支持keepalive后，如何知道request结束了呢？</p>
<ol>
<li>在Http1.1的版本里， 解决方案是request 和reponse里使用<strong>contentLength</strong>来帮助确认是否收到全部数据。</li>
<li>动态生成的文件没有Content-Length，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了,即如果要一边产生数据，一边发给客户端，服务器就需要使用”Transfer-Encoding: chunked”这样的方式来代替Content-Length。这时候就要根据chunked编码来判断，chunked编码的数据在最后有一个<strong>长度为0</strong>chunked块，表明本次传输数据结束.</li>
</ol>
<h4 id="管道机制-Pipelining"><a href="#管道机制-Pipelining" class="headerlink" title="管道机制(Pipelining)"></a><strong>管道机制(Pipelining)</strong></h4><p><img src="https://i.postimg.cc/3wgmkwqx/1920px-HTTP-pipelining.png" alt=""></p>
<p>HTTP Pipelining是把多个HTTP请求放到一个TCP连接中一一发送，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。但就像在超市收银台或者银行柜台排队时一样，你并不知道前面的顾客是干脆利索的还是会跟收银员/柜员磨蹭到世界末日。不管怎么说，服务器（即收银员/柜员）是要按照顺序处理请求的，如果前一个请求非常耗时（顾客磨蹭），那么后续请求都会受到影响，这就是所谓的线头阻塞（Head of line blocking）。</p>
<p>HTTP2.0 新增了多路复用的技术，通过在应用层http协议和传输层tcp协议之间增加一个二进制分帧层，将请求分为不同的帧，每一帧会标识出该帧属于哪个流，流是多个帧组成的数据流。所谓多路复用，即在一个TCP连接中存在多个流，即可以同时发送多个请求，对端可以通过帧中的表示知道该帧属于哪个请求。在客户端，这些帧乱序发送，到对端后再根据每个帧首部的流标识符重新组装。通过该技术，可以避免HTTP旧版本的队头阻塞问题，极大提高传输性能。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket是HTML5新增的协议，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。</p>
<p>为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。</p>
<p>这样一来，要在浏览器中搞一个实时聊天，在线炒股（不鼓励），或者在线多人游戏的话就没法实现了，只能借助Flash这些插件。</p>
<p>也有人说，HTTP协议其实也能实现啊，比如用轮询或者Comet。轮询是指浏览器通过JavaScript启动一个定时器，然后以固定的间隔给服务器发请求，询问服务器有没有新消息。这个机制的缺点一是实时性不够，二是频繁的请求会给服务器带来极大的压力。</p>
<p>Comet本质上也是轮询，但是在没有消息的情况下，服务器先拖一段时间，等到有消息了再回复。这个机制暂时地解决了实时性问题，但是它带来了新的问题：以多线程模式运行的服务器会让大部分线程大部分时间都处于挂起状态，极大地浪费服务器资源。另外，一个HTTP连接在长时间没有数据传输的情况下，链路上的任何一个网关都可能关闭这个连接，而网关是我们不可控的，这就要求Comet连接必须定期发一些ping数据表示连接“正常工作”。</p>
<p>以上两种机制都治标不治本，所以，HTML5推出了WebSocket标准，让浏览器和服务器之间可以建立无限制的全双工通信，任何一方都可以主动发消息给对方。</p>
<h3 id="WebSocket协议"><a href="#WebSocket协议" class="headerlink" title="WebSocket协议"></a>WebSocket协议</h3><p>WebSocket并不是全新的协议，而是利用了HTTP协议来建立连接。我们来看看WebSocket连接是如何创建的。</p>
<p>首先，WebSocket连接必须由浏览器发起，因为请求协议是一个标准的HTTP请求，格式如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">ws://localhost:3000/ws/chat</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: localhost</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Origin</span>: http://localhost:3000</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: client-random-string</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure>
<p>该请求和普通的HTTP请求有几点不同：</p>
<ol>
<li>GET请求的地址不是类似<code>/path/</code>，而是以<code>ws://</code>开头的地址；</li>
<li>请求头<code>Upgrade: websocket</code>和<code>Connection: Upgrade</code>表示这个连接将要被转换为WebSocket连接；</li>
<li><code>Sec-WebSocket-Key</code>是用于标识这个连接，并非用于加密数据；</li>
<li><code>Sec-WebSocket-Version</code>指定了WebSocket的协议版本。</li>
</ol>
<p>随后，服务器如果接受该请求，就会返回如下响应：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: server-random-string</div></pre></td></tr></table></figure>
<p>该响应代码<code>101</code>表示本次连接的HTTP协议即将被更改，更改后的协议就是<code>Upgrade: websocket</code>指定的WebSocket协议。</p>
<p>版本号和子协议规定了双方能理解的数据格式，以及是否支持压缩等等。如果仅使用WebSocket的API，就不需要关心这些。</p>
<p>现在，一个WebSocket连接就建立成功，浏览器和服务器就可以随时主动发送消息给对方。消息有两种，一种是文本，一种是二进制数据。通常，我们可以发送JSON格式的文本，这样，在浏览器处理起来就十分容易。</p>
<p>为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。</p>
<p>安全的WebSocket连接机制和HTTPS类似。首先，浏览器用<code>wss://xxx</code>创建WebSocket连接时，会先通过HTTPS创建安全的连接，然后，该HTTPS连接升级为WebSocket连接，底层通信走的仍然是安全的SSL/TLS协议。</p>
<p>参考资料：</p>
<p>proto3官网指南：<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/proto3</a></p>
<p>protobuf-gradle-plugin：<a href="https://github.com/google/protobuf-gradle-plugin" target="_blank" rel="external">https://github.com/google/protobuf-gradle-plugin</a></p>
<p>图床：<a href="https://postimages.org/" target="_blank" rel="external">https://postimages.org/</a></p>
<p>博客：<a href="https://juejin.im/post/5dcbf630e51d451bfe5bb21b" target="_blank" rel="external">https://juejin.im/post/5dcbf630e51d451bfe5bb21b</a></p>
<p>廖雪峰websocket：<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/1022910821149312/1103303693824096</a></p>
]]></content>
  </entry>
  <entry>
    <title>性能优化之卡顿优化</title>
    <url>/2020/04/04/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对用户来说，内存占用高、耗费电量、耗费流量可能不容易被发现，但是对于卡顿特别敏感，尤其在某些时候出现高频掉帧，俗称冻帧。对于开发者来说，卡顿问题非常难以排查定位，其产生的原因错综复杂，跟用户当前手机的 CPU<br>、内存、磁盘 I/O 等环境都可能有关系。所以，到底如何该定义卡顿？在我们平时开发又有哪些工具可以帮助开发更好的发现和排查问题？在线上又该监控卡顿情况呢？下面我们来一一解决这些困惑。</p>
<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-1-CPU-时间"><a href="#1-1-CPU-时间" class="headerlink" title="1.1 CPU 时间"></a>1.1 CPU 时间</h3><p>造成卡顿的原因可能有千百种，不过最终都会反映到 CPU 时间上，我们可以把 CPU 时间分为两种：用户时间和系统时间。用户时间就是执行用户态应用程序代码所消耗的时间；系统时间是执行内核态系统调用所消耗的时间，包括 I/O、锁、中断以及其他系统调用的时间。</p>
<p>评价一个 CPU 的性能，需要看主频、核心数、缓存等参数。</p>
<p>获取设备的 CPU 信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 获取 CPU 核心数</div><div class="line">cat /sys/devices/system/cpu/possible</div><div class="line"></div><div class="line">// 获取某个 CPU 的频率</div><div class="line">cat /sys/devices/system/cpu/cpu0/cpufeq/cpuinfo_max_freq</div></pre></td></tr></table></figure>
<p><img src="https://image1.guazistatic.com/qn190919122704652961c6fad0ec3086534ca4f9635097.jpg" title="CPU信息" width="60%" height="50%"></p>
<p>当出现卡顿问题的时候，怎么去区分究竟是我们代码的问题，还是系统的问题？用户时间和系统时间可以给我们哪些线索？这里需要两个非常重要的指标帮助我们做判断。</p>
<ul>
<li>CPU 的使用率</li>
</ul>
<p>可以通过 /proc/stat 得到整个系统的 CPU 使用情况，通过 /proc/[pid]/stat 可以得到某个进程的 CPU 使用情况。</p>
<p><img src="https://image1.guazistatic.com/qn1909191227041f49d7ed96d67ec483b751f8f758fef4.jpg" title="CPU 使用率" width="60%" height="50%"></p>
<p><img src="https://image1.guazistatic.com/qn190919122810e9828814066102aabd999558dd1e959c.jpg" title="向日葵进程CPU使用率" width="60%" height="50%"></p>
<p>参考链接：</p>
<ul>
<li><a href="http://www.samirchen.com/linux-cpu-performance/" target="_blank" rel="external">《Linux 环境下进程的CPU 占有率》</a></li>
<li><a href="http://man7.org/linux/man-pages/man5/proc.5.html" target="_blank" rel="external">Linux 文档</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">命令 </div><div class="line">    </div><div class="line">* top 命令</div><div class="line">帮助查看哪个进程是 CPU 的消耗大户</div><div class="line">    </div><div class="line">* vmstat 命令</div><div class="line">可以实时监控操作系统的虚拟内存和 CPU 活动；</div><div class="line">    </div><div class="line">* strace 命令</div><div class="line">    </div><div class="line">可以跟踪某个进程中所有的系统调用</div></pre></td></tr></table></figure>
<ul>
<li>CPU 饱和度</li>
</ul>
<p>CPU 饱和度反映的是线程排队等待 CPU 的情况，也就是 CPU 的负载情况。CPU 饱和度会跟应用的线程数有关，如果启动线程过多，容易导致系统不断地切换执行的线程，把大量的时间浪费在上下文切换，每次 CPU 上下文切换都需要刷新寄存器和计数器，至少需要十几纳秒的时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">命令</div><div class="line">    </div><div class="line">* vmstat 命令或者 /proc/[pid]/schedstat 文件</div><div class="line"></div><div class="line">查看 CPU 上下文切换次数，需要特别注意 nr_involuntary_switches 被动切换的次数。</div><div class="line">    </div><div class="line">// TODO</div><div class="line">    </div><div class="line">* uptime 命令</div><div class="line">查看 CPU 在1分钟、5分钟和15分钟内的平均负载，例如一个4核的 CPU，如果当前平均负载是 8，这意味着每个 CPU 上有一个线程在运行，还有一个线程在等待。一般平均负载建议控制在 0.7 x 核数 以内。</div><div class="line">    </div><div class="line">// TODO</div></pre></td></tr></table></figure>
<p>线程优先级-nice 值越低，抢占 CPU 时间片的能力越强。</p>
<h3 id="1-2-绘制原理"><a href="#1-2-绘制原理" class="headerlink" title="1.2 绘制原理"></a>1.2 绘制原理</h3><h4 id="1-2-1-UI-渲染背景知识"><a href="#1-2-1-UI-渲染背景知识" class="headerlink" title="1.2.1 UI 渲染背景知识"></a>1.2.1 UI 渲染背景知识</h4><h5 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h5><p>px、ppi、dpi、dp、density</p>
<p><img src="https://image1.guazistatic.com/qn190919110932352fb536e03597aa813ca1a5f301a706.png" title="屏幕适配概念图" width="60%" height="50%"></p>
<p>参考链接：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="external">一种极低成本的 Android 屏幕适配方式-今日头条适配方案</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 目前稳定高效的 UI 适配方案-smallestWidth 限定符适配方案</a></li>
</ul>
<h5 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h5><p>UI 渲染依赖两个核心的硬件：CPU 与 GPU。UI 组件在绘制到屏幕之前，都需要经过 Rasterization（格栅化）操作，而格栅化操作是一个耗时操作。GPU(Graphic processing Unit)也就是图形处理器，它主要用于处理图形运算，可能帮助我们加快格栅化操作。</p>
<p>软件绘制使用的是 Skia 库，它是一款能在低端机上呈现高质量的 2D 跨平台框架，类似 Chrome、Flutter 内部使用的都是 Skia 库。</p>
<p><img src="https://image1.guazistatic.com/qn190919111052ffeb2c38ef6bd21146e952bfa24093ba.png" title="CPU&GPU" width="60%" height="50%"></p>
<h5 id="OpenGL-与-Vulkan"><a href="#OpenGL-与-Vulkan" class="headerlink" title="OpenGL 与 Vulkan"></a>OpenGL 与 Vulkan</h5><p>对于硬件绘制，通过调用 OpenGL ES 接口利用 GPU 完成绘制。<a href="https://developer.android.com/guide/topics/graphics/opengl" target="_blank" rel="external">OpenGL</a> 是一个跨平台的图形 API，它为 2D/3D 图形处理硬件指定了标准软件接口，而 OpenGL ES 是 OpenGL 的子集，专为嵌入式设备设计。</p>
<p>Android 7.0 把 <a href="https://www.khronos.org/opengles/" target="_blank" rel="external">OpenGL ES</a> 升级到最新的 3.2 版本同时，还添加了对 <a href="https://developer.android.com/guide/topics/graphics/opengl" target="_blank" rel="external">Vulkan</a>的支持，Vulkan 是用于高性能 3D 图形的低开销、跨平台 API。相比 OpenGL ES，Vulkan 在改善功耗、多核优化提升绘图调用上有着非常明显的优势。</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.android.com/guide/topics/graphics/hardware-accel" target="_blank" rel="external">官方硬件加速文档</a></li>
</ul>
<h4 id="1-2-2-Android-渲染的演进"><a href="#1-2-2-Android-渲染的演进" class="headerlink" title="1.2.2 Android 渲染的演进"></a>1.2.2 Android 渲染的演进</h4><h5 id="Android-图形系统整体架构"><a href="#Android-图形系统整体架构" class="headerlink" title="Android 图形系统整体架构"></a>Android 图形系统整体架构</h5><p><img src="https://image1.guazistatic.com/qn1909191113170c6c33689b84f89cffb7158bf39c677b.png" title="Android图形系统整体架构" width="60%" height="50%"></p>
<ul>
<li>画笔：Skia 或者 OpenGL</li>
<li>画纸：Surface</li>
<li>画板：Graphic Buffer</li>
<li>显示：SurfaceFlinger</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://source.android.com/devices/graphics" target="_blank" rel="external">Android图形系统整体架构</a></li>
</ul>
<h5 id="硬件加速绘制"><a href="#硬件加速绘制" class="headerlink" title="硬件加速绘制"></a>硬件加速绘制</h5><h6 id="Android-3-0-软件绘制"><a href="#Android-3-0-软件绘制" class="headerlink" title="Android 3.0 软件绘制"></a>Android 3.0 软件绘制</h6><p>在 Android 3.0 之前，或者没有启动硬件加速时，系统都会使用软件方式来渲染 UI。</p>
<p>整个流程如上图所示： </p>
<ul>
<li>Surface。每个 View 都由某一个窗口管理，而每一个窗口都关联有一个 Surface。</li>
<li>Canvas。通过 Surface 的 lock 函数获得一个 Canvas，Canvas 可以简单理解为 Skia 底层接口的封装。</li>
<li>Graphic Buffer。SurfaceFlinger 会帮我们托管一个 BufferQueue，我们从 BufferQueue 中拿到 Graphic Buffer，然后通过 Canvas 以及 Skia 将绘制内容栅格化到上面。</li>
<li>SurfaceFlinger。通过 Swap Buffer 把 Front Graphic Buffer 的内容交给 SurfaceFinger，最后硬件合成器 Hardware Composer 合成并输出到显示屏。</li>
</ul>
<h6 id="Android-4-0-开启硬件加速"><a href="#Android-4-0-开启硬件加速" class="headerlink" title="Android 4.0 开启硬件加速"></a>Android 4.0 开启硬件加速</h6><ul>
<li>从 Androd 3.0 开始，Android 开始支持硬件加速，到 Android 4.0 时，，默认开启硬件加速。</li>
</ul>
<p><img src="https://image1.guazistatic.com/qn19091911154999d60646d9219d8b1e6218e68a2c44e3.png" title="Android3.0软件绘制" width="60%" height="50%"></p>
<p><img src="https://image1.guazistatic.com/qn190919111942b4b368029f2a1347d4c80daed7f422af.png" title="Android4.0+硬件加速" width="60%" height="50%"></p>
<p>硬件加速核心是通过 GPU 完成 Graphic Buffer 的内容绘制，此外硬件绘制还引入了一个 DisplayList 的概念，每个 View 内部都有一个 DisplayView，当某个 View 需要重绘时，将它标记为 Dirty，不需要像软件绘制向上递归，这样可以大大减少绘图的操作数量，提升渲染效率。</p>
<p><img src="https://image1.guazistatic.com/qn1909191120489667933f36eb46ea66108b6b56b8d9fc.png" title="View的DisplayList局部刷新" width="60%" height="50%"></p>
<h5 id="Project-Butter-黄油计划"><a href="#Project-Butter-黄油计划" class="headerlink" title="Project Butter 黄油计划"></a>Project Butter 黄油计划</h5><p>Android 4.1：Project Butter 主要包含两个组成部分，一个是 VSYNC，一个是 Triple Buffering。</p>
<p>VSYNC 信号</p>
<p><img src="https://image1.guazistatic.com/qn19091911240594e2ad944f08925fda3b071594b2a253.png" title="VSYNC信号" width="60%" height="50%"></p>
<p>三级缓冲机制 Triple Buffering</p>
<p><img src="https://image1.guazistatic.com/qn1909191124058eeb7346852a1e58a73f2c77738fc44a.png" title="三级缓冲机制 Triple Buffering" width="60%" height="50%"></p>
<p>Jank渲染超时</p>
<p><img src="https://image1.guazistatic.com/qn190919112405c9440b92128ff74dc9a20a0c14f4366a.png" title="Jank渲染超时" width="60%" height="50%"></p>
<h5 id="Android-5-0-RenderThread-异步渲染"><a href="#Android-5-0-RenderThread-异步渲染" class="headerlink" title="Android 5.0: RenderThread 异步渲染"></a>Android 5.0: RenderThread 异步渲染</h5><p><img src="https://image1.guazistatic.com/qn190919112854e8df57ca4577f04a8805d85c73edd18c.png" title="RenderThread工作" width="60%" height="50%"></p>
<h5 id="数据测量"><a href="#数据测量" class="headerlink" title="数据测量"></a>数据测量</h5><ul>
<li>绘制过度工具</li>
</ul>
<p>在 Android 4.2，系统增加了检测绘制过度工具。</p>
<p><img src="https://image1.guazistatic.com/qn1909191127242810c169379808a29814b4a234f76f70.png" title="检测绘制过度工具" width="50%" height="50%"></p>
<p>参考资料：<a href="https://developer.android.com/studio/profile/inspect-gpu-rendering" target="_blank" rel="external">检查 GPU 渲染进度和绘制过度</a></p>
<h5 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h5><p>在 Android 6.0 的时候，Android 在 gxinfo 添加了更详细的信息；在 Android 7.0 又对 HWUI 进行了一些重构，而且支持了 Vulkan；在 Android P 支持了 Vulkun 1.1。相信在未来不久的 Android Q，更好地支持 Vulkan 将是一个必然的方向。</p>
<p>总的来说，UI 渲染的优化必然会朝着两个方向。一个是进一步压榨硬件的性能，让 UI 可以更加流畅。一个是改进或者增加更多的分析工具，帮助我们更容易地发现以及定位问题。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>虽然硬件加速绘制极大提高了 Android 系统显示和刷新的速度，但它也存在一些问题，一方面是内存消耗，另一方面是兼容性问题，部分绘制函数不支持，更可怕的是硬件加速绘制流程本身存在 Bug。</p>
<h4 id="1-2-3-如何优化-UI-渲染？"><a href="#1-2-3-如何优化-UI-渲染？" class="headerlink" title="1.2.3 如何优化 UI 渲染？"></a>1.2.3 如何优化 UI 渲染？</h4><h5 id="adb-命令"><a href="#adb-命令" class="headerlink" title="adb 命令"></a>adb 命令</h5><ul>
<li>gfxinfo，可以输出包含各阶段发生的动画以及帧相关的性能信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 渲染相关的内存和 View hierarchy 信息</div><div class="line">adb shell dumpsys gfxinfo 包名</div><div class="line"></div><div class="line">// 拿到最近 120 帧每个绘制阶段的耗时信息</div><div class="line">adb shell dumpsys gfxinfo 包名 framestats</div></pre></td></tr></table></figure>
<ul>
<li>SurfaceFlinger</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 查看 Graphic Buffer 占用的内存</div><div class="line">adb shell dumpsys SurfaceFlinger</div></pre></td></tr></table></figure>
<h5 id="UI-优化常用手段"><a href="#UI-优化常用手段" class="headerlink" title="UI 优化常用手段"></a>UI 优化常用手段</h5><p><img src="https://image1.guazistatic.com/qn1909191222242370be9975cefc6f0924e6b07b0f7e28.png" title="UI 渲染阶段流程图" width="60%" height="50%"></p>
<h6 id="尽量使用硬件加速"><a href="#尽量使用硬件加速" class="headerlink" title="尽量使用硬件加速"></a>尽量使用硬件加速</h6><p>如果使用了不支持的 API，系统就需要通过 CPU 软件模拟绘制，这也是渐变、磨砂、圆角等效果渲染性能比较低的原因。</p>
<p>SVG 是个典型的例子，SVG 有很多指令硬件加速都不支持，我们可以用一个取巧的方法，提前将这些 SVG 转换为 Bitmap 缓存起来，这样系统就可以更好地使用硬件加速绘制。同理，对于圆角、渐变等场景，我们也可以改为 Bitmap 实现。</p>
<p>问题：如何提前生成 Bitmap，以及 Bitmap 的内存需要如何管理，可以参考市面上常用图片库的实现！</p>
<h6 id="Create-View-优化"><a href="#Create-View-优化" class="headerlink" title="Create View 优化"></a>Create View 优化</h6><ul>
<li>使用代码创建</li>
</ul>
<p>使用一些开源的 XML 转换为 Java 代码工具，例如 <a href="https://github.com/iReaderAndroid/X2C" target="_blank" rel="external">X2C</a>。建议在一些修改不频繁的场景下使用这种方式。</p>
<ul>
<li>异步创建</li>
</ul>
<p>在线程提前创建 View，实现 UI 的预加载，在使用线程创建 UI 的时候，先把线程 Looper 的 MessageQueue 替换为 UI 线程 Looper 的 Queue，在创建完 View 后需要把线程 Looper 恢复成原来的。</p>
<p><img src="https://image1.guazistatic.com/qn1909191220478850f7025622ef2529abf43fcddf89cd.png" title="异步创建 View" width="60%" height="50%"></p>
<ul>
<li>View 重用</li>
</ul>
<p>View 会随着 Activity 的销毁而销毁，ListView、RecyclerView 通过 view 的缓存与重用大大提升渲染性能，因此我们可以参考它们的思想，实现一套可以在不同 Activity 或 Fragment 使用的 View 缓存机制。注意：需要保证所有进入缓存池的 View 都是干净的，不会保留之前的状态。</p>
<p><img src="https://image1.guazistatic.com/qn19091911515882e0dd5e9ca72774ed332aed9ea95ce0.png" title="View 重用" width="60%" height="50%"></p>
<h6 id="measure-layout-优化"><a href="#measure-layout-优化" class="headerlink" title="measure/layout 优化"></a>measure/layout 优化</h6><ul>
<li>减少 UI 布局层次</li>
</ul>
<p>尽量扁平化，使用<viewstub> <merge> 等优化。</merge></viewstub></p>
<ul>
<li>优化 layout 开销</li>
</ul>
<p>尽量不用 RelativeLayout 或者基于 weighted LinearLayout，它们 layout 的开销非常巨大，推荐使用 ConstraintLayout 替代 RL 或者 weighted LL。</p>
<ul>
<li>背景优化</li>
</ul>
<p>尽量不要重复设置主题背景(Theme)，theme 默认会是一个纯色背景，如果我们自定义了界面的背景，那么主题的背景对我们来说是无用的，由于主题背景设置在 DecorView 中，所以这里会带来重复绘制，会带来绘制性能损耗。</p>
<h5 id="UI-进阶优化"><a href="#UI-进阶优化" class="headerlink" title="UI 进阶优化"></a>UI 进阶优化</h5><h6 id="Litho-异步布局"><a href="#Litho-异步布局" class="headerlink" title="Litho: 异步布局"></a>Litho: 异步布局</h6><ul>
<li>异步布局</li>
</ul>
<p>Android 主线程，measure -&gt; layout -&gt; draw </p>
<p><img src="https://image1.guazistatic.com/qn190919120250bea4eb101e8a0cfadfa6fdfeeece45d7.png" title="Android 主线程布局" width="60%" height="50%"></p>
<p>Litho异步布局</p>
<p><img src="https://image1.guazistatic.com/qn190919120250831ba0eadde92d1d63638132e956f1e2.png" title="Litho异步布局" width="60%" height="50%"></p>
<ul>
<li>界面扁平化</li>
</ul>
<p><img src="https://image1.guazistatic.com/qn190919120437803b746a1a64157aa23855f0fe31dc1a.png" title="界面扁平化" width="60%" height="50%"></p>
<ul>
<li>优化 RecyclerView</li>
</ul>
<p><img src="https://image1.guazistatic.com/qn190919120509f3e132a3ffc901191b766947cf5d711c.png" title="优化RecyclerView" width="60%" height="50%"></p>
<p>Litho 优化了 RV 中 UI 组件的缓存和回收方法，原生 RV 或者 LV 都是按照 viewType 来进行缓存和回收，但如果一个 RV/LV 中出现了 viewType 过多，会是缓存形同虚设，Litho 是按照 text、image 和 video 独立回收，可以提高缓存命中率、降低内存使用率、提高滚动帧率。</p>
<p>缺点：Litho 实现了 measure/layout 异步化，使用了类似 react 单向数据流设计，一定程度上加大了 UI 开发的复杂度，并且 Litho 的 UI 代码是使用 java/kotlin 进行编写，无法在 AS 中预览。</p>
<h6 id="RenderThread-与-RenderScript"><a href="#RenderThread-与-RenderScript" class="headerlink" title="RenderThread 与 RenderScript"></a>RenderThread 与 RenderScript</h6><p>在 Android 5.0，系统增加了 RenderThread，对于 ViewPropertyAnimator 和 CircularReveal 动画，我们可以使用 <a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect" target="_blank" rel="external">RenderThread:异步渲染动画</a>，当主线程阻塞的时候，普通动画会出现明显的丢帧卡顿，而使用 RenderThread 渲染的动画即使阻塞了主线程仍不受影响。</p>
<p>现在越来越多的应用会使用一些高级图片或者视频编辑功能，例如图片的高斯模糊、放大、锐化等。拿日常我们使用最多的“扫一扫”这个场景来看，这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。</p>
<p>图片的变换涉及大量的计算任务，这个时候使用 GPU 是更好的选择，那如何进一步压榨系统 GPU 的性能呢？</p>
<p>我们可以通过<a href="https://developer.android.com/guide/topics/renderscript/compute" target="_blank" rel="external">RenderScript</a>，它是 Android 操作系统上的一套 API。它基于异构计算思想，专门用于密集型计算。</p>
<h6 id="Flutter-自己的布局-渲染引擎"><a href="#Flutter-自己的布局-渲染引擎" class="headerlink" title="Flutter: 自己的布局 + 渲染引擎"></a>Flutter: 自己的布局 + 渲染引擎</h6><p><img src="https://image1.guazistatic.com/qn190919122132614a269a091e353f4745895cb8b87b85.png" title="Flutter 渲染流程" width="60%" height="50%"></p>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><ol>
<li>在系统的框架下优化。布局优化、使用代码创建、View 缓存等都思路，减少甚至省下渲染流水线里某个阶段的耗时。</li>
<li>利用系统的新特性。使用硬件加速、RenderThread、RenderScript 等，通过系统一些新的特性，最大限度压榨出性能。</li>
<li>突破系统的限制，Android 碎片化很严重，很多好的特性可能低版本系统并不支持，一些特定的场景下它无法实现最优解。这时候，就要突破系统的条条框框，例如 Facebook-Litho 突破了布局渲染过程，Flutter 更近一步，把渲染都接管过来。</li>
</ol>
<blockquote>
<p>在 UI 优化时，第一阶段的优化在系统的束缚下也可以达到非常不错的效果。不过越到后面越容易出现瓶颈，这时就需要进一步往底层走，可以对整个架构有更大的掌控力，需要造自己的「轮子」！</p>
</blockquote>
<h2 id="二、Android-卡顿排查工具"><a href="#二、Android-卡顿排查工具" class="headerlink" title="二、Android 卡顿排查工具"></a>二、Android 卡顿排查工具</h2><h3 id="2-1-Traceview"><a href="#2-1-Traceview" class="headerlink" title="2.1 Traceview"></a>2.1 Traceview</h3><p>利用 Android Runtime 函数调用的 event 事件，将函数运行的耗时和调用关系写入 trace 文件中。可监控 Android framework、java、应用程序代码。</p>
<p>在 Android 5.0 之后，新增了 startMethodTracingSampling 方法，可以使用基于样本的方式进行分析，以减少对运行时的性能影响。新增了 sample 类型后，就需要我们在开销和信息丰富度之间做好权衡。</p>
<p>TraceView 的生成</p>
<ol>
<li>代码调用</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">// 生成traceView的起点，保存traceView的名称（路径：/mnt/sdcard/fileName）</span></div><div class="line">    Debug.startMethodTracing(<span class="string">"fileName"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</div><div class="line">    Debug.stopMethodTracing();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<center class="half"><br>    <img src="https://image1.guazistatic.com/qn1909191231155fed9e563e7274b32df4349ac9f6a012.jpg" width="50%"><br>    <img src="https://image1.guazistatic.com/qn1909191231153f36511aa2721267d0f680d6873f7dcd.jpg" width="50%"><br></center>


<p>缺点：工具本身带来的性能开销过大，有时候无法真实反映情况，比如一个函数本身的耗时是 1 秒，开启 TraceView 后可能变成 5 秒，而且这些函数的耗时变化并不是成比例放大。</p>
<ol>
<li>DDMS</li>
</ol>
<p>Android Device Monitor(DDMS)，选择进程 attached，点击trace 开始，操作app, trace 结束，分析结果。</p>
<p>ps：DDMS 可通过命令 monitor 直接打开，目录在 /sdk/tools 下。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://www.jianshu.com/p/7e9ca2c73c97" target="_blank" rel="external">Android性能优化—TraceView的使用</a></li>
<li><a href="https://www.oschina.net/news/56500/traceview-android" target="_blank" rel="external">正确使用 Android 性能分析工具——TraceView</a></li>
</ul>
<h3 id="2-2-systrace"><a href="#2-2-systrace" class="headerlink" title="2.2 systrace"></a>2.2 systrace</h3><p>Android 4.1 新增的性能分析工具，经常使用 systrace 来跟踪系统的 I/O 操作、CPU 负载、Surface 渲染、GC 等事件。</p>
<p>系统预留接口来监控应用程序的调用耗时，可以在可疑引起 jank 代码的地方，添加如下代码，这两个是成对出现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Trace.beginSection(<span class="string">"tag"</span>);</div><div class="line">Trace.endSection();</div></pre></td></tr></table></figure>
<p><img src="https://image1.guazistatic.com/qn19091912343088c96647027b9347f0129f313fa97658.jpg" title="Trace演示代码" width="60%" height="50%"></p>
<p><img src="https://image1.guazistatic.com/qn19091912343009d4bf336f3d0190aac7a4a8ffc1bb4f.jpg" title="systrace使用演示" width="60%" height="50%"></p>
<p>参考资料：</p>
<ul>
<li><a href="https://www.cnblogs.com/blogs-of-lxl/p/10926824.html" target="_blank" rel="external">Android：通过systrace进行性能分析</a></li>
<li><a href="https://www.jianshu.com/p/75aa88d1b575" target="_blank" rel="external">Android Systrace 使用方法</a></li>
<li><a href="http://ddrv.cn/a/89930/" target="_blank" rel="external">Android Systrace的使用和分析</a></li>
<li><a href="https://www.jianshu.com/p/e9e05ce5b0c9" target="_blank" rel="external">在Android Studio下使用Hierarchy Viewer</a></li>
</ul>
<p>怎样在 systrace 上面自动增加应用程序的耗时分析呢？</p>
<blockquote>
<p>编译时给每个函数插桩的方式来实现，在重要函数的入口和出口分别增加 Trace 代码，实现在 systrace 基础上增加应用程序耗时的监控。</p>
</blockquote>
<h3 id="2-3-AS-Profiler"><a href="#2-3-AS-Profiler" class="headerlink" title="2.3 AS-Profiler"></a>2.3 AS-Profiler</h3><p>Android Studio 自带 Profiler 工具，可以检测 CPU、memory等，点击 View -&gt; Tool Window -&gt; Profiler 打开工具使用。</p>
<p><img src="http://app.guazistatic.com/AS_Profiler.jpg" title="AS-Profiler" width="60%" height="50%"></p>
<p>参考链接：</p>
<ul>
<li><a href="https://developer.android.com/studio/profile/android-profiler?hl=zh-cn" target="_blank" rel="external">利用 Android Profiler 测量应用性能</a></li>
<li><a href="https://www.jianshu.com/p/e75680772375" target="_blank" rel="external">Android Studio 3.0 Memory Profiler使用
</a></li>
</ul>
<h3 id="2-4-Simpleperf"><a href="#2-4-Simpleperf" class="headerlink" title="2.4 Simpleperf"></a>2.4 Simpleperf</h3><p>Android 5.0 新增了 Simpleperf 性能分析工具，分析 Native 函数的调用，它利用 CPU 的性能监控单元 （PMU）提供的硬件 perf 事件，使用 Simpleperf 可以看到所有的 Native 代码的耗时，有时候一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等。</p>
<p>Simpleperf 同时封装了 systrace 的监控功能，现在 Simpleperf 比较友好地支持 Java 代码的性能分析。</p>
<h3 id="其它-Nanoscope"><a href="#其它-Nanoscope" class="headerlink" title="其它 Nanoscope"></a>其它 Nanoscope</h3><p>Uber 开源的 <a href="http://github.com/uber/nanoscope" target="_blank" rel="external">Nanoscope</a>，直接修改 Android 虚拟机源码，在 ArtMethod 执行入口和执行结束位置新增埋点代码，将所有的信息先写到内存，等到 trace 结束后才统一生成结果文件。需要刷入 ROM。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>汇总一下，如果需要分析 Native 代码的耗时，可以选择 Simpleperf；如果想分析系统调用，可以选择 systrace；如果想分析整个程序执行流程的耗时，可以选择 TraceView 或者插桩版本的 systrace。</p>
<h2 id="三、监控应用卡顿实践"><a href="#三、监控应用卡顿实践" class="headerlink" title="三、监控应用卡顿实践"></a>三、监控应用卡顿实践</h2><h3 id="3-1-监控主线程原理"><a href="#3-1-监控主线程原理" class="headerlink" title="3.1 监控主线程原理"></a>3.1 监控主线程原理</h3><ul>
<li>消息队列</li>
</ul>
<p>依赖主线程 Looper，监控每次 dispatchMessage 的执行耗时。（BlockCanary）</p>
<p>Looper#loop 代码片段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        ...</div><div class="line">        <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></div><div class="line">        Printer logging = me.mLogging;</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</div><div class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</div><div class="line">        &#125;</div><div class="line">        msg.target.dispatchMessage(msg);</div><div class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</div><div class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</div><div class="line">        &#125;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主线程所有执行的任务都在 dispatchMessage 方法中派发执行完成，我们通过 setMessageLogging 的方式给主线程的 Looper 设置一个 Printer ，因为 dispatchMessage 执行前后都会打印对应信息，在执行前利用另外一条线程，通过 Thread#getStackTrace 接口，以轮询的方式获取主线程执行堆栈信息并记录起来，同时统计每次 dispatchMessage 方法执行耗时，当超出阈值时，将该次获取的堆栈进行分析上报，从而来捕捉卡顿信息，否则丢弃此次记录的堆栈信息。</p>
<ul>
<li>Vsync 时间差</li>
</ul>
<p>依赖 Choreographer 模块，监控相邻两次 Vsync 事件通知的时间差。（ArgusAPM、LogMonitor）。</p>
<p>利用系统 Choreographer 模块，向该模块注册一个 FrameCallback 监听对象，同时通过另外一条线程循环记录主线程堆栈信息，并在每次 Vsync 事件 doFrame 通知回来时，循环注册该监听对象，间接统计两次 Vsync 事件的时间间隔，当超出阈值时，取出记录的堆栈进行分析上报。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> Choreographer.FrameCallback() &#123;</div><div class="line">    <span class="meta">@Override</span>    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(frameTimeNanos - mLastFrameNanos &gt; <span class="number">100</span>) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        mLastFrameNanos = frameTimeNanos;</div><div class="line">        Choreographer.getInstance().postFrameCallback(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这两种方案，可以较方便的捕捉到卡顿的堆栈，但其最大的不足在于，无法获取到各个函数的执行耗时，对于稍微复杂一点的堆栈，很难找出可能耗时的函数，也就很难找到卡顿的原因。另外，通过其他线程循环获取主线程的堆栈，如果稍微处理不及时，很容易导致获取的堆栈有所偏移，不够准确，加上没有耗时信息，卡顿也就不好定位。</p>
<p>所以我们希望寻求一种可以在线上准确地捕捉卡顿堆栈，又能计算出各个函数执行耗时的方案。 而要计算函数的执行耗时，最关键的点在于如何对执行过程中的函数进行打点监控。</p>
<h3 id="3-2-插桩"><a href="#3-2-插桩" class="headerlink" title="3.2 插桩"></a>3.2 插桩</h3><ul>
<li><p>应用启动时，默认打开 Trace 功能（Debug.startMethodTracing），应用内所有函数在执行前后将会经过该函数（dalvik 上 dvmMethodTraceAdd 函数 或 art 上 Trace::LogMethodTraceEvent 函数）， 通过hack手段代理该函数，在每个执行方法前后进行打点记录。</p>
</li>
<li><p>修改字节码的方式，在编译期修改所有 class 文件中的函数字节码，对所有函数前后进行打点插桩。</p>
</li>
</ul>
<p>第一种方案，最大的好处是能统计到包括系统函数在内的所有函数出入口，对代码或字节码不用做任何修改，所以对apk包的大小没有影响，但由于方式比较hack，在兼容性和安全性上存在一定的风险。</p>
<p>第二种方案，利用 Java 字节码修改工具（如 BCEL、ASM、Javassis等），在编译期间收集所有生成的 class 文件，扫描文件内的方法指令进行统一的打点插桩，同样也可以高效的记录函数执行过程中的信息，相比第一种方案，除了无法统计系统内执行的函数，其它应用内实现的函数都可以覆盖到。而往往造成卡顿的函数并不是系统内执行的函数，一般都是我们应用开发实现的函数，所以这里无法统计系统内执行的函数对卡顿的定位影响不大。此方案无需 hook 任何函数，所以在兼容性方面会比第一个方案更可靠。</p>
<p>在这考虑上，我们最终选择了修改字节码的方案，来实现 Matrix-TraceCannary 模块，解决其它方案中卡顿堆栈无耗时信息的主要问题，来帮助开发者发现及定位卡顿问题。</p>
<p>参考链接：</p>
<p><a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary" target="_blank" rel="external">Matrix Android TraceCanary</a></p>
<h3 id="3-3-Profilo"><a href="#3-3-Profilo" class="headerlink" title="3.3 Profilo"></a>3.3 Profilo</h3><p>2018 年 3 月，Facebook 开源了一个 <a href="http://github.com/facebookincubator/profilo" target="_blank" rel="external">Profilo</a> 库，它收集了各大方案的优点。</p>
<ul>
<li>集成了 atrace 功能，ftrace（Linux 的ftrace 调试工具，相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里添加了一些性能监控的埋点。Android 在 ftrace 基础上封装了 atrace，并增加了更多特有的探针，例如 Graphics、Activity Manager、Dalvik VM、System Server 等。），Profilo 通过 PLT Hook 拦截了写入操作，选择部分关心事件，例如四大组件生命周期、锁等待时间、类校验、GC 时间等。</li>
<li>快速获取 Java 堆栈，拿到当前执行的 Thread，通过 Thread 对象获取当前线程的 ManagedStack，ManagedStack 是一个单链表，保存了当前的 ShadowFrame 或 QuickFrame 栈指针，它依次遍历 ManagedStack 链表，然后遍历内部的 ShadowFrame 或 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。通过这种方式可以实现一边继续跑步，还可以帮它做检查，而且耗时基本忽略不计。</li>
</ul>
<h3 id="3-4-线程监控"><a href="#3-4-线程监控" class="headerlink" title="3.4 线程监控"></a>3.4 线程监控</h3><p>Java 线程管理是很多应用头疼的事情，应用启动就已经创建了十几上百个线程，而且大部分线程都没有经过线程池管理，都在自由的狂奔着。</p>
<p>另一方面某些线程优先级或者活跃度比较高，占用了过多的 CPU，这会降低主线程 UI 响应能力，需要特别针对这些线程做重点的优化。</p>
<ul>
<li><p>线程数量<br>监控线程数量的多少以及创建线程的方式，可通过 got hook 线程的 nativeCreate() 函数，用于进行线程收敛，也就是减少线程数量。</p>
</li>
<li><p>线程时间</p>
</li>
</ul>
<p>监控线程用户时间 utime、系统时间 stime 和优先级，看哪些线程 utime + stime 比较多，占用了过多的 CPU，有可能有一些线程因为生命周期很短导致很难发现，这里我们需要结合线程创建监控。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>导致卡顿问题很多，比如函数非常耗时、I/O 非常慢、线程间锁竞争或者锁等待等，其实很多时候卡顿问题并不难解决，比较困难的是如何快速发现这些卡顿点，以及更多的辅助信息找到真正的卡顿原因，还原卡顿现场。</p>
<h2 id="四、卡顿优化计划"><a href="#四、卡顿优化计划" class="headerlink" title="四、卡顿优化计划"></a>四、卡顿优化计划</h2><h3 id="4-1-常见卡顿场景"><a href="#4-1-常见卡顿场景" class="headerlink" title="4.1 常见卡顿场景"></a>4.1 常见卡顿场景</h3><ul>
<li>布局嵌套层次太深，可以使用 merge、viewStub、include 来优化</li>
<li>onDraw() 里面循环创建了大量临时变量，频繁触发 GC</li>
<li>主线程等待优先级子线程问题（锁同步问题）</li>
<li>主线程执行耗时操作，阻塞主线程执行（同步读写文件，DB 操作）</li>
</ul>
<h3 id="4-2-卡顿排查思路"><a href="#4-2-卡顿排查思路" class="headerlink" title="4.2 卡顿排查思路"></a>4.2 卡顿排查思路</h3><ul>
<li>显示页面实时 FPS 帧率，帮助查看流畅度（UI 优化，参见上述方法）</li>
<li>慢函数堆栈显示，当发生卡顿时，可以显示具体哪个函数哪行代码造成的卡顿</li>
<li>线程监控，监控全局线程创建</li>
</ul>
<h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><ul>
<li><a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="external">Android 开发高手课-卡顿优化</a></li>
<li><a href="https://time.geekbang.org/column/article/80921" target="_blank" rel="external">Android 开发高手课-渲染优化</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI2OTQxMTM4OQ==&amp;mid=2247490024&amp;idx=2&amp;sn=3b8a42d0e9aae286984c03a5ac0b3389&amp;chksm=eae1ecbadd9665ace47c2ce20487852a38dfe3735a0ee74d38096af7f7d38c862373a83e90a9" target="_blank" rel="external">不敢相信？System.currentTimeMillis() 居然存在性能问题</a></li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 Gradle（一）：Gradle 详解</title>
    <url>/2020/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Gradle%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AGradle-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><h2 id="1-1-什么是构建？"><a href="#1-1-什么是构建？" class="headerlink" title="1.1 什么是构建？"></a>1.1 什么是构建？</h2><p>构建，叫 build 也好，叫 make 也行，根绝外部输入的信息然后干一堆事情，最后得到几个产出物（Artifact）。</p>
<p>Gradle 是当前非常「劲爆」的构建工具，介绍 Gradle 之前，先说说一些之前使用过的构建工具们。在 Gradle 爆红之前，常用的构建工具是 Ant，然后进化到 Maven。Ant 和 Maven 这两个工具在出来时也算方便，但是二者都有些缺点。比如，编译规则是用 XML 来编写的，XML 虽然通俗易懂，但是很难在其中描述 if/else 这样有不同条件的任务。</p>
<h2 id="1-2-构建历程"><a href="#1-2-构建历程" class="headerlink" title="1.2 构建历程"></a>1.2 构建历程</h2><ul>
<li>Ant </li>
</ul>
<p><img desc="gradle_ant_eclipse" src="http://wanghaoxun.com/img/gradle_ant_eclipse.jpg" width="60%"></p>
<ul>
<li>Maven</li>
</ul>
<p><img desc="gradle_maven_retrofit" src="http://wanghaoxun.com/img/gradle_maven_retrofit.jpg" width="60%"></p>
<p>你会发现 Ant 和 Maven 配置复杂，依赖混乱，几十人的团队协作开发编辑不敢想象，甚至都怀疑这玩意是给人用的？（黑人脸，what？？？）</p>
<p><img src="http://wanghaoxun.com/img/black_face.jpeg" alt="Nick Young"></p>
<p><strong>怎么办？怎么办？自然是编程来解决。。。</strong></p>
<ul>
<li>Gradle </li>
</ul>
<p><img desc="gradle_xrk_crm" src="http://wanghaoxun.com/img/gradle_xrk_crm.jpg" width="60%"></p>
<p>Gradle 作为一种很方便的构建工具，可以轻松解决多版本配置、构建依赖等问题，最主要它支持用 Grooovy、Java、Kotlin 来编写，可以书写自己的变量、函数。在使用 Gradle 之前，我们可能还有几个小要求：</p>
<ol>
<li>这种编程不要搞得太复杂，几行代码就轻松把要做的事情描述出来就最好不过了。所以 Gradle 选择了 Groovy，Groovy 基于 Java 并拓展了 Java，Groovy 说白了就是把写 Java 程序变得像写脚本一样简单。写完就可以执行，Groovy 内部会将其编译成 Java class 然后启动虚拟机来执行。</li>
<li>除了可以用灵活的语言来写构建规则外，Gradle 另外一个特点就是它是一种 DSL，即 Domain Specific Language，领域相关语言。什么是 DSL？说白了它是某个行业中的行话。类似徐克导演的《智取威虎山》中就很有典型的 DSL 使用描述，例如：</li>
</ol>
<blockquote>
<p>土匪：天王盖地虎！（你好大的胆！敢来气你的祖宗？）<br>杨子荣：宝塔镇河妖！（要是那样，叫我从山上摔死，掉河里淹死。）<br>土匪：野鸡闷头钻，哪能上天王山！（你不是正牌的。）<br>杨子荣：地上有的是米，喂呀，有根底！（老子是正牌的，老牌的。）</p>
</blockquote>
<p>Gradle 中也有类似的行话，比如 sourceSet 代表源文件的集合等… 太多了，记不住？没关系，后面我们会通过手册来慢慢了解一些常用的。</p>
<p><strong>一句行话可以包含很多意思，在这个行当里的人一听就懂，不用解释。另外，基于外行，我们甚至可以建立一个模板，使用者只要往这个模板里填必须的内容，Gradle 就可以非常漂亮的完成工作，得到我们想要的东西。</strong></p>
<h2 id="1-3-Gradle-小总结"><a href="#1-3-Gradle-小总结" class="headerlink" title="1.3 Gradle 小总结"></a>1.3 Gradle 小总结</h2><p>至此，大家应该明白要真正学会 Gradle 怕是离不开下面两个基础知识：</p>
<ol>
<li>Groovy，基于 Java，了解 Groovy 语言是掌握 Gradle 的基础</li>
<li>Gradle 作为一个工具，它的行话和它的「为人处事」的原则</li>
</ol>
<h1 id="二、Groovy-介绍"><a href="#二、Groovy-介绍" class="headerlink" title="二、Groovy 介绍"></a>二、Groovy 介绍</h1><p>Groovy 是一种动态语言，它和 Java 一样，也运行在 Java 虚拟机中。恩？？对，你没听错，你可以认为 Groovy 拓展了 Java 语言，比如，Groovy 对自己的定义就是：Groovy 是在 Java 平台上，具有像 Python，Ruby 和 Smalltalk 语言特性的灵活动态语言，Groovy 保证了这些特性像 Java 语法一样被 Java 开发者使用。</p>
<p>除了语言和 Java 相通外，Groovy 有时候又像一种脚本语言，当你执行 Groovy 脚本时，Groovy 会先将其编译成 Java 类字节码，然后通过 JVM 来执行这个 Java 类，图示展示了 Java、Groovy和 JVM 之间的关系。</p>
<p><img src="http://wanghaoxun.com/img/Groovy关系图.png" alt="Groovy 和 Java 关系图"></p>
<p><strong>实际上，在 Groovy Code 在真正执行的时候已经变成了 Java 字节码，所以 JVM 根本不知道自己运行的是 Groovy 代码。</strong></p>
<p>下面将集中讲解 Groovy 和 Gradle 打交道时一些常用的知识点。</p>
<h2 id="2-1-Groovy-开发环境"><a href="#2-1-Groovy-开发环境" class="headerlink" title="2.1 Groovy 开发环境"></a>2.1 Groovy 开发环境</h2><p>根据 <a href="http://www.groovy-lang.org/download.html#gvm" target="_blank" rel="external">Groovy 官网</a> 介绍部署 Groovy 开发环境。</p>
<p>macOS 安装</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><div class="line">brew install groovy</div></pre></td></tr></table></figure>
<p>Groovy 也有一套 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">GDK</a></p>
<p><img desc="Groovy-GDK" src="http://wanghaoxun.com/img/Groovy-GDK.jpg" width="60%"></p>
<p><a href="https://github.com/gradle/gradle" target="_blank" rel="external">Gradle 源代码地址</a></p>
<h2 id="2-2-一些前提知识"><a href="#2-2-一些前提知识" class="headerlink" title="2.2 一些前提知识"></a>2.2 一些前提知识</h2><ul>
<li>Groovy 注释标记和 Java 一样，支持 // 或者 /**/</li>
<li>Groovy 语句可以不用分号结尾</li>
<li>Groovy 中支持动态类型，即定义变量的时候可以不指定其类型。Groovy 中，变量定义可以使用关键字 def。注意，虽然 def 不是必须的，但是为了代码清晰，建议还是使用 def 关键字</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">def</span> variable1 = <span class="number">1</span>   <span class="comment">// 可以不使用分号结尾 </span></div><div class="line"><span class="keyword">def</span> varable2 = <span class="string">"I am a person"</span></div><div class="line"><span class="keyword">def</span> <span class="keyword">int</span> x = <span class="number">1</span>   <span class="comment">// 变量定义时，也可以直接指定类型</span></div></pre></td></tr></table></figure>
<ul>
<li>函数定义时，参数的类型也可以不指定</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">String testFunction(arg1,arg2)&#123;<span class="comment">// 无需指定参数类型 </span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>除了变量定义可以不指定类型外，Groovy 中函数的返回值也可以是无类型的</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 无类型的函数定义，必须使用 def 关键字</span></div><div class="line"></div><div class="line"><span class="keyword">def</span> nonReturnTypeFunc()&#123;</div><div class="line">    last_line   <span class="comment">// 最后一行代码的执行结果就是本函数的返回值 </span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// 如果指定了函数返回类型，则可不必加 def 关键字来定义函数 </span></div><div class="line">String getString()&#123;</div><div class="line">   <span class="keyword">return</span> <span class="string">"I am a string"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回 Object 类型来处理的。毕竟，Groovy 是基于 Java 的，而且最终会转成 Java Code 运行在 JVM 上</p>
<ul>
<li>函数返回值：Groovy 的函数里，可以不使用 return xxx 来设置 xxx 为函数返回值。如果不使用 return 语句的话，则函数里最后一句代码的执行结果被设置成返回值。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 下面这个函数的返回值是字符串"getSomething return value"</span></div><div class="line"><span class="keyword">def</span> getSomething() &#123;</div><div class="line"> </div><div class="line">    <span class="string">"getSomething return value"</span> <span class="comment">// 如果这是最后一行代码，则返回类型为 String</span></div><div class="line"> </div><div class="line">    <span class="number">1000</span> <span class="comment">// 如果这是最后一行代码，则返回类型为 Integer</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型，否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。</p>
<ul>
<li>Groovy 对字符串支持相当强大，充分吸收了一些脚本语言的优点：</li>
</ul>
<ol>
<li>单引号’’中的内容严格对应 Java 中的 String，不对 $ 符号进行转义</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">def</span> singleQuote=<span class="string">'I am $ dolloar'</span>  <span class="comment">// 输出就是 I am $ dolloar</span></div></pre></td></tr></table></figure>
<ol>
<li>双引号””的内容则和脚本语言的处理有点像，如果字符中有 $ 号的话，则它会$ 表达式先求值</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">def</span> doubleQuoteWithoutDollar = <span class="string">"I am one dollar"</span> <span class="comment">// 输出 I am one dollar</span></div><div class="line"><span class="keyword">def</span> x = <span class="number">1</span></div><div class="line"><span class="keyword">def</span> doubleQuoteWithDollar = <span class="string">"I am $x dolloar"</span> <span class="comment">// 输出 I am 1 dolloar</span></div></pre></td></tr></table></figure>
<ol>
<li>三个引号’’’xxx’’’中的字符串支持随意换行 比如</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">def</span> multieLines = <span class="string">''' begin</span></div><div class="line">  line  1 </div><div class="line">  line  2</div><div class="line">  end '''</div></pre></td></tr></table></figure>
<ul>
<li>最后，除了每行代码不用加分号外，Groovy 中函数调用的时候还可以不加括号。</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">println(<span class="string">"test"</span>) ---&gt; println <span class="string">"test"</span></div></pre></td></tr></table></figure>
<p><strong>注意，虽然写代码的时候，对于函数调用可以不带括号，但是 Groovy 经常把属性和函数调用混淆。比如</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">def</span> getSomething()&#123;</div><div class="line">   <span class="string">"hello"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>getSomething()   // 如果不加括号的话，Groovy 会误认为 getSomething 是一个变量。</p>
<p>所以，调用函数要不要带括号，我个人意见是如果这个函数是 Groovy API 或者 Gradle API 中比较常用的，比如 println，就可以不带括号。否则还是带括号。Groovy 自己也没有太好的办法解决这个问题，只能兵来将挡水来土掩了。</p>
<h2 id="2-3-Groovy-中的数据类型"><a href="#2-3-Groovy-中的数据类型" class="headerlink" title="2.3 Groovy 中的数据类型"></a>2.3 Groovy 中的数据类型</h2><p>Groovy 中的数据类型我们就介绍三种和 Java 不太一样的：</p>
<ul>
<li>一个是 Java 中的基本数据类型</li>
<li>另外一个是 Groovy 中的容器类</li>
<li>最后一个非常重要的是闭包</li>
</ul>
<h3 id="2-3-1-基本数据类型"><a href="#2-3-1-基本数据类型" class="headerlink" title="2.3.1 基本数据类型"></a>2.3.1 基本数据类型</h3><p>作为动态语言，Groovy 世界中的所有事物都是对象。所以，int，boolean 这些 Java 中的基本数据类型，在 Groovy 代码中其实对应的是它们的包装数据类型。比如 int 对应为 Integer，boolean 对应为 Boolean。比如下图中的代码执行结果：</p>
<p><img desc="基本数据类型" src="http://wanghaoxun.com/img/groovy-basic-data-type.jpg" width="60%"></p>
<h3 id="2-3-2-容器类"><a href="#2-3-2-容器类" class="headerlink" title="2.3.2 容器类"></a>2.3.2 容器类</h3><p>Groovy 中的容器类很简单，就三种：</p>
<ul>
<li>List：链表，其底层对应 Java 中的 List 接口，一般用 ArrayList 作为真正的实现类</li>
<li>Map：键 - 值表，其底层对应 Java 中的 LinkedHashMap</li>
<li>Range：范围，它其实是 List 的一种拓展</li>
</ul>
<p>了解容器简单例子：</p>
<ol>
<li>List 类</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">变量定义：List 变量由 [] 定义，比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aList = [<span class="number">5</span>,<span class="string">'string'</span>,<span class="literal">true</span>] <span class="comment">//List 由 [] 定义，其元素可以是任何对象 </span></div><div class="line"></div><div class="line">变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List 会自动 </div><div class="line">往该索引添加元素 </div><div class="line"></div><div class="line"><span class="keyword">assert</span> aList[<span class="number">1</span>] == <span class="string">'string'</span></div><div class="line"><span class="keyword">assert</span> aList[<span class="number">5</span>] == <span class="literal">null</span> <span class="comment">// 第 6 个元素为空 </span></div><div class="line">aList[<span class="number">100</span>] = <span class="number">100</span>  <span class="comment">// 设置第 101 个元素的值为 100</span></div><div class="line"><span class="keyword">assert</span> aList[<span class="number">100</span>] == <span class="number">100</span></div><div class="line"></div><div class="line">那么，aList 到现在为止有多少个元素呢？</div><div class="line"></div><div class="line">println aList.size  ===&gt; 结果是 <span class="number">101</span></div></pre></td></tr></table></figure>
<ol>
<li>Map 类</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">容器变量定义 </div><div class="line"></div><div class="line">变量定义：Map 变量由 [:] 定义，比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aMap = [<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="literal">true</span>] </div><div class="line"></div><div class="line">Map 由 [:] 定义，注意其中的冒号。冒号左边是 key，右边是 Value。key 必须是字符串，value 可以是任何对象。另外，key 可以用<span class="string">''</span>或<span class="string">""</span>包起来，也可以不用引号包起来。比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aNewMap = [<span class="string">key1:</span><span class="string">"value"</span>,<span class="string">key2:</span><span class="literal">true</span>] <span class="comment">// 其中的 key1 和 key2 默认被 </span></div><div class="line">处理成字符串<span class="string">"key1"</span>和<span class="string">"key2"</span></div><div class="line"></div><div class="line">不过 Key 要是不使用引号包起来的话，也会带来一定混淆，比如 </div><div class="line"></div><div class="line"><span class="keyword">def</span> key1 = <span class="string">"wowo"</span></div><div class="line"><span class="keyword">def</span> aConfusedMap = [<span class="string">key1:</span><span class="string">"who am i?"</span>]</div><div class="line"></div><div class="line">aConfuseMap 中的 key1 到底是<span class="string">"key1"</span>还是变量 key1 的值“wowo”？显然，答案是字符串<span class="string">"key1"</span>。如果要是<span class="string">"wowo"</span>的话，则 aConfusedMap 的定义必须设置成：</div><div class="line"></div><div class="line"><span class="keyword">def</span> aConfusedMap = [(key1):<span class="string">"who am i?"</span>]</div><div class="line"></div><div class="line">Map 中元素的存取更加方便，它支持多种方法：</div><div class="line"></div><div class="line">println aMap.keyName    &lt;== 这种表达方法好像 key 就是 aMap 的一个成员变量一样 </div><div class="line">println aMap[<span class="string">'keyName'</span>] &lt;== 这种表达方法更传统一点 </div><div class="line">aMap.anotherkey = <span class="string">"i am map"</span>  &lt;== 为 map 添加新元素</div></pre></td></tr></table></figure>
<ol>
<li>Range 类</li>
</ol>
<p>Range 是 Groovy 对 List 的一种扩展，变量定义和大体的使用方法如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line"><span class="keyword">def</span> aRange = <span class="number">1.</span><span class="number">.5</span>  &lt;==Range 类型的变量 由 begin 值 + 两个点 +end 值表示 </div><div class="line">                      左边这个 aRange 包含 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> 这 <span class="number">5</span> 个值 </div><div class="line"></div><div class="line">如果不想包含最后一个元素，则 </div><div class="line"></div><div class="line"><span class="keyword">def</span> aRangeWithoutEnd = <span class="number">1.</span>.&lt;<span class="number">5</span>  &lt;== 包含 <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> 这 <span class="number">4</span> 个元素 </div><div class="line">println aRange.from</div><div class="line">println aRange.to</div></pre></td></tr></table></figure>
<h3 id="2-3-3-Groovy-API-的一些秘笈"><a href="#2-3-3-Groovy-API-的一些秘笈" class="headerlink" title="2.3.3 Groovy API 的一些秘笈"></a>2.3.3 Groovy API 的一些秘笈</h3><p>了解 Groovy 的语法，是离不开 SDK 的，Groovy 是动态语言，所以要使用它的 SDK 也需要掌握一些小诀窍。</p>
<p>Groovy 的 API 文档地址：<a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></p>
<p>以上面介绍的 Range 为例，我们该如何查阅 SDK 更好的使用它呢？</p>
<ul>
<li>先找到 Range 类，它位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">groovy.lang</a> 包中：</li>
</ul>
<p>有了 API 文档，你可以使用里面的函数了，不过，细心地你可以发现我们刚才代码中用到的 Range.from/to 属性值，在 Range API 文档中并没有这两个成员变量。</p>
<p><img desc="gradle-groovy-sdk-range" src="http://wanghaoxun.com/img/gradle-groovy-sdk-range.jpg" width="60%"></p>
<p>文档中没有说明 Range 有 from 和 to 这两个属性，但是却有 getFrom 和 getTo 两个函数，What？？？原来：</p>
<p>根据 Groovy 的原则，如果一个类中有名为 xxyyzz 这样的属性（其实就是成员变量），Groovy 会自动为它添加 getXX 和 setXX 两个函数，用于获取和设置 xxyyzz 属性值。</p>
<p><strong>注意：get 和 set 后第一个字母是大写的！</strong></p>
<p>所以，当你看到 Range 中有 getFrom 和 getTo 这两个函数时候，就得知道潜规则下，Range 有 from 和 to 这两个属性。当然，由于它们不可以被外界设置，所以没有公开 setFrom 和 setTo 函数。</p>
<h2 id="2-4-闭包"><a href="#2-4-闭包" class="headerlink" title="2.4 闭包"></a>2.4 闭包</h2><h3 id="2-4-1-闭包的样子"><a href="#2-4-1-闭包的样子" class="headerlink" title="2.4.1 闭包的样子"></a>2.4.1 闭包的样子</h3><p>闭包，英文叫 Closure，是 Groovy 中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！</p>
<p><strong>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def aClosure = &#123;// 闭包是一段代码，所以需要用花括号括起来..  </div><div class="line">    Stringparam1, int param2 -&gt;  // 这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </div><div class="line">    println &quot;this is code&quot; // 这是代码，最后一句是返回值，  </div><div class="line">   // 也可以使用 return，和 Groovy 中普通函数一样  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简而言之，Closure 的定义格式是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def xxx = &#123;paramters -&gt; code&#125;  // 或者  </div><div class="line">def xxx = &#123;无参数，纯 code&#125;  这种 case 不需要 -&gt; 符号</div></pre></td></tr></table></figure>
<p>补充一点，有没有想到我分享 Java8 时提到的 Lambda 表达式呢？哈哈。。。</p>
<p><strong>从 C/C++ 语言的角度看，闭包和函数指针很像</strong>。闭包定义好，要调用它的方法就是：</p>
<p>闭包对象.call(参数)  或者更像函数指针调用的方法：</p>
<p>闭包对象 (参数)</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">aClosure.call(&quot;this is string&quot;,100)  或者  </div><div class="line">aClosure(&quot;this is string&quot;, 100)</div></pre></td></tr></table></figure>
<p>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫 it，和 this 的作用类似。it 代表闭包的参数。</p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def greeting = &#123; &quot;Hello, $it!&quot; &#125;</div><div class="line">assert greeting(&apos;Nelson&apos;) == &apos;Hello, Nelson!&apos;</div></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def greeting = &#123; it -&gt; &quot;Hello, $it!&quot; &#125;</div><div class="line">assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;</div></pre></td></tr></table></figure>
<h3 id="2-4-2-Closure-使用中的注意点"><a href="#2-4-2-Closure-使用中的注意点" class="headerlink" title="2.4.2 Closure 使用中的注意点"></a>2.4.2 Closure 使用中的注意点</h3><ol>
<li>省略圆括号</li>
</ol>
<p>闭包在 Groovy 中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</div></pre></td></tr></table></figure>
<p>上面这个函数表示针对 List 的每一个元素都会调用 closure 做一些处理。这里的 closure，就有点回调函数的感觉。但是，在使用这个 each 函数的时候，我们传递一个怎样的 Closure 进去呢？比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def iamList = [1,2,3,4,5]  // 定义一个 List</div><div class="line">iamList.each &#123;  // 调用它的 each，这段代码的格式看不懂了吧？each 是个函数，圆括号去哪了？</div><div class="line">      println it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码，有 2个知识点：</p>
<ul>
<li><strong>each 函数调用的圆括号不见了！</strong>原来，Groovy 中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def  testClosure(int a1,String b1, Closure closure) &#123;</div><div class="line">      //do something</div><div class="line">      closure() // 调用闭包 </div><div class="line">&#125;</div><div class="line">那么调用的时候，就可以免括号！</div><div class="line">testClosure (4, &quot;test&quot;, &#123;</div><div class="line">   println &quot;i am in closure&quot;</div><div class="line">&#125; )  // 外层的括号可以不写..</div><div class="line">// 简写</div><div class="line">testClosure 4,&quot;test&quot;,&#123;println &quot;i am in closure&quot;&#125;</div></pre></td></tr></table></figure>
<p>注意，这个特点非常重要，因为以后在 Gradle 中经常出现如下这样的代码：</p>
<p><img desc="Gradle 简单闭包示例" src="http://wanghaoxun.com/img/gradle-groovy-closure-hello.png"></p>
<p>经常碰见图示这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我疑惑，以 doLast 为例，完整的代码应该按下面这种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">doLast(&#123;</div><div class="line">   println &apos;Hello world!&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>有了圆括号，你会知道 doLast 只是把一个 Closure 对象传了进去。很明显，它不代表这段脚本解析到 doLast 的时候就会调用 println ‘Hello world!’ 。</p>
<p>但是把圆括号去掉后，就感觉好像 println ‘Hello world!’ 立即就会被调用一样！</p>
<ol>
<li>如何确定 Closure 的参数</li>
</ol>
<p>另外一个比较让人头疼的地方是，closure 的参数该怎么搞？还是刚才的 each 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def iamList = [1,2,3,4,5]  // 定义一个 List 变量 </div><div class="line">iamList.each&#123;  // 调用它的 each 函数，只要传入一个 Closure 就可以了。</div><div class="line">  println it</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><strong>对于 each 所需要的 Closure，它的参数是什么？有多少个参数？返回值是什么？</strong></li>
</ul>
<p>Closure 虽然方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，该如何知道调用者传递什么参数给 Closure 呢？</p>
<p>此问题如何破解？只能通过查询 <a href="http://docs.groovy-lang.org/latest/html/gapi/index.html?org/codehaus/groovy/runtime/DefaultGroovyMethods.html" target="_blank" rel="external">API</a>  文档才能了解上下文语义。如下图：</p>
<p>从整体上知道 groovy SDK 对 JDK 做了扩展，这些都是 GDK 提供的新类，这些方法并没有加到 JDK 中对应的类中，那是如何直接调用它扩展的那些方法呢？例如，Class DefaultGroovyMethods 类中为我们任意对象都提供了一个 each 方法。</p>
<p><img desc="each 方法" src="http://wanghaoxun.com/img/groovy-defaultmethods-each.jpg" width="60%"></p>
<p><img desc="findAll 方法" src="http://wanghaoxun.com/img/groovy-defaultmethods-findall.jpg" width="60%"></p>
<ul>
<li>each 函数说明中，将给指定的 closure 传递 Set 中的每一个 item。所以，closure 的参数只有一个。</li>
<li>findAll 中，绝对抓瞎了。一个是没说明往 Closure 里传什么。另外没说明 Closure 的返回值是什么…..</li>
</ul>
<p><strong>对 Map 的 findAll 而言，Closure 可以有两个参数。findAll 会将 Key 和 Value 分别传进去。并且，Closure 返回 true，表示该元素是自己想要的。返回 false 表示该元素不是自己要找的。</strong> 示意代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def aMap = [k1:&apos;value1&apos;,k2:true]</div><div class="line">def results = aMap.findAll &#123;</div><div class="line">    key, value -&gt; </div><div class="line">    println &quot;key=$key, value=$value&quot;</div><div class="line">    if(key == &apos;k1&apos;) </div><div class="line">        return true</div><div class="line">    return false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>Closure 的使用有点坑，很大程度上依赖你对 API 的熟悉程度，so，最初阶段，SDK 查询是少不了的！</p>
</blockquote>
<h2 id="2-5-脚本类、文件-I-O-和-XML-操作"><a href="#2-5-脚本类、文件-I-O-和-XML-操作" class="headerlink" title="2.5 脚本类、文件 I/O 和 XML 操作"></a>2.5 脚本类、文件 I/O 和 XML 操作</h2><p>最后，来看一下 Groovy 中比较高级的用法。</p>
<h3 id="2-5-1-脚本类"><a href="#2-5-1-脚本类" class="headerlink" title="2.5.1 脚本类"></a>2.5.1 脚本类</h3><ol>
<li>脚本中 import 其他类</li>
</ol>
<p>Groovy 中可以像 Java 那样写 package，然后写类。比如在文件夹 com/nelson/groovy/chap2 目录中放一个文件，叫 Article.groovy，如代码所示（演示-chap2 代码）：</p>
<p>创建了 Article.groovy 文件，ArticleTest.groovy 再 import 了 Article 类，然后创建了 Article 类型的对象，接着调用它的 print 函数。</p>
<p>在 groovy 中，系统自带会加载当前目录 / 子目录下的 xxx.groovy 文件。所以，当执行 groovy ArticleTest.groovy 的时候，ArticleTest.groovy import 的 Article 类能被自动搜索并加载到。</p>
<ol>
<li>脚本到底是什么</li>
</ol>
<p>Java 中，我们最熟悉的是类。但是我们在 Java 的一个源码文件中，不能不写 class（interface 或者其他….），而 Groovy 可以像写脚本一样，把要做的事情都写在 xxx.groovy 中，而且可以通过 groovy xxx.groovy 直接执行这个脚本。这到底是怎么搞的？</p>
<p>既然是基于 Java 的，Groovy 会先把 xxx.groovy 中的内容转换成一个 Java 类。比如：chap2/Inner.groovy 文件</p>
<p><strong>执行 groovyc -d classes Inner.groovy</strong>，groovyc 是 groovy 的编译命令， -d classes 用于将编译得到的 class 文件拷贝到 classes 文件夹下，Inner.groovy 脚本转换得到的 java class，可以用 jd-gui 反编译它的代码，也可以用 IEA 直接查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import groovy.lang.Binding;</div><div class="line">import groovy.lang.Script;</div><div class="line">import org.codehaus.groovy.runtime.InvokerHelper;</div><div class="line">import org.codehaus.groovy.runtime.callsite.CallSite;</div><div class="line"></div><div class="line">public class Inner extends Script &#123;</div><div class="line">    public Inner() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Inner(Binding context) &#123;</div><div class="line">        CallSite[] var2 = $getCallSiteArray();</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String... args) &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        var1[0].call(InvokerHelper.class, Inner.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object run() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        return var1[1].callCurrent(this, &quot;Hello Groovy!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Inner.groovy 被转换成了一个 Script 类，它从 script 派生。</li>
<li>每一个脚本都会生成一个 static main 函数。这样，当我们 groovy Inner.groovy 的时候，其实就是用 java 去执行这个 main 函数</li>
<li>脚本中的所有代码都会放到 run 函数中。比如，println ‘Hello Groovy’，这句代码实际上是包含在 run 函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在 Inner 类中</li>
</ul>
<ol>
<li>脚本中的变量和作用域</li>
</ol>
<p>上面说了脚本的代码其实都会被放到 run 函数中去执行，那么在 Groovy 的脚本中，很重要的一点就是脚本中定义的变量和它的作用域。举例：</p>
<p>Field.groovy 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 2.5.1 脚本中的变量和作用域</div><div class="line"> */</div><div class="line">def x = 1</div><div class="line"></div><div class="line">def printx() &#123;</div><div class="line">    println x</div><div class="line">&#125;</div><div class="line"></div><div class="line">printx()</div></pre></td></tr></table></figure>
<p><strong>运行脚本会报错，groovy.lang.MissingPropertyException: No such property: x for class: Field</strong></p>
<p>反编译后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Field extends Script &#123;</div><div class="line">    public Field() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Field(Binding context) &#123;</div><div class="line">        CallSite[] var2 = $getCallSiteArray();</div><div class="line">        super(context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String... args) &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        var1[0].call(InvokerHelper.class, Field.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object run() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        Object x = 1;</div><div class="line">        return x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object printx() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        return var1[1].callCurrent(this, var1[2].callGroovyObjectGetProperty(this));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>printx 被定义成 Field 类的成员函数</li>
<li>def x = 1，这句话是在 run 中创建的。所以，x = 1 从代码上看好像是在整个脚本中定义的，但实际上 printx 访问不了它。printx 是 test 成员函数，除非 x 也被定义成 test 的成员函数，否则 printx 不能访问它。</li>
</ul>
<p>那么，如何使得 printx 能访问 x 呢？很简单，定义的时候不要加类型和 def。演示 chap2/Field2.groovy 源文件和反编译文件</p>
<p>x 也没有被定义成 Field2 的成员函数，而是在 run 的执行过程中，将 x 作为一个属性添加到 Field2 <strong>实例对象</strong>中了。然后在 printx 中，先获取这个属性。</p>
<p><strong>注意，Groovy 文档说 x = 1 这种定义将使得 x 变成 Filed2 的成员变量，但从反编译情况来看，这是不对的。。。</strong></p>
<p>虽然 printx 可以访问 x 变量了，但是假如有其他脚本却无法访问 x 变量。因为它不是 Field2 的成员变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Field3 extends Script &#123;</div><div class="line">    Object x;</div><div class="line"></div><div class="line">    public Field3() &#123;</div><div class="line">       ...</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String... args) &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        var1[0].call(InvokerHelper.class, Field3.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object run() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        Object var10000 = null;</div><div class="line">        return !__$stMC &amp;&amp; !BytecodeInterface8.disabledStandardMetaClass() ? this.printx() : var1[1].callCurrent(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Object printx() &#123;</div><div class="line">        CallSite[] var1 = $getCallSiteArray();</div><div class="line">        return var1[2].callCurrent(this, this.x);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到 Field3.groovy 中的 x 已经变成了 Field3 类的成员属性了。如此，我们可以在 script 中定义那些需要输出给外部脚本或类使用的变量了！</p>
<blockquote>
<p>这里演示 Field2.groovy，Field3.groovy，InvokeField.groovy 文件来说明成员属性！</p>
</blockquote>
<h3 id="2-5-2-文件-I-O"><a href="#2-5-2-文件-I-O" class="headerlink" title="2.5.2 文件 I/O"></a>2.5.2 文件 I/O</h3><p>本节介绍 Groovy 的文件 I/O 操作。虽然比 Java 看起来简单，但要理解起来其实比较难。尤其是当你要自己查 SDK 并编写代码的时候。</p>
<p>整体说来，Groovy 的 I/O 操作是在原有 Java I/O 操作上进行了更为简单方便的封装，并且使用 Closure 来简化代码编写。主要封装了如下一些类：</p>
<ul>
<li>java.io.File class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></li>
<li>java.io.InputStream class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></li>
<li>java.io.OutputStream class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></li>
<li>java.io.Reader class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a></li>
<li>java.io.Writer class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a></li>
<li>java.nio.file.Path class: <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a></li>
</ul>
<ol>
<li>读文件</li>
</ol>
<p>Groovy 中，文件读操作简单到令人发指：</p>
<p>def targetFile = new File(文件名)  &lt;==File 对象还是要创建的</p>
<p>看看 Groovy 定义的 API：</p>
<ul>
<li>读该文件中的每一行：eachLine 的唯一参数是一个 Closure。Closure 的参数是文件每一行的内容</li>
</ul>
<p>内部实现肯定是 Groovy 打开这个文件，然后读取文件的一行，然后调用 Closure…</p>
<p>演示 File.groovy 文件</p>
<ul>
<li>直接得到文件内容</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">targetFile.getBytes() // 文件内容一次性读出，返回类型为 byte[]</div></pre></td></tr></table></figure>
<p>注意前面提到的 getter 和 setter 函数，这里可以直接使用 targetFile.bytes //…</p>
<ul>
<li>使用 InputStream </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def ism = targetFile.newInputStream()</div><div class="line"></div><div class="line">ism.close()</div></pre></td></tr></table></figure>
<ul>
<li>使用闭包操作 inputStream，以后会在 Gradle 里经常看到这种写法。。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">targetFile.withInputStream &#123; ism -&gt;</div><div class="line">    // 操作 ism，不用 close，groovy 会自动替你 close</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>确实简单到发指，一开始也死活不理解 withInputStream 是个啥意思。所以，请再看的各位老铁牢记 Groovy I/O 操作相关类的 SDK 地址~</p>
<ol>
<li>写文件</li>
</ol>
<p>和读文件差不多，不再啰嗦，这里举个例子，告诉你如何 copy 文件，演示 Copy.groovy 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def srcFile = new File(&apos;src/com/nelson/groovy/chap2/source.txt&apos;)</div><div class="line">def targetFile = new File(&apos;src/com/nelson/groovy/chap2/dest.txt&apos;)</div><div class="line">targetFile.withOutputStream &#123; os -&gt;</div><div class="line">    srcFile.withInputStream &#123; ins -&gt;</div><div class="line">        // 利用 OutputStream 的 &lt;&lt; 操作符重载，完成从 Inputstream 到 OutputStream 的输出</div><div class="line">        os &lt;&lt; ins</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于 OutputStream 的 &lt;&lt; 操作符重载，查看 SDK 文档之后才知道：</p>
<p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></p>
<p>再一次向极致简单致敬。以后，怕是 SDK 离不开手了，各位。。。</p>
<h3 id="2-5-3-XML-操作"><a href="#2-5-3-XML-操作" class="headerlink" title="2.5.3 XML 操作"></a>2.5.3 XML 操作</h3><p>除了 I/O 异常简单之外，Groovy 中的 XML 操作也极致得很。Groovy 中，XML 的解析提供了和 XPath 类似的方法，名为 GPath。这是一个类，提供相应 API。关于 XPath，请看 <a href="https://en.wikipedia.org/wiki/XPath" target="_blank" rel="external">WIKI</a>。</p>
<p>演示 Xml.groovy 文件</p>
<p>详细操作就不在这展开了，用到了各位在查 SDK 完成吧~</p>
<h3 id="2-6-更多"><a href="#2-6-更多" class="headerlink" title="2.6 更多"></a>2.6 更多</h3><p>作为一门语言，Groovy 是复杂的，是需要深入学习和钻研的。一本厚书都无法描述 Groovy 的方方面面。</p>
<p>从使用的角度看，尤其是又限定在 Gradle 这个领域内，能用到的 Groovy 中一些简单的知识。</p>
<h1 id="三、Gradle-介绍"><a href="#三、Gradle-介绍" class="headerlink" title="三、Gradle 介绍"></a>三、Gradle 介绍</h1><p><img src="http://wanghaoxun.com/img/gradlephant@2x.png" align="right" width="280"></p>
<p>现在正式进入 Gradle。Gradle 是一个工具，同时它也是一个编程框架。前面也提到过，使用这个工具可以完成 app 的编译打包等工作。当然你也可以用它干其他的事情。</p>
<p>Gradle 是什么？学习它到什么地步就可以了？</p>
<p>看待问题的时候，所站的角度非常重要！</p>
<p>-&gt; 当你把 Gradle 当工具看的时候，我们只想着如何用好它。会写、写好配置脚本就 OK<br>-&gt; 当你把它当做编程框架看的时候，你可能需要学习很多更深入的内容。</p>
<p>今天我们把它当工具看，明天因为需求发生变化，我们可能又得把它当编程框架看。</p>
<h2 id="3-1-Gradle-开发环境部署"><a href="#3-1-Gradle-开发环境部署" class="headerlink" title="3.1 Gradle 开发环境部署"></a>3.1 Gradle 开发环境部署</h2><p>Gradle 官网：<a href="http://gradle.org/，最新" target="_blank" rel="external">http://gradle.org/，最新</a> Gradle 6.0.1</p>
<p>文档：<a href="https://docs.gradle.org/current/release-notes.html，其中的" target="_blank" rel="external">https://docs.gradle.org/current/release-notes.html，其中的</a> User Guide 和 DSL Reference 很关键，User Guide 就是介绍 Gradle 的一本书，而 DSL Reference 是 Gradle API 的说明。</p>
<p>MacOs 安装：</p>
<ul>
<li>下载 Gradle：<a href="http://gradle.org/gradle-download/" target="_blank" rel="external">http://gradle.org/gradle-download/</a>  选择Complete distribution和Binary only distribution都行。然后解压到指定目录</li>
<li>设置 ~/.bashrc 把 Gradle 加到 PATH 里</li>
<li>执行 source ~/.bashrc 初始化环境</li>
<li>执行 gradle –version 显示 Gradle 版本号</li>
</ul>
<p>注意，为什么说 Gradle 是一个编程框架？来看它提供的 API 文档：</p>
<p><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></p>
<p>原来，我们编写所谓的编译脚本，其实就是玩 Gradle 的 API…. 所以它从更底层意义上看，是一个编程框架！</p>
<p>既然是编程框架，我在讲解 Gradle 的时候，尽量会从 API 的角度来介绍。有些读者肯定会不耐烦，为嘛这么费事？</p>
<p><strong>从我个人的经历来看：因为我从网上学习到的资料来看，几乎全是从脚本的角度来介绍 Gradle，结果学习一通下来，只记住参数怎么配置，却不知道它们都是函数调用，都是严格对应相关 API 的。</strong></p>
<p>而从 API 角度来看待 Gradle 的话，有了 SDK 文档，你就可以编程。编程是靠记住一行行代码来实现的吗？不是，是在你掌握大体流程，然后根据 SDK + API 来完成的！</p>
<p>其实，Gradle 自己的 User Guide 也明确说了：</p>
<p><strong>Build scripts are code</strong></p>
<h2 id="3-2-基本组件"><a href="#3-2-基本组件" class="headerlink" title="3.2 基本组件"></a>3.2 基本组件</h2><p>Gradle 是一个框架，它定义一套自己的游戏规则。我们要玩转 Gradle，必须要遵守它设计的规则。下面我们来讲讲 Gradle 的基本组件：</p>
<p>Gradle 中，每一个待编译的工程都叫一个 Project。每一个 Project 在构建的时候都包含一系列的 Task。比如一个 Android APK 的编译可能包含：<strong>Java 源码编译 Task、资源编译 Task、JNI 编译 Task、lint 检查 Task、打包生成 APK 的 Task、签名 Task 等。</strong></p>
<p>一个 Project 到底包含多少个 Task，其实是由编译脚本指定的插件决定。插件是什么呢？插件就是用来定义 Task，并具体执行这些 Task 的东西。</p>
<p>Gradle 是一个框架，作为框架，它负责定义流程和规则。而具体的编译工作则是通过插件的方式来完成的。比如<strong>编译 Java 有 Java 插件，编译 Groovy 有 Groovy 插件，编译 Android APP 有 Android APP 插件，编译 Android Library 有 Android Library 插件</strong></p>
<p>到现在为止，你知道 Gradle 中每一个待编译的工程都是一个 Project，一个具体的编译过程是由一个一个的 Task 来定义和执行的。</p>
<h3 id="3-2-1-一个重要的例子"><a href="#3-2-1-一个重要的例子" class="headerlink" title="3.2.1 一个重要的例子"></a>3.2.1 一个重要的例子</h3><p>演示向日葵项目</p>
<p><img desc="向日葵工程目录结构" src="http://wanghaoxun.com/img/gradle-xrk-project.jpg" width="60%"></p>
<ul>
<li>BIZ(biz-task,biz-transfer)、BIZService(biz-core,biz-form,biz-lego) 是 Android Library。其中，BIZ 下面的 library 依赖 BIZService library</li>
<li>CRMApp 和 MiniApp 是 Android APP。这些 App 和 SDK 有依赖关系。CRMApp 依赖所有的 BIZ library。</li>
</ul>
<p>问题1：请回答问题，在上面这个例子中，有多少个 Project？</p>
<p>答案是：每一个 Library 和每一个 App 都是单独的 Project。根据 Gradle 的要求，每一个 Project 在其根目录下都需要有一个 build.gradle。build.gradle 文件就是该 Project 的编译脚本，类似于 Makefile。</p>
<p>问题2：这么多 project，我们要独立编译他们的话，得 cd 某个 project，然后执行 gradle xxx，这会很麻烦，这么多 project，每个都得重复执行。可不可以在工程下执行 gradle assemble 把这些 Project 的东西都编译出来呢？</p>
<p>答案自然是可以。在 Gradle 中，这叫 Multi-Projects Build。在项目下添加个 settings.gradle 文件，名字必须是 settings.gradle。它里边用来告诉 Gradle，这个 multiprojects 包含多少个子 Project。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">include ModuleA,ModuleB...</div></pre></td></tr></table></figure>
<h3 id="3-2-2-Gradle-命令介绍"><a href="#3-2-2-Gradle-命令介绍" class="headerlink" title="3.2.2 Gradle 命令介绍"></a>3.2.2 Gradle 命令介绍</h3><ol>
<li>gradle projects 查看工程信息</li>
</ol>
<p><code>./gradlew projects</code> 可以查看 multi projects 到底包含多少个子 Project</p>
<ol>
<li>gradle tasks 查看任务信息</li>
</ol>
<p><code>./gradlew project-path:tasks</code> 查看某个 Project 包含哪些 Task 信息。</p>
<p>Android Library 对应的插件定义了好多 Task。每种插件定义的 Task 都不尽相同，这就是所谓的 Domain Specific，需要我们对相关领域有比较多的了解。</p>
<ol>
<li>gradle task-name 执行任务</li>
</ol>
<p>上面列出了好多任务，这时候就可以通过 gradle 任务名来执行某个任务。这和 make xxx 很像。比如：</p>
<ul>
<li>gradle clean 是执行清理任务，和 make clean 类似。</li>
<li>gradle properites 用来查看所有属性信息。</li>
</ul>
<p>这里要强调一点：Task 和 Task 之间往往是有关系的，这就是所谓的依赖关系。比如，assemble task 就依赖其他 task 先执行，assemble 才能完成最终的输出。</p>
<p>大家先了解这么多，等后面介绍如何写 gradle 脚本的时候，这就是调用几个函数的事情，Nothing Special!</p>
<h2 id="3-3-Gradle-工作流程"><a href="#3-3-Gradle-工作流程" class="headerlink" title="3.3 Gradle 工作流程"></a>3.3 Gradle 工作流程</h2><p>Gradle 的工作流程其实蛮简单，用一个图来表示：</p>
<p><img src="http://wanghaoxun.com/gradle%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Gradle 工作流程"></p>
<p>Gradle 工作包含三个阶段：</p>
<ul>
<li>首先是初始化阶段。对我们前面的 multi-project build 而言，就是执行 settings.gradle</li>
<li>Initiliazation phase 的下一个阶段是 Configration 阶段</li>
<li>Configration 阶段的目标是解析每个 project 中的 build.gradle。比如 multi-project build 例子中，解析每个子目录中的 build.gradle。在这两个阶段之间，我们可以加一些定制化的 Hook。这当然是通过 API 来添加的</li>
<li>Configuration 阶段完了后，整个 build 的 project 以及内部的 Task 关系就确定了。恩？前面说过，一个 Project 包含很多 Task，每个 Task 之间有依赖关系。Configuration 会建立一个有向图来描述 Task 之间的依赖关系。所以，我们可以添加一个 HOOK，即当 Task 关系图建立好后，执行一些操作</li>
<li>最后一个阶段就是执行任务了。当然，任务执行完后，我们还可以加 Hook</li>
</ul>
<p>关于 Gradle 的工作流程，你只要记住：</p>
<ul>
<li>Gradle 有一个初始化流程，这个时候 settings.gradle 会执行。</li>
<li>在配置阶段，每个 Project 都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。</li>
<li>然后才是执行阶段。你在 gradle xxx 中指定什么任务，gradle 就会将这个 xxx 任务链上的所有任务全部按依赖顺序执行一遍！</li>
</ul>
<p>Gradle 对应项目执行流程图：</p>
<p><img src="http://wanghaoxun.com/img/Gradle 执行流程.jpg" width="60%"></p>
<p><strong>接下来告诉你怎么写代码！！！</strong></p>
<h2 id="Gradle-编程模型及-API-实例详解"><a href="#Gradle-编程模型及-API-实例详解" class="headerlink" title="Gradle 编程模型及 API 实例详解"></a>Gradle 编程模型及 API 实例详解</h2><p><strong><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a> 这个文档很重要，在强调一遍~</strong></p>
<p>Gradle 基于 Groovy，Groovy 又基于 Java。所以，Gradle 执行的时候和 Groovy 一样，会把脚本转换成 Java 对象。Gradle 主要有三种对象，这三种对象和三种不同的脚本文件对应，在 gradle 执行的时候，会将脚本转换成对应的对端：</p>
<ul>
<li>Gradle 对象：当我们执行 gradle xxx 或者什么的时候，gradle 会从默认的配置脚本中构造出一个 Gradle 对象。在整个执行过程中，只有这么一个对象。Gradle 对象的数据类型就是 Gradle。我们一般很少去定制这个默认的配置脚本。</li>
<li>Project 对象：每一个 build.gradle 会转换成一个 Project 对象。</li>
<li>Settings 对象：显然，每一个 settings.gradle 都会转换成一个 Settings 对象。</li>
</ul>
<p>注意，对于其他 gradle 文件，除非定义了 class，否则会转换成一个实现了 Script 接口的对象。这一点和 Groovy 的脚本类相似。</p>
<p>当我们执行 gradle 的时候，gradle 首先是按顺序解析各个 gradle 文件。这里边就有所所谓的生命周期的问题，即先解析谁，后解析谁。图示是 Gradle 文档中对生命周期的介绍：结合上一节的内容，相信大家都能看明白了。现在只需要看红框里的内容：</p>
<p><img src="http://wanghaoxun.com/gradle-lifecycle.png" alt="Gradle-Lifecycle"></p>
<p>文档地址：<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Project.html</a></p>
<h2 id="3-4-1-Gradle-对象"><a href="#3-4-1-Gradle-对象" class="headerlink" title="3.4.1 Gradle 对象"></a>3.4.1 Gradle 对象</h2><p>我们先来看 Gradle 对象，它有哪些属性呢？跳转到文档，看看：<a href="https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html</a></p>
<p>可以尝试在 Setting.gradle 和 CRMApp build.gradle 中打印查看 gradle 详细信息：</p>
<ul>
<li>可发现 gradle 对象的 hashCode 一样</li>
<li>HomeDir 是在哪个目录存储的 gradle 可执行程序 </li>
<li>User Home Dir：是 gradle 自己设置的目录，里边存储了一些配置文件，以及编译过程中的缓存文件，生成的类文件，编译中依赖的插件等等。~/.gradle 目录</li>
</ul>
<h2 id="3-4-2-Project-对象"><a href="#3-4-2-Project-对象" class="headerlink" title="3.4.2 Project 对象"></a>3.4.2 Project 对象</h2><p>每一个 build.gradle 文件都会转换成一个 Project 对象。在 Gradle 术语中，Project 对象对应的是 Build Script。</p>
<p>Project 包含若干 Tasks。另外，由于 Project 对应具体的工程，所以需要为 Project 加载所需要的插件，比如为 Java 工程加载 Java 插件。其实，一个 Project 包含多少 Task 往往是插件决定的。</p>
<p>所以，在 Project 中，我们要：</p>
<ul>
<li>加载插件</li>
<li>不同插件有不同的行话，即不同的配置。例如我们要在 Project 中配置好 code 目录，这样插件就知道从哪里读取源文件等</li>
<li>设置属性</li>
</ul>
<ol>
<li>加载插件</li>
</ol>
<p>Project 的 API 位于 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a> 加载插件是调用它的 apply 函数。apply 其实是 Project 实现的</p>
<p>PluginAware 接口定义的：</p>
<p>apply 的用法：</p>
<p>apply 是一个函数，此处调用的是一个 apply 重载函数。注意，Groovy 支持函数调用的时候通过 参数名 1: 参数值 1，参数名 2：参数值 2 的方式来传递参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Project implements PluginAware #apply(..) 函数生命</div><div class="line">void apply(Map&lt;String, ?&gt; options)</div><div class="line"></div><div class="line">// 使用</div><div class="line">apply plugin: &apos;com.android.application&apos;</div></pre></td></tr></table></figure>
<p>问题：除了加载二进制的插件（上面的插件其实都是下载了对应的 jar 包，这也是通常意义上我们所理解的插件），还可以加载一个 gradle 文件。为什么要加载 gradle 文件呢？</p>
<p>其实这和代码的模块划分有关。一般而言，我会把一些通用的函数放到一个名叫 utils.gradle 文件里。然后在其他工程的 build.gradle 来加载这个 utils.gradle。这样，通过一些处理，我就可以调用 utils.gradle 中定义的函数了。</p>
<p>加载 utils.gradle 插件的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apply from: rootProject.getRootDir().getAbsolutePath() + &quot;/utils.gradle&quot;</div></pre></td></tr></table></figure>
<p>utils.gradle 是我封装的一个 gradle 脚本，里边定义了一些方便函数，比如读取 AndroidManifest.xml 中的 versionName，或者是 copy jar 包/APK<br>包到指定的目录。</p>
<p>问题：那么，apply 最后一个函数到底支持哪些参数呢？</p>
<p>还得查阅文档来看说明，我这里不遗余力的列出 API 图片，就是希望大家在写脚本的时候，碰到不会的，一定要去查看 API 文档！这点很重要！！！</p>
<ol>
<li>设置属性</li>
</ol>
<p>如果是单个脚本，则不需要考虑属性的跨脚本传播，但是 Gradle 往往包含不止一个 build.gradle 文件，比如我设置的 utils.gradle，settings.gradle。如何在多个脚本中设置属性呢？</p>
<p>Gradle 提供了一种名为 extra property 的方法。extra property 是额外属性的意思，在第一次定义该属性的时候需要通过 ext 前缀来标示它是一个额外的属性。定义好之后，后面的存取就不需要 ext 前缀了。ext 属性支持 Project 和 Gradle 对象。即 Project 和 Gradle 对象都可以设置 ext 属性。</p>
<p>举个栗子：</p>
<ul>
<li>在 setting.gradle 文件为 Gradle 对象设置一些外置属性，</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def initGradleEnvironment()&#123;  </div><div class="line">    // 属性值从 local.properites 中读取  </div><div class="line">    Propertiesproperties = new Properties()  </div><div class="line">    File propertyFile = new File(rootDir.getAbsolutePath() +&quot;/local.properties&quot;)  </div><div class="line">    properties.load(propertyFile.newDataInputStream())  </div><div class="line">    //gradle 就是 gradle 对象。它默认是 Settings 和 Project 的成员变量。可直接获取  </div><div class="line">   //ext 前缀，表明操作的是外置属性。api 是一个新的属性名。前面说过，只在  </div><div class="line">   // 第一次定义或者设置它的时候需要 ext 前缀  </div><div class="line">    gradle.ext.api = properties.getProperty(&apos;sdk.api&apos;)  </div><div class="line">     </div><div class="line">    println gradle.api  // 再次存取 api 的时候，就不需要 ext 前缀了  </div><div class="line">    ......  </div><div class="line">&#125; </div><div class="line"></div><div class="line">// 调用初始化</div><div class="line">initGradleEnvironment()</div></pre></td></tr></table></figure>
<ul>
<li>再强化栗子，utils.gradle 文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// utils.gradle 中定义了一个获取 AndroidManifests.xmlversionName 的函数  </div><div class="line">def  getVersionName()&#123;  </div><div class="line">   // 问题1：下面这行代码中的 project 是谁？  </div><div class="line">   defxmlFile = project.file(&quot;AndroidManifest.xml&quot;)  </div><div class="line">   defrootManifest = new XmlSlurper().parse(xmlFile)  </div><div class="line">   returnrootManifest[&apos;@android:versionName&apos;]    </div><div class="line">&#125;  </div><div class="line">// 现在，想把这个 API 输出到各个 Project。由于这个 utils.gradle 会被每一个 Project Apply，所以  </div><div class="line">// 我可以把 getVersionName 定义成一个 closure，然后赋值到一个外部属性  </div><div class="line"></div><div class="line">// 问题2：下面的 ext 是谁的 ext？  </div><div class="line">ext&#123; // 此段花括号中代码是闭包  </div><div class="line">    // 除了 ext.xxx=value 这种定义方法外，还可以使用 ext&#123;&#125;这种书写方法。  </div><div class="line">    //ext&#123;&#125;不是 ext(Closure) 对应的函数调用。但是 ext&#123;&#125;中的&#123;&#125;确实是闭包。  </div><div class="line">    getVersionName = this.&amp;getVersionName  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>先来理清楚一个问题，Project 和 utils.gradle 对于的 Script 的对象的关系是：</p>
<ul>
<li>当一个 Project apply 一个 gradle 文件的时候，这个 gradle 文件会转换成一个 Script 对象。这个，相信大家都已经知道了。</li>
<li>Script 中有一个 delegate 对象，这个 delegate 默认是加载（即调用 apply）它的 Project 对象。但是，在 apply 函数中，有一个 from 参数，还有一个 to 参数。通过 to 参数，你可以把 delegate 对象指定为别的东西。</li>
<li>delegate 对象是什么意思？当你在 Script 中操作一些不是 Script 自己定义的变量，或者函数时候，gradle 会到 Script 的 delegate 对象去找，看看有没有定义这些变量或函数。</li>
</ul>
<p>现在你知道问题 1,2 和答案了：</p>
<ul>
<li>问题 1：project 就是加载 utils.gradle 的 project。由于 b_sales_android 有多个 project，所以 utils.gradle 会分别加载到 project 中。所以，getVersionName 才不用区分到底是哪个 project。反正一个 project 有一个 utils.gradle 对应的 Script。</li>
<li>问题 2：ext：自然就是 Project 对应的 ext 了。此处为 Project 添加了一些 closure。那么，在 Project 中就可以调用 getVersionName 函数了</li>
</ul>
<p>一些思考：</p>
<ul>
<li>Java 和 Groovy 中：我们会把常用的函数放到一个辅助类和公共类中，然后在别的地方 import 并调用它们。</li>
<li>但是在 Gradle，更正规的方法是在 xxx.gradle 中定义插件。然后通过添加 Task 的方式来完成工作。gradle 的 user guide 有详细介绍如何实现自己的插件。</li>
</ul>
<ol>
<li>Task 介绍</li>
</ol>
<p>Task 是 Gradle 中的一种数据类型，它代表了一些要执行或者要干的工作。不同的插件可以添加不同的 Task。每一个 Task 都需要和一个 Project 关联。</p>
<p>Task 的 API 文档位于 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</a> 关于 Task，我这里简单介绍下 build.gradle 中怎么写它，以及 Task 中一些常见的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//Task 是和 Project 关联的，所以，我们要利用 Project 的 task 函数来创建一个 Task  </div><div class="line">task myTask  &lt;==myTask 是新建 Task 的名字  </div><div class="line">task myTask &#123; configure closure &#125;  </div><div class="line">task myType &lt;&lt; &#123; task action &#125; &lt;== 注意，&lt;&lt; 符号是 doLast 的缩写  </div><div class="line">task myTask(type: SomeType)  </div><div class="line">task myTask(type: SomeType) &#123; configure closure &#125;</div></pre></td></tr></table></figure>
<p>上述代码中都用了 Project 的一个函数，名为 task，注意：</p>
<ul>
<li>一个 Task 包含若干 Action。所以，Task 有 doFirst 和 doLast 两个函数，用于添加需要最先执行的 Action 和需要和需要最后执行的 Action。Action 就是一个闭包。</li>
<li>Task 创建的时候可以指定 Type，通过type: 名字表达。这是什么意思呢？其实就是告诉 Gradle，这个新建的 Task 对象会从哪个基类 Task 派生。比如，Gradle 本身提供了一些通用的 Task，最常见的有 Copy 任务。Copy 是 Gradle 中的一个类。当我们：task myTask(type:Copy)的时候，创建的 Task 就是一个 Copy Task。</li>
<li>当我们使用 task myTask{ xxx}的时候。花括号是一个 closure。这会导致 gradle 在创建这个 Task 之后，返回给用户之前，会先执行 closure 的内容。</li>
<li>当我们使用 task myTask &lt;&lt; {xxx}的时候，我们创建了一个 Task 对象，同时把 closure 做为一个 action 加到这个 Task 的 action 队列中，并且告诉它“最后才执行这个 closure”（注意，&lt;&lt; 符号是 doLast 的代表）。</li>
</ul>
<p><strong>讲了这么多东西，都有点烦了。是的，Gradle 用一整本书来讲都嫌不够呢！</strong></p>
<h2 id="3-4-3-b-sales-android-实例"><a href="#3-4-3-b-sales-android-实例" class="headerlink" title="3.4.3 b_sales_android 实例"></a>3.4.3 b_sales_android 实例</h2><p>现在正是开始通过例子来介绍怎么玩 gradle。这里要特别强调一点，根据 Gradle 的哲学。gradle 文件中包含一些所谓的 Script Block（姑且这么称它）。Script Block 作用是让我们来配置相关的信息。不同的 SB 有不同的需要配置的东西。这也是我最早说的行话。比如，源码对应的 SB，就需要我们配置源码在哪个文件夹里。关于 SB，我们后面将见识到！</p>
<p>b_sales_android 是一个 multi project。下面包含多个 Project。对于这种 Project，请大家回想下我们该创建哪些文件？</p>
<ul>
<li>settings.gradle 是必不可少的</li>
<li>根目录下的 build.gradle。这个我们没讲过，因为 b_sales_android 的根目录本身不包含代码，而是包含其他子 project。</li>
<li>每个 project 目录下包含对于的 build.gradle</li>
<li>另外，我把常用的函数封装到一个名为 utils.gradle 的脚本里了。</li>
</ul>
<p>马上一个一个来看它们：</p>
<ol>
<li>utils.gradle</li>
</ol>
<p>用来放一些获取版本号、拷贝文件等公共函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import groovy.util.XmlSlurper  // 解析 XML 时候要引入这个 groovy 的 package  </div><div class="line"> </div><div class="line">def getVersionName() &#123;</div><div class="line">   defxmlFile = project.file(&quot;AndroidManifest.xml&quot;)  </div><div class="line">   defrootManifest = new XmlSlurper().parse(xmlFile)  </div><div class="line">   returnrootManifest[&apos;@android:versionName&apos;]    </div><div class="line">&#125;  </div><div class="line">   </div><div class="line">// 对于 android library 编译，我会 disable 所有的 debug 编译任务  </div><div class="line">def disableDebugBuild() &#123;  </div><div class="line">  //project.tasks 包含了所有的 tasks，下面的 findAll 是寻找那些名字中带 debug 的 Task。  </div><div class="line">  // 返回值保存到 targetTasks 容器中  </div><div class="line">  def targetTasks = project.tasks.findAll&#123;task -&gt;  </div><div class="line">     task.name.contains(&quot;Debug&quot;)  </div><div class="line">  &#125;  </div><div class="line">  // 对满足条件的 task，设置它为 disable。如此这般，这个 Task 就不会被执行  </div><div class="line"> targetTasks.each&#123;  </div><div class="line">     println&quot;disable debug task  :$&#123;it.name&#125;&quot;  </div><div class="line">    it.setEnabled false  </div><div class="line">  &#125;  </div><div class="line">&#125;  </div><div class="line">// 将函数设置为 extra 属性中去，这样，加载 utils.gradle 的 Project 就能调用此文件中定义的函数了  </div><div class="line">ext&#123;  </div><div class="line">   getVersionName = this.&amp;getVersionName </div><div class="line">   disableDebugBuild = this.&amp;disableDebugBuild  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>setting.gradle</li>
</ol>
<p>这个文件中我们该干什么？调用 include 把需要包含的子 Project 加进来。代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 添加子 Project 信息  </div><div class="line">include &apos;:CRMApp&apos;</div><div class="line">include &apos;:biz-dev&apos;</div><div class="line">include &apos;:biz-test&apos;</div><div class="line">...</div><div class="line"></div><div class="line">/**</div><div class="line">  这个函数的目的是 </div><div class="line">  1  解析一个名为 local.properties 的文件，读取 AndroidSDK 和 NDK 的路径 </div><div class="line">  2  获取最终产出物目录的路径。这样，编译完的 apk 或者 jar 包将拷贝到这个最终产出物目录中 </div><div class="line">  3 获取 Android SDK 指定编译的版本 </div><div class="line">*/  </div><div class="line">def initXRKGradleEnvironment() &#123;   </div><div class="line">   println&quot;initialize xrk Gradle Environment .....&quot;  </div><div class="line">   Properties properties = new Properties()  </div><div class="line">   //local.properites 也放在 posdevice 目录下  </div><div class="line">   File propertyFile = new File(rootDir.getAbsolutePath()+ &quot;/local.properties&quot;)  </div><div class="line">   properties.load(propertyFile.newDataInputStream())  </div><div class="line">    /* </div><div class="line">      根据 Project、Gradle 生命周期的介绍，settings 对象的创建位于具体 Project 创建之前 </div><div class="line">      而 Gradle 底对象已经创建好了。所以，我们把 local.properties 的信息读出来后，通过 </div><div class="line">     extra 属性的方式设置到 gradle 对象中 </div><div class="line">      而具体 Project 在执行的时候，就可以直接从 gradle 对象中得到这些属性了！ </div><div class="line">    */  </div><div class="line">    gradle.ext.api =properties.getProperty(&apos;sdk.api&apos;)  </div><div class="line">    gradle.ext.sdkDir =properties.getProperty(&apos;sdk.dir&apos;)  </div><div class="line">     gradle.ext.ndkDir =properties.getProperty(&apos;ndk.dir&apos;)  </div><div class="line">     gradle.ext.localDir =properties.getProperty(&apos;local.dir&apos;)  </div><div class="line">    // 指定 debugkeystore 文件的位置，debug 版 apk 签名的时候会用到  </div><div class="line">    gradle.ext.debugKeystore= properties.getProperty(&apos;debug.keystore&apos;)  </div><div class="line">     ......  </div><div class="line">    println&quot;initialize xrk Gradle Environment completed...&quot;  </div><div class="line">&#125;  </div><div class="line">// 初始化  </div><div class="line">initXRKGradleEnvironment()</div></pre></td></tr></table></figure>
<p>注意，对于 Android 来说，local.properties 文件是必须的，它的内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 注意，根据 Android Gradle 的规范，只有下面两个属性是必须的，其余都是我自己加的  </div><div class="line">sdk.dir=/Users/Nelson/Library/Android/sdk</div><div class="line">ndk.dir=/Users/Nelson/Library/Android/android-ndk-r16b</div><div class="line">sdk.api=android-21</div><div class="line">// 本地签名绝对地址</div><div class="line">debug.keystore=/Users/Nelson/Downloads/guazi/tools/mykeystore.jks  </div><div class="line">// 生成 library artifact 对应目录地址</div><div class="line">local.dir=/Users/Nelson/Downloads/guazi/xrk-flat-dir/</div></pre></td></tr></table></figure>
<ol>
<li>b_sales_android build.gradle </li>
</ol>
<p>作为 multi-project 根目录，一般情况下，它的 build.gradle 是做一些全局配置。来看我们的 build.gradle</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 下面这个 subprojects&#123;&#125;就是一个 Script Block  </div><div class="line">subprojects &#123;  </div><div class="line">  println&quot;Configure for $project.name&quot; // 遍历子 Project，project 变量对应每个子 Project  </div><div class="line">  buildscript &#123;  // 这也是一个 SB  </div><div class="line">    repositories &#123;//repositories 是一个 SB  </div><div class="line">       ///jcenter 是一个函数，表示编译过程中依赖的库，所需的插件可以在 jcenter 仓库中  </div><div class="line">       // 下载。  </div><div class="line">       jcenter()  </div><div class="line">    &#125;  </div><div class="line">    dependencies &#123; //SB  </div><div class="line">        //dependencies 表示我们编译的时候，依赖 android 开发的 gradle 插件。插件对应的  </div><div class="line">       //class path 是 com.android.tools.build。版本是 3.1.4  </div><div class="line">        classpath&apos;com.android.tools.build:gradle:3.1.4&apos;  </div><div class="line">    &#125;  </div><div class="line">   // 为每个子 Project 加载 utils.gradle 。当然，这句话可以放到 buildscript 花括号之后  </div><div class="line">   applyfrom: rootProject.getRootDir().getAbsolutePath() + &quot;/utils.gradle&quot;  </div><div class="line"> &#125;//buildscript 结束  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>SB 在 Gradle 的 API 文档中也是有的。先来看 Gradle 定义了哪些 SB。</strong></p>
<p><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Project.html</a></p>
<p>你看，subprojects、dependencies、repositories 都是 SB。那么 SB 到底是什么？它是怎么完成所谓配置的呢？</p>
<p>仔细研究，你会发现 SB 后面都需要跟一个花括号，而花括号，恩，我们感觉里边可能一个 Closure。由于文档中这些 SB 的 Description 都有“Configure xxx for this project”，所以很可能 subprojects 是一个函数，然后其参数是一个 Closure。是这样的吗？</p>
<p>Absolutely right。只是这些函数你直接到 Project API 里不一定能找全。不过要是你好奇心重，不妨到 <a href="https://docs.gradle.org/current/javadoc/" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/</a> 选择 Index 这一项，然后 ctrl+f，输入任何一个 Block，你都会找到对应的函数。比如我替你找了几个 API：演示去文档查找，例如 buildscript <a href="https://docs.gradle.org/current/javadoc/index-all.html#I:B" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/index-all.html#I:B</a></p>
<p><strong>特别提示：当你下次看到一个不认识的 SB 的时候，就去看 API 吧。</strong></p>
<p>下面来解释代码中的各个 SB：</p>
<ul>
<li>subprojects：它会遍历 b_sales_android 中的每个子 Project。在它的 Closure 中，默认参数是子 Project 对应的 Project 对象。由于其他 SB 都在 subprojects 花括号中，所以相当于对每个 Project 都配置了一些信息。</li>
<li>buildscript：它的 closure 是在一个类型为 ScriptHandler 的对象上执行的。主要用来所依赖的 classpath 等信息。通过查看 ScriptHandler API 可知，在 buildscript SB 中，你可以调用 ScriptHandler 提供的 repositories(Closure )、dependencies(Closure) 函数。这也是为什么 repositories 和 dependencies 两个 SB 为什么要放在 buildscript 的花括号中的原因。明白了？这就是所谓的行话，得知道规矩。不知道规矩你就乱了。记不住规矩，又不知道查 SDK，那么就彻底抓瞎，只能到网上到处找答案了！</li>
<li>关于 repositories 和 dependencies，大家直接看 API 吧。后面碰到了具体代码我们再来介绍</li>
</ul>
<ol>
<li>BIZ-xxx build.gradle</li>
</ol>
<p>BIZ-xxx 是一个 Android Library。按 Google 的想法，Android Library 编译出来的应该是一个 AAR 文件。但是加入这时我们的项目有些特殊，我需要发布 xxx.jar 包给其他人使用。jar 在编译过程中会生成，但是它不属于 Android Library 的标准输出。在这种情况下，我需要在编译完成后，主动 copy jar 包到我自己设计的产出物目录中。</p>
<p>BIZ 下的工程都是一个个 Android Library。按 Google 的想法，Android Library 编译出来的应该是一个 AAR 文件。</p>
<p>问题：我现在需要发布 biz-xxx.jar 包给其他人使用，怎么办？</p>
<p>jar 在编译过程中会生成，但是它不属于 Android Library 的标准输出。在这种情况下，需要在编译完成后，主动 copy jar 包到我自己设计的产出目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Library 工程必须加载此插件。注意，加载了 Android 插件就不要加载 Java 插件了。因为 Android  </div><div class="line">// 插件本身就是拓展了 Java 插件  </div><div class="line">apply plugin: &apos;com.android.library&apos;   </div><div class="line">//android 的编译，增加了一种新类型的 ScriptBlock--&gt;android  </div><div class="line">android &#123;  </div><div class="line">       // 我在 local.properties 中设置的 API 版本号，就可以一次设置，多个 Project 使用了  </div><div class="line">      // 借助我特意设计的 gradle.ext.api 属性  </div><div class="line">       compileSdkVersion = gradle.api </div><div class="line">       sourceSets&#123; // 配置源码路径。这个 sourceSets 是 Java 插件引入的  </div><div class="line">           main&#123; //main：Android 也用了  </div><div class="line">               manifest.srcFile &apos;AndroidManifest.xml&apos; // 这是一个函数，设置 manifest.srcFile  </div><div class="line">               aidl.srcDirs=[&apos;src&apos;] // 设置 aidl 文件的目录  </div><div class="line">               java.srcDirs=[&apos;src&apos;] // 设置 java 文件的目录  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        </div><div class="line">        dependencies &#123;  // 配置依赖关系  </div><div class="line">          // compile 表示编译和运行时候需要的 jar 包，fileTree 是一个函数，  </div><div class="line">         // dir:&apos;libs&apos;，表示搜索目录的名称是 libs。include:[&apos;*.jar&apos;]，表示搜索目录下满足 *.jar 名字的 jar  </div><div class="line">         // 包都作为依赖 jar 文件  </div><div class="line">           compile fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;])  </div><div class="line">       &#125;  </div><div class="line">&#125;  //android SB 配置完了  </div><div class="line"></div><div class="line">// 前面说了，我要把 jar 包拷贝到指定的目录。对于 Android 编译，我一般指定 gradle assemble  </div><div class="line">// 它默认编译 debug 和 release 两种输出。所以，下面这个段代码表示：  </div><div class="line">//tasks 代表一个 Projects 中的所有 Task，是一个容器。getByName 表示找到指定名称的任务。  </div><div class="line">// 我这里要找的 assemble 任务，然后我通过 doLast 添加了一个 Action。这个 Action 就是 copy  </div><div class="line">// 产出物到我设置的目标目录中去  </div><div class="line"></div><div class="line">tasks.getByName(&quot;assemble&quot;)&#123;  </div><div class="line">   it.doLast&#123;  </div><div class="line">       println &quot;$project.name: After assemble, jar libs are copied tolocal repository&quot;  </div><div class="line">        copyOutput(true)</div><div class="line">        </div><div class="line">        // 具体函数内部如下：</div><div class="line">        from(&apos;build/intermediates/bundles/release/&apos;)</div><div class="line">        into(&apos;build/outputs/&apos;)</div><div class="line">        include(&apos;classes.jar&apos;)</div><div class="line">        rename (&apos;classes.jar&apos;, &apos;myLib.jar&apos;)</div><div class="line">        into(&apos;release/&apos;) //you can change this directory where you want to copy your .jar</div><div class="line">     &#125;  </div><div class="line">&#125;  </div><div class="line">/* </div><div class="line">  因为我的项目只提供最终的 release 编译出来的 Jar 包给其他人，所以不需要编译 debug 版的东西 </div><div class="line">  当 Project 创建完所有任务的有向图后，我通过 afterEvaluate 函数设置一个回调 Closure。在这个回调 </div><div class="line">  Closure 里，我 disable 了所有 Debug 的 Task </div><div class="line">*/  </div><div class="line">project.afterEvaluate&#123;  </div><div class="line">    disableDebugBuild()  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Android 自己定义了很多 ScriptBlock，Android 定义的 DSL 参考文档在：</p>
<p><strong>Android Gradle Plugin release notes</strong></p>
<p><a href="https://developer.android.com/studio/releases/gradle-plugin" target="_blank" rel="external">https://developer.android.com/studio/releases/gradle-plugin</a></p>
<p>这条很重要，请惠存！里面包含了：<a href="http://google.github.io/android-gradle-dsl/current/" target="_blank" rel="external">Android Plugin DSL Reference</a>、<a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="external">Configure Your Build</a>、<a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Reference</a></p>
<p>AGP-Android Gradle Plugin 版本号</p>
<p><img desc="AGP 版本对比" src="http://wanghaoxun.com/img/gradle-agp-version.jpg" width="60%"></p>
<ol>
<li>CRMApp build.gradle</li>
</ol>
<p>再来看看 APK 的 build，它内部包含了编译（class，NDK），还有签名。</p>
<p>问题：根据项目需求，我们开发只能签 debug 版本的，而 release 版的签名得发布 unsigned 包给 leader 签名，怎么办？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;  //APK 编译必须加载这个插件  </div><div class="line">android &#123;  </div><div class="line">    compileSdkVersion gradle.api  </div><div class="line">    buildToolsVersion &quot;22.0.1&quot;  </div><div class="line">    sourceSets&#123; </div><div class="line">        main&#123;  </div><div class="line">            // 设置 jni 和 java 目录</div><div class="line">            jni.srcDirs = []  </div><div class="line">            java.srcDirs=[&apos;src&apos;]  </div><div class="line">               </div><div class="line">        &#125;  </div><div class="line">    &#125;//main 结束  </div><div class="line">    signingConfigs &#123; // 设置签名信息配置  </div><div class="line">        debug &#123;  // 如果我们在 local.properties 设置使用特殊的 keystore，则使用它  </div><div class="line">           // 下面这些设置，无非是函数调用.... 请务必阅读 API 文档  </div><div class="line">           if(project.gradle.debugKeystore != null)&#123;  </div><div class="line">              storeFile file(&quot;file://$&#123;project.gradle.debugKeystore&#125;&quot;)  </div><div class="line">              storePassword &quot;android&quot;  </div><div class="line">              keyAlias &quot;androiddebugkey&quot;  </div><div class="line">              keyPassword &quot;android&quot;  </div><div class="line">           &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;//signingConfigs 结束  </div><div class="line">    </div><div class="line">    buildTypes &#123;  </div><div class="line">        debug &#123;  </div><div class="line">            signingConfig signingConfigs.debug  </div><div class="line">            jniDebuggable false  </div><div class="line">        &#125;  </div><div class="line">    &#125;//buildTypes 结束  </div><div class="line">    </div><div class="line">    repositories &#123;  </div><div class="line">        flatDir &#123;//flatDir：告诉 gradle，编译中依赖的 jar 包存储在 dirs 指定的目录  </div><div class="line">           name &quot;minsheng-gradle-local-repository&quot; dirs gradle.LOCAL_JAR_OUT //LOCAL_JAR_OUT 是我存放编译出来的 jar 包的位置  </div><div class="line">        &#125;  </div><div class="line">    &#125;//repositories 结束  </div><div class="line">&#125;//android 结束  </div><div class="line">/* </div><div class="line">   创建一个 Task，类型是 Exec，这表明它会执行一个命令。我这里让他执行 ndk 的 </div><div class="line">   ndk-build 命令，用于编译 ndk。关于 Exec 类型的 Task，请自行脑补 Gradle 的 API </div><div class="line">*/  </div><div class="line">// 注意此处创建 task 的方法，是直接&#123;&#125;喔，那么它后面的 tasks.withType(JavaCompile)  </div><div class="line">// 设置的依赖关系，还有意义吗？Think！如果你能想明白，gradle 掌握也就差不多了  </div><div class="line">task buildNative(type: Exec, description: &apos;CompileJNI source via NDK&apos;) &#123;  </div><div class="line">       if(project.gradle.ndkDir == null) // 看看有没有指定 ndk.dir 路径  </div><div class="line">          println &quot;CANNOT Build NDK&quot;  </div><div class="line">       else&#123;  </div><div class="line">            commandLine &quot;/$&#123;project.gradle.ndkDir&#125;/ndk-build&quot;,  </div><div class="line">               &apos;-C&apos;, file(&apos;jni&apos;).absolutePath,  </div><div class="line">               &apos;-j&apos;, Runtime.runtime.availableProcessors(),  </div><div class="line">               &apos;all&apos;, &apos;NDK_DEBUG=0&apos;  </div><div class="line">        &#125;  </div><div class="line">  &#125;  </div><div class="line"> tasks.withType(JavaCompile) &#123;  </div><div class="line">       compileTask -&gt; compileTask.dependsOn buildNative  </div><div class="line">  &#125;  </div><div class="line">  .....</div></pre></td></tr></table></figure>
<ol>
<li>再来个实例演示</li>
</ol>
<p>问题：现在 App 有个特点，有三个版本，分别是 debug、release 和 demo。这三个版本对应的代码都一样，但是在运行的时候会跳转到 debug、release 或者 demo 的逻辑上。</p>
<p>办法：在编译 build、release 和 demo 版本前，在 build.gradle 中自动设置 runtime_config 的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">apply plugin: &apos;com.android.application&apos;  // 加载 APP 插件  </div><div class="line"></div><div class="line">    signingConfigs &#123;</div><div class="line">        debug &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    /* </div><div class="line">     最关键的内容来了： buildTypes ScriptBlock。</div><div class="line">     buildTypes 和上面的 signingConfigs，当我们在 build.gradle 中通过&#123;&#125;配置它的时候， </div><div class="line">     其背后的所代表的对象是 NamedDomainObjectContainer&lt;BuildType&gt; 和 </div><div class="line">     NamedDomainObjectContainer&lt;SigningConfig&gt; </div><div class="line">     注意，NamedDomainObjectContainer&lt;BuildType 或者 SigningConfig&gt; 是一种容器， </div><div class="line">     容器的元素是 BuildType 或者 SigningConfig。我们在 debug&#123;&#125;要填充 BuildType 或者 </div><div class="line">    SigningConfig 所包的元素，比如 storePassword 就是 SigningConfig 类的成员。而 proguardFile 等 </div><div class="line">    是 BuildType 的成员。 </div><div class="line">    那么，为什么要使用 NamedDomainObjectContainer 这种数据结构呢？因为往这种容器里 </div><div class="line">    添加元素可以采用这样的方法： 比如 signingConfig 为例 </div><div class="line">    </div><div class="line">    signingConfigs &#123;// 这是一个 NamedDomainObjectContainer&lt;SigningConfig&gt; </div><div class="line">       test1&#123;// 新建一个名为 test1 的 SigningConfig 元素，然后添加到容器里 </div><div class="line">         // 在这个花括号中设置 SigningConfig 的成员变量的值 </div><div class="line">       &#125; </div><div class="line">      test2&#123;// 新建一个名为 test2 的 SigningConfig 元素，然后添加到容器里 </div><div class="line">         // 在这个花括号中设置 SigningConfig 的成员变量的值 </div><div class="line">      &#125; </div><div class="line">    &#125; </div><div class="line">    在 buildTypes 中，Android 默认为这几个 NamedDomainObjectContainer 添加了 </div><div class="line">    debug 和 release 对应的对象。如果我们再添加别的名字的东西，那么 gradle assemble 的时候 </div><div class="line">    也会编译这个名字的 apk 出来。比如，我添加一个名为 test 的 buildTypes，那么 gradle assemble </div><div class="line">    就会编译一个 xxx-test-yy.apk。在此，test 就好像 debug、release 一样。 </div><div class="line">   */  </div><div class="line">   buildTypes&#123;  </div><div class="line">        debug&#123; // 修改 debug 的 signingConfig 为 signingConfig.debug 配置  </div><div class="line">            signingConfig signingConfigs.debug  </div><div class="line">        &#125;  </div><div class="line">        demo&#123; //demo 版需要混淆  </div><div class="line">            proguardFile &apos;proguard-project.txt&apos;  </div><div class="line">            signingConfig signingConfigs.debug  </div><div class="line">        &#125;  </div><div class="line">       // release 版没有设置，所以默认没有签名，没有混淆  </div><div class="line">    &#125;  </div><div class="line">    </div><div class="line">    // 来看如何动态生成 runtime_config 文件  </div><div class="line">   def runtime_config_file = &apos;assets/runtime_config&apos;  </div><div class="line">   /* </div><div class="line">   我们在 gradle 解析完整个任务之后，找到对应的 Task，然后在里边添加一个 doFirst Action </div><div class="line">   这样能确保编译开始的时候，我们就把 runtime_config 文件准备好了。 </div><div class="line">   注意，必须在 afterEvaluate 里边才能做，否则 gradle 没有建立完任务有向图，你是找不到 </div><div class="line">   什么 preDebugBuild 之类的任务的 </div><div class="line">   */  </div><div class="line">   project.afterEvaluate&#123;  </div><div class="line">      // 找到 preDebugBuild 任务，然后添加一个 Action   </div><div class="line">      tasks.getByName(&quot;preDebugBuild&quot;)&#123;  </div><div class="line">           it.doFirst&#123;  </div><div class="line">               println &quot;generate debug configuration for $&#123;project.name&#125;&quot;  </div><div class="line">               def configFile = new File(runtime_config_file)  </div><div class="line">               configFile.withOutputStream&#123;os-&gt;  </div><div class="line">                   os &lt;&lt; I am Debug\n&apos;  // 往配置文件里写 I am Debug  </div><div class="line">                &#125;  </div><div class="line">           &#125;  </div><div class="line">        &#125;  </div><div class="line">       // 找到 preReleaseBuild 任务  </div><div class="line">       tasks.getByName(&quot;preReleaseBuild&quot;)&#123;  </div><div class="line">           it.doFirst&#123;  </div><div class="line">               println &quot;generate release configuration for $&#123;project.name&#125;&quot;  </div><div class="line">               def configFile = new File(runtime_config_file)  </div><div class="line">               configFile.withOutputStream&#123;os-&gt;  </div><div class="line">                   os &lt;&lt; I am release\n&apos;  </div><div class="line">               &#125;  </div><div class="line">           &#125;  </div><div class="line">        &#125;  </div><div class="line">       // 找到 preDemoBuild。这个任务明显是因为我们在 buildType 里添加了一个 demo 的元素  </div><div class="line">      // 所以 Android APP 插件自动为我们生成的  </div><div class="line">       tasks.getByName(&quot;preDemoBuild&quot;)&#123;  </div><div class="line">           it.doFirst&#123;  </div><div class="line">               println &quot;generate offlinedemo configuration for$&#123;project.name&#125;&quot;  </div><div class="line">               def configFile = new File(runtime_config_file)  </div><div class="line">               configFile.withOutputStream&#123;os-&gt;  </div><div class="line">                   os &lt;&lt; I am Demo\n&apos;  </div><div class="line">               &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"> .....//copyOutput</div></pre></td></tr></table></figure>
<p>why？为什么我知道有 preXXXBuild 这样的任务？</p>
<p><strong>./gradlew tasks –all 查看所有任务。然后，多尝试几次，直到成功</strong></p>
<h1 id="四、锦囊文档集合"><a href="#四、锦囊文档集合" class="headerlink" title="四、锦囊文档集合"></a>四、锦囊文档集合</h1><h2 id="所有文档集合"><a href="#所有文档集合" class="headerlink" title="所有文档集合"></a>所有文档集合</h2><ol>
<li><p>Groovy-最新版本 v2.5.8</p>
<ul>
<li><a href="http://www.groovy-lang.org/download.html#gvm" target="_blank" rel="external">Groovy 官网</a> </li>
<li><p><a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">Groovy 的 API 文档地址</a></p>
<p>Groovy I/O</p>
</li>
<li><p><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">java.io.File class</a></p>
</li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">java.io.InputStream class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">java.io.OutputStream class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" target="_blank" rel="external">java.io.Reader class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" target="_blank" rel="external">java.io.Writer class</a></li>
<li><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" target="_blank" rel="external">java.nio.file.Path class</a></li>
</ul>
</li>
<li><p>Gradle–最新版本 v6.0.1</p>
<ul>
<li><a href="http://gradle.org/" target="_blank" rel="external">Gradle 官网</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Reference</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html" target="_blank" rel="external">Gradle-Project</a></li>
<li><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">Gradle-Task</a></li>
<li><a href="https://docs.gradle.org/current/javadoc/" target="_blank" rel="external">Gradle javadoc</a></li>
</ul>
</li>
<li><p>AGP-Android Gradle Plugin</p>
<ul>
<li><a href="https://developer.android.com/studio/releases/gradle-plugin" target="_blank" rel="external">Android Gradle Plugin release notes-Google Gradle 总入口</a></li>
<li><a href="http://google.github.io/android-gradle-dsl/current/" target="_blank" rel="external">Android Plugin DSL Reference</a></li>
<li><a href="https://developer.android.com/studio/build/index.html" target="_blank" rel="external">Configure Your Build</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Reference</a></li>
</ul>
</li>
</ol>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>啰里啰嗦的讲了这么多 Gradle 知识，解开了它神秘的面纱，回想以前配置项目 Gradle 一直是我的心病，不知道如何下手，只能网上搜索，碰运气。走了不少弯路，直到完整学习了下 Gradle 框架，了解了套路，现在求解问题的思路也和以前不一样了：</p>
<ul>
<li>最开始的时候，我一直把 gradle 当做脚本看。然后到处到网上找怎么配置 gradle。可能能编译成功，但是完全不知道为什么。比如 NameDomainObjectContainer，为什么有 debug、release。能自己加别的吗？不知道怎么加，没有章法，没有参考。出了问题只能 google，找到一个解法，试一试，成功就不管。这么搞，心里不踏实。</li>
<li>另外，对语法不熟悉，尤其是 Groovy 语法，虽然看了下快速教材，但总感觉一到 gradle 就看不懂。主要问题还是闭包，比如 Groovy 那一节写得文件拷贝的例子中的 withOutputStream，还有 gradle 中的 withType，都是些啥玩意啊？</li>
<li>所以后来下决心先把 Groovy 学会，主要是把自己暴露在闭包里边。另外，Groovy 是一门语言，总得有 SDK 说明吧。写了几个例子，慢慢体会到 Groovy 的好处，也熟悉 Groovy 的语法了。</li>
<li>接着开始看 Gradle。Gradle 有几本书，我看过 Gradle in Action。说实话，看得非常痛苦。现在想起来，Gradle 其实比较简单，知道它的生命周期，知道它怎么解析脚本，知道它的 API，几乎很快就能干活。而 Gradle In Action 一上来就很细，而且没有从 API 角度介绍。说个很有趣的事情，书中有个类似下面的例子。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">task myTask  &lt;&lt;  &#123;</div><div class="line">   println &apos; I am myTask&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>书中说，如果代码没有加 &lt;&lt;，则这个任务在脚本 initialization（也就是你无论执行什么任务，这个任务都会被执行，I am myTask都会被输出）的时候执行，如果加了&lt;&lt;，则在 gradle myTask 后才执行。</p>
<p>换成现在我们理解的：</p>
<p>这和我们调用 task 这个函数的方式有关！如果没有 &lt;&lt;，则闭包在 task 函数返回前会执行，而如果加了 &lt;&lt;，则变成调用 myTask.doLast 添加一个 Action 了，自然它会等到 grdle myTask 的时候才会执行！</p>
<p><strong>API 说清楚了，如果你把 Gradle 当做编程框架来看，对于我们这些程序猿来说，写这几百行代码，那还算事嘛？？？</strong></p>
<p>完结~ 下一篇我们讲解项目实战 Gradle 编译那些事，敬请等候。。。</p>
<hr>
<p><strong>备注：Groovy 章节对应的代码在我本地，GitHub repo，嗯.. 先安全检查下再传上去吧，你懂的。。。</strong></p>
<h1 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h1><p>Blog</p>
<ul>
<li><a href="https://cn.udacity.com/course/gradle-for-android-and-java--ud867" target="_blank" rel="external">用 Gradle 构建 Android 和 Java by Google</a></li>
<li><a href="https://www.infoq.cn/article/android-in-depth-gradle/?utm_source=infoq&amp;utm_campaign=user_page&amp;utm_medium=link" target="_blank" rel="external">邓平凡 | 深入理解 Android（一）：Gradle 详解</a></li>
<li><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">Gradle DSL Version 6.0.1</a></li>
</ul>
<p>UDACITY</p>
<ul>
<li><a href="https://cn.udacity.com/course/gradle-for-android-and-java--ud867" target="_blank" rel="external">Udacity | 用 Gradle 构建 Android 和 Java</a></li>
</ul>
<p>API</p>
<ul>
<li><a href="https://www.imooc.com/article/44169" target="_blank" rel="external">Groovy核心类源码讲解(下)</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>流程图</title>
    <url>/2020/04/03/%E6%B5%81%E7%A8%8B%E5%9B%BE/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="一、什么是流程图"><a href="#一、什么是流程图" class="headerlink" title="一、什么是流程图"></a>一、什么是流程图</h2><p><strong>流程图 = 流程 + 图</strong></p>
<p>流程是一系列的逻辑关系（包含因果关系、时间先后、必要条件、输入输出）做需求前一定要先把这些逻辑关系理清楚，如果非要用一句话概括的话“流程就是在特定的情境下满足用户特定需要的总结”。</p>
<p>图就是将你头脑中的逻辑关系以图形化的形式呈现出来，具有图形化、可视化的特点，因为是图，你可以像你的版本迭代一样，当你的逻辑需要修改的时候拿出来迭代一下。</p>
<h2 id="二、为什么要画流程图"><a href="#二、为什么要画流程图" class="headerlink" title="二、为什么要画流程图"></a>二、为什么要画流程图</h2><h3 id="2-1、帮助梳理逻辑"><a href="#2-1、帮助梳理逻辑" class="headerlink" title="2.1、帮助梳理逻辑"></a>2.1、帮助梳理逻辑</h3><p>我们每个人想一个逻辑的时候，不一定能把这个逻辑的细枝末节都想到，如果我们贸然的画原型就有可能做许多无用功，这个时候画流程图可以帮助我们梳理清楚我们的逻辑。建议刚开始梳理逻辑的时候可以在纸上画画这种流程图，因为这样的好处是你可以快速的把你脑中的逻辑呈现在纸上，修改起来也方便，当你画好以后然后再用专业的工具画出来保存。</p>
<h3 id="2-2、便于宣讲和传播"><a href="#2-2、便于宣讲和传播" class="headerlink" title="2.2、便于宣讲和传播"></a>2.2、便于宣讲和传播</h3><p>产品经理需要开评审会和写PRD文档的，这个时候如果你有一张清晰的流程图，不仅便于你讲解，也便于技术理解，同时把你的流程图插入PRD文档中也方便传播，当技术忘记流程的时候，查看一下文档里的流程就知道流程是啥样了，不用反复来找你确认。</p>
<h3 id="2-3、优化迭代"><a href="#2-3、优化迭代" class="headerlink" title="2.3、优化迭代"></a>2.3、优化迭代</h3><p>对于拿到一个逻辑，我们不一定能考虑的那么周全，这个时候有一个清晰的流程图也方便做记录以及修改。</p>
<p>同时每个版本迭代的流程图可能会有相应的变化，通过对每个版本流程图的对比分析，可以知道流程优化在什么地方，产品优化了什么地方。</p>
<h2 id="三、流程图元素定义"><a href="#三、流程图元素定义" class="headerlink" title="三、流程图元素定义"></a>三、流程图元素定义</h2><p>流程图是符号化的图形语言，有自己的规范，菱形代表判断，距形代表具体的操作行为、开始和结束用圆角表示…</p>
<p><img src="https://image1.guazistatic.com/qn191103175155bdad63f119676a41d4d6432e8f39e3ba.jpg" alt="流程图元素定义"></p>
<h2 id="四、流程图分类"><a href="#四、流程图分类" class="headerlink" title="四、流程图分类"></a>四、流程图分类</h2><p>产品中设计的流程图主要有三种，业务流程图、任务流程图、页面流程图。</p>
<h3 id="4-1、业务流程图"><a href="#4-1、业务流程图" class="headerlink" title="4.1、业务流程图"></a>4.1、业务流程图</h3><p>业务流程图就是描述那些个体在什么条件下做了什么事情，他们之间有何关联。主要分三个方面：①涉及到哪些主体？②每个主体都有哪些任务？③各个主体之间怎么联系的？一般涉及到多个主体，每个主体之间有联系，比如p2p平台。</p>
<p><img src="https://image1.guazistatic.com/qn1911031752242c688d16a1c1f83bda33684a57acdc17.jpg" alt="p2p业务流程图"></p>
<p>这是p2p的业务流程图、涉及到借款人、平台、投资人、第三方支付四个主体，以及每个主题需要完成的任务、任务之间的联系和先后顺序。</p>
<h3 id="4-2、任务流程图"><a href="#4-2、任务流程图" class="headerlink" title="4.2、任务流程图"></a>4.2、任务流程图</h3><p>泳道图一般是从战略上分析整个业务流程，让你对公司所做的业务有个大概的了解，而任务流程图就是在你的产品操作上，用户通过什么样的操作来完成它的目标，比如你去银行ATM机器上取钱，你是如何一步步操作把钱取出来的，这里以p2p理财产品购买为例，来说明购买的任务流程图。</p>
<p><img src="https://image1.guazistatic.com/qn191103175300a90d608a39c4df15378664895d66abc4.jpg" alt="p2p理财-购买任务流程图"></p>
<p>画流程图的时候注意主要流程和异常流程，在这个例子中，主要流程就是购买流程、异常流程就是没有设置交易密码、用户忘记交易密码、以及超过重试次数这些流程，画流程图的时候先画主要的流程，然后再把异常额流程考虑上，查漏补缺，保证不遗漏，产品的逻辑漏洞多半是由于异常情况没有考虑清楚，画流程图可以有效的帮助你梳理逻辑。</p>
<h3 id="4-3、页面流程图"><a href="#4-3、页面流程图" class="headerlink" title="4.3、页面流程图"></a>4.3、页面流程图</h3><p>如果说业务流程图帮助你梳理战略，任务流程图帮助你梳理用户操作行为（主要给程序员看）、页面跳转流程在帮助你梳理各个页面之间的跳转关系（主要给UI和前端程序员看）这是一个逐步从整体到局部，从后端到前端的过程。</p>
<p>所有的产品都是由页面组成的，不论是APP、PC、H5都是由一个个页面组成的，页面流程图描述完成一个任务需要经过哪些步骤，你在画图的时候只需要清晰的表现出用户点击页面的什么地方，然后跳转到那个页面。主要由页面、行动点、连接线组成，下面以用户购买理财产品举例。</p>
<p><img src="https://image1.guazistatic.com/qn191103175330c3cb9ae6d9143e8c16115fb1893bdc9f.jpg" alt="用户购买理财产品-交互图"></p>
<p>页面流程一般只考虑正常的操作流程就行，对于异常的操作流程在正常流程的旁边画出，例如：上面的正常页面跳转是用户购买这个流程，异常页面跳转流程是在购买界面金额不足的时候点击去充值流程，这个在正常流程的旁边标示出来就好。</p>
<h2 id="五、如何绘制流程图"><a href="#五、如何绘制流程图" class="headerlink" title="五、如何绘制流程图"></a>五、如何绘制流程图</h2><p>上面说了需要绘制流程图，这里说说绘制流程图的思路。</p>
<h3 id="5-1、调查研究"><a href="#5-1、调查研究" class="headerlink" title="5.1、调查研究"></a>5.1、调查研究</h3><p>对于业务流程图，如果你不懂业务，可以让业务人员给你讲解；对于操作流程图你可以实地观察用户的操作，或者自己走一下业务流程以及使用竞品；至于页面流程图，只要你元素出来了，怎么跳转，这个难度应该不大。</p>
<h3 id="5-2、梳理提炼"><a href="#5-2、梳理提炼" class="headerlink" title="5.2、梳理提炼"></a>5.2、梳理提炼</h3><p>业务人员给我们讲解的流程，我们要梳理提炼出来，可以把主要的流程画出来，然后再向里面补进异常流程，我们可以先在纸上画画，这样速度比较快，根据业务员的讲解，然后再用专业的工具展现出来。一般流程图有三种结构：顺序结构、选择结构、循环结构</p>
<p><img src="https://image1.guazistatic.com/qn191103175357264de4fd3783beec419d4e3274d29641.jpg" alt="流程图三种结构"></p>
<h3 id="5-3、评估确认"><a href="#5-3、评估确认" class="headerlink" title="5.3、评估确认"></a>5.3、评估确认</h3><p>我们可以让精通业务和涉及到流程图的角色都参与到评估流程图里来，众人拾柴火焰高，其他人员说不定能把我们没有想到的流程提出来，产品经理要多和别人交流。</p>
<h3 id="5-4、维护更新"><a href="#5-4、维护更新" class="headerlink" title="5.4、维护更新"></a>5.4、维护更新</h3><p>我们的流程图需要不断的维护和更新，因为我们的流程有可能变更或者优化，流程图也需要定期维护和更新。比如以前你是绑卡和充值两个流程，你现在为了用户体验把他们整合到一起，直接绑卡充值，这个时候你的流程图就需要变更。</p>
<h2 id="六、绘制流程图的工具"><a href="#六、绘制流程图的工具" class="headerlink" title="六、绘制流程图的工具"></a>六、绘制流程图的工具</h2><p>“工欲善其事,必先利其器”,下面就为大家介绍几款常用流程图绘制工具。</p>
<h3 id="6-1、visio"><a href="#6-1、visio" class="headerlink" title="6.1、visio"></a>6.1、visio</h3><p>Visio是微软推出的一款流程图绘制工具，它有很多组件库，可以方便快捷的完成流程图、泳道图、结构图的绘制，但是不支持mac电脑（苦恼），其实我一直觉得它挺好用的，虽然画出来可能没有mac上用Omnigraffle画出来的美。</p>
<p><img src="https://image1.guazistatic.com/qn1911031754329d63cc464cbafadacb2378b20aeefd3f.jpg" alt="visio"></p>
<h3 id="6-2、Omnigraffle（Mac）"><a href="#6-2、Omnigraffle（Mac）" class="headerlink" title="6.2、Omnigraffle（Mac）"></a>6.2、Omnigraffle（Mac）</h3><p>Mac下没有Visio很多人就用这个，这个一般流程图都能绘制，但是效率感觉没有Visio高，优点就是画出来的图形比较美，同时支持外部插件，缺点就是没有比较好的泳道流程图插件，画起泳道图来不是你太方便，需要下载的画可以去马云家买一个，省时省力，还可更新。</p>
<p><img src="https://image1.guazistatic.com/qn1911031754320fd3b3c9693bc9fee98c3d8bc245cffe.jpg" alt="omnigraffle"></p>
<h3 id="6-3、ProcessOn-在线"><a href="#6-3、ProcessOn-在线" class="headerlink" title="6.3、ProcessOn 在线"></a>6.3、ProcessOn 在线</h3><p>是一款网页版的在线作图工具，优点是无需下载安装、破解这些破事，同时支持在线协作，可以多人同时对一个文件协作编辑，而且上手比较容易，它提供很多流程图模版，可以方便的画出流程图、思维导图、原型图、UML图，缺点就是在绘制泳道图需要增加泳道的时候，只能在最后一列加入，不能在中间加入这一点有点麻烦，还有要吐槽的就是由于是在线的，有时候导出图片，导出来的并不太好，流程图画的大的时候也无法截图。</p>
<p><img src="https://image1.guazistatic.com/qn191103175432140801eddc452cfde66073b5bcc8574e.jpg" alt="ProcessOn"></p>
<h3 id="6-4、Axure"><a href="#6-4、Axure" class="headerlink" title="6.4、Axure"></a>6.4、Axure</h3><p>axure画原型挺好用的，画人物流程图的时候也可以用，但是要画泳道图、UML图的时候，没有对应的模版，需要自己画，效率不高，如果你觉得画原型，制作文档都在Axure里，不想来回切换软件的画，可以在里面自己制作一个组件，下次直接调用。</p>
<p><img src="https://image1.guazistatic.com/qn19110317543292b4ad57b0c828a2a257399c73fc7eca.jpg" alt="Axure"></p>
<h2 id="七、实际项目"><a href="#七、实际项目" class="headerlink" title="七、实际项目"></a>七、实际项目</h2><ul>
<li><a href="https://www.processon.com/diagraming/5c77967fe4b0993b7adf1e71" target="_blank" rel="external">向日葵-微信聊天项目-流程图</a></li>
<li><a href="http://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="external">彻底弄懂HTTP缓存机制及原理</a></li>
</ul>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>总结：在用xmind梳理完成你的产品架构和功能列表，然后用流程图梳理一下你头脑中的逻辑，最后才是画产品的原型，这是一个从整体到局部，从巨像到抽象的过程，只有这样才能达到事半功倍的效果。</p>
<h2 id="九、参考"><a href="#九、参考" class="headerlink" title="九、参考"></a>九、参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25020707" target="_blank" rel="external">如何绘制产品流程图</a></li>
<li><a href="https://blog.csdn.net/u010707039/article/details/85211658" target="_blank" rel="external">通过流程图来分析Android事件分发</a></li>
<li><a href="https://www.processon.com/view/5938ca45e4b036140a0ef61f?fromnew=1" target="_blank" rel="external">ProcessOn-决策流程图</a></li>
<li><a href="https://www.processon.com/view/595c8901e4b068b0a2418dff?fromnew=1" target="_blank" rel="external">ProcessOn-知识云微服务架构</a></li>
<li><a href="https://www.processon.com/view/5b507876e4b053a09c0cd343?fromnew=1" target="_blank" rel="external">ProcessOn-聚合支付流程</a></li>
<li><a href="https://www.processon.com/view/5a6ef27ae4b076434229ae4a?fromnew=1" target="_blank" rel="external">ProcessOn-项目管理流程</a></li>
<li><a href="https://www.processon.com/view/5ca9ef11e4b06765f0878463?fromnew=1" target="_blank" rel="external">ProcessOn-医院在线预约门诊</a></li>
<li><a href="https://www.processon.com/view/5c7f190ae4b0d1a5b0f2f2ce?fromnew=1" target="_blank" rel="external">ProcessOn-零基础的数据分析思路</a></li>
<li><a href="https://www.processon.com/view/5bd139b5e4b0fe81b66f3a92?fromnew=1" target="_blank" rel="external">ProcessOn-后端架构</a></li>
<li><a href="https://www.processon.com/view/5aa8ef88e4b06bbdabb1fa6d?fromnew=1" target="_blank" rel="external">ProcessOn-技术架构</a></li>
<li><a href="https://www.processon.com/view/5c077474e4b0615cb4da62fe?fromnew=1" target="_blank" rel="external">ProcessOn-美团自配送流程</a></li>
<li><a href="https://www.processon.com/view/59b63effe4b00e6de9151ce6?fromnew=1" target="_blank" rel="external">ProcessOn-电商平台前台后台流程梳理</a></li>
<li><a href="https://www.processon.com/view/5ca73d72e4b0cfb73428e5f9?fromnew=1" target="_blank" rel="external">ProcessOn-线性表删除元素</a></li>
<li><a href="https://www.processon.com/view/596442cde4b0a77c5aec74d9?fromnew=1" target="_blank" rel="external">ProcessOn-电商系统架构</a></li>
<li><a href="https://www.processon.com/view/5aa285b0e4b0fb5a6beecfb9?fromnew=1" target="_blank" rel="external">ProcessOn-推荐系统</a></li>
<li><a href="https://www.processon.com/view/5938c757e4b036140a0ef5ef?fromnew=1" target="_blank" rel="external">ProcessOn-系统架构设计</a></li>
<li><a href="https://www.processon.com/view/5ad1b686e4b0b74a6dd628f7?fromnew=1" target="_blank" rel="external">ProcessOn-抖音短视频迭代记录</a></li>
<li><a href="https://www.processon.com/view/5ad012f8e4b0f5fa24d1e06a?fromnew=1" target="_blank" rel="external">ProcessOn-人脸识别后端服务架构</a></li>
<li><a href="https://www.processon.com/view/5ca469dde4b029f6dae5b026?fromnew=1" target="_blank" rel="external">ProcessOn-公司场景（设备）接入协作流程</a></li>
<li><a href="https://www.processon.com/view/5c753233e4b07fada4f4f4c0?fromnew=1" target="_blank" rel="external">ProcessOn-拼团模式</a></li>
<li><a href="https://www.processon.com/view/5c7896f7e4b00bcc4f756fb4?fromnew=1" target="_blank" rel="external">ProcessOn-人拉人设计</a></li>
<li><a href="https://www.processon.com/view/5bd56149e4b09d44956ac41a?fromnew=1" target="_blank" rel="external">ProcessOn-大数据平台架构</a></li>
<li><a href="https://www.processon.com/view/59ee95e3e4b08b9e91801845?fromnew=1" target="_blank" rel="external">ProcessOn-ERP整体运作流程及单据职责</a></li>
<li><a href="https://www.processon.com/view/53d0622b0cf27d6e7f3f396b?fromnew=1" target="_blank" rel="external">ProcessOn-IT软件运维-数据库脚本执行流程</a></li>
<li><a href="https://www.processon.com/view/5ab84809e4b02cee4cec102d?fromnew=1" target="_blank" rel="external">ProcessOn-系统故障流程图</a></li>
<li><a href="https://www.processon.com/view/5a9f867fe4b0f7be027ae13c?fromnew=1" target="_blank" rel="external">ProcessOn-基于区块链的信贷云技术架构</a></li>
</ul>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin入门与使用</title>
    <url>/2020/04/03/Kotlin%E5%85%A5%E9%97%A8%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
]]></content>
  </entry>
  <entry>
    <title>Android 多渠道打包实践</title>
    <url>/2020/04/03/Android-%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>向日葵 APP 主版本已经越来越庞大，包含了很多业务线功能，每次发版内容复杂，在一些特殊场景下，拉取单独地分支开发，会额外增加维护成本，影响正常的工程，代码正确性不敢保证。一个鲜明的例子是：我们需要向外提供一个轻量级登录模块功能，也就是 Android AAR 代码包，如果单独创建一个 library 开发会特别麻烦，维护库的压力会很大。</p>
<p>在这样的前提下，我们引入 Android 工程共主线差异化打包，共主线的核心其实是利用 productFlavors block 语法，差异化开发，共用主线，多渠道打包。</p>
<p>一句话总结：productFlavors 可以差异化开发，共用主线，多渠道打包</p>
<h2 id="差异化构建"><a href="#差异化构建" class="headerlink" title="差异化构建"></a>差异化构建</h2><p>在 Library 库的 build.gradle 文件里配置不同的 productFlavors 实现同一个库下差异化版本构建，实现两个不同的产品。例如，向日库登录模块实现2个迭代版本，分别为 full 和 lite，其中 full 为全量代码，lite 为轻量版代码向外提供 aar，配置代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><div class="line">android &#123;</div><div class="line">    publishNonDefault <span class="literal">true</span></div><div class="line">    flavorDimensions <span class="string">"dimension"</span></div><div class="line">    productFlavors &#123;</div><div class="line">        full &#123;</div><div class="line">            dimension <span class="string">"dimension"</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        lite &#123;</div><div class="line">            dimension <span class="string">"dimension"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><p>gradle 中有一个 source set 概念，不同产品可以设置不同的 source set，通常 src/main 目录是 IDE 自动帮我们创建的文件夹,因此我们可以在 src 目录下创建 full/lite 这样的目录,目录名需要和 productFlavors 中定义的产品名对应 。<br>在 src/main 目录下新建两个同级目录 full 与 lite，目录的名称要与 productFlavors 中设定的工程名保持一致。如下所示：</p>
<p><img src="https://image1.guazistatic.com/qn191031162602f5518be1df7755c7b227b6089274af5a.jpg" alt="biz-shell模块多产品构建"></p>
<p>这样 src/full/java 文件内可以放不同的代码，src/full/res 文件夹内可以放不同的资源文件，同时也可以定义不同的 AndroidManifest 文件，比如申请不同的权限之类。其中，对于 full 和 lite 来说，main 目录下的文件和资源是共享的，而 full 与 lite 下的文件和资源是对应的 product 特有的，在这里可以做一些差异化的编码，达到共主线，差异化逻辑的效果。</p>
<h2 id="多渠道打包"><a href="#多渠道打包" class="headerlink" title="多渠道打包"></a>多渠道打包</h2><p>assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type(Debug/Release) + Product Flavor，其中 assembleDebug 可以简写为 aDebug 使用，为什么是aDebug，a就是assemble，至于assemble就是gradle的强大之处了。</p>
<p>assemble 命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./gradlew assembleDebug </div><div class="line">编译并生成 Debug 包，包含 productFlavors 下所有定义的产品或渠道包</div><div class="line">./gradlew assembleRelease </div><div class="line">编译并生成 Release 包,包含 productFlavors 下所有定义的产品或渠道包</div><div class="line">./gradlew assembleProductARelease </div><div class="line">编译并生成 Release 包,包含 ProductA 下所有定义的产品或渠道包</div><div class="line">./gradlew assembleProductADebug</div><div class="line"> 编译并生成 Debug 包,包含 ProductA 下所有定义的产品或渠道包</div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/33722674" target="_blank" rel="external">使用gradle的productFlavors实现Android项目多渠道打包</a></li>
<li><a href="https://juejin.im/entry/5a586bfaf265da3e2c3808c5" target="_blank" rel="external">Gradle中productFlavors使用详解</a></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Gradle项目编译优化</title>
    <url>/2020/04/03/Gradle%E9%A1%B9%E7%9B%AE%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h1 id="一、当-Gradle-遇上我们的项目时"><a href="#一、当-Gradle-遇上我们的项目时" class="headerlink" title="一、当 Gradle 遇上我们的项目时"></a>一、当 Gradle 遇上我们的项目时</h1><p>那些我们遇到的问题们：</p>
<ul>
<li>解释下什么是 Gradle ?</li>
<li>Gradle 原理是是样子的？</li>
<li>那些错误该怎么处理？</li>
<li>怎么解决编译慢的问题？</li>
</ul>
<h1 id="二、基本内容"><a href="#二、基本内容" class="headerlink" title="二、基本内容"></a>二、基本内容</h1><h2 id="2-1-基本知识"><a href="#2-1-基本知识" class="headerlink" title="2.1 基本知识"></a>2.1 基本知识</h2><ol>
<li>这三个是不一样滴</li>
</ol>
<p>gradle &amp; gradlew &amp; android plugin gradlew </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Makefile - C/C++ 组织动态链接库和文件</div><div class="line"># Java 简单点</div><div class="line">javac HelloWorld.java</div><div class="line">java HelloWorld</div></pre></td></tr></table></figure>
<ul>
<li>Eclipse-Ant 编译，没准备让人看懂</li>
<li>Maven-XML，编译 XML 大几千行，像 Spring 项目，基本没法编辑</li>
<li>Gradle-Groovy 像我们 build.gradle 文件，很多 DSL，符合程序员的风格</li>
</ul>
<ol>
<li>Gradle 讲解</li>
</ol>
<ul>
<li>configuration -&gt; Task module A -&gt; compile A -&gt; Jar </li>
</ul>
<p><img desc="gradle-执行流程" src="http://wanghaoxun.com/img/Gradle 执行流程.jpg" width="60%"></p>
<ul>
<li>Task 执行</li>
</ul>
<p>Input -&gt; Task Java Compile -&gt; .class 文件</p>
<p>TODO2：gradle-task执行.jpg</p>
<ul>
<li>AGP-Android Gradle Plugin</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">classpath &apos;com.android.tools.build:gradle:3.5.0&apos;</div></pre></td></tr></table></figure>
<p>AGP 代码也是个 jar包，用了就会生成很多 Task</p>
<p>TODO3：gradle-agp-souce.jpg</p>
<p>Android 和 Java 不一样，它有 Resource 文件，要生成 resource id-R.id 文件，还有 Manifest，AIDL 等等，AGP 添加了很多 Task，最后生成 module aar 包。AGP 就是帮你在 Android 中把包打出来。</p>
<p>TODO4：gradle-agp-task.jpg</p>
<ol>
<li>gradle 和 gradlew 不是一个东西！！！</li>
</ol>
<p>位置不一样，gradlew gradle wrapper 不是一个东西</p>
<p>TODO5：gradle-gradlew.jpg</p>
<ol>
<li>在 Android Studio 里点 RUN AS 将注入 init-script，运行结果和 shell 里会有不同混合执行会很慢！！！</li>
</ol>
<p>我们可以在命令行或者 AS 里点击运行工程，不建议同时使用。点击 RUN AS 会通过 init-script 往里面注入很多复杂的 debug，性能相关，打广告等等。所以，在 AS 中可能快可能慢。</p>
<ol>
<li>sdk list gradle </li>
</ol>
<p>最新 gradle 5.6.1，我们现在用的是 3.4.1。gradle 每个版本性能最高提高 10%，可能吗？？？</p>
<h2 id="2-2-项目现状"><a href="#2-2-项目现状" class="headerlink" title="2.2 项目现状"></a>2.2 项目现状</h2><ol>
<li>why so so so slowwwwww?</li>
</ol>
<p>编译失败了，clean 完了，在运行失败了，已经运行了 28 分钟左右。</p>
<ul>
<li>模块太多</li>
<li>资源太多</li>
<li>什么都多！！！</li>
<li>APT 太慢</li>
<li><p>AOP 太慢</p>
</li>
<li><p>2557 tasks executed in 89 projects in 9m 56.538s</p>
</li>
</ul>
<p>项目代码 13多万行，编译模块几十个，APT（ButterKnife，EventBus，Room等等），AOP 也有几个。</p>
<ol>
<li>Official solution </li>
</ol>
<p>官方更新了这么多版本，0.x.x -&gt; 5.6.x 版本，应该提升很多吧，实际呢？呵呵，下面列举一些有用的：</p>
<ol>
<li>Parallel 并行</li>
<li>Compiler daemon 不要每次创建新进程，使用后台进程</li>
<li>Big RAM(memory)!!! 更大的内存</li>
<li>Build Cache 增量编译 cache</li>
<li>incremental build 编译走增量</li>
<li>Compile avoidance 很多编译不用走全量</li>
<li>ABI </li>
</ol>
<ul>
<li>Parallel-Gradle Task 并行执行</li>
</ul>
<p>格式化输出 task 运行过程，可以看到有 8 条线也就是 8 个线程同时运行。电脑 CPU 有 4核，超线程到 8 核，gradle 把所有 CPU 沾满之后，就会变得很卡。自己可以配置调节少些，电脑舒服点。</p>
<p>TODO5：gradle-task-parallel.jpg</p>
<ul>
<li>Incremental Build 增量编译</li>
</ul>
<p>TODO2：gradle-task执行.jpg</p>
<p>只编译 changed 的文件，增量编译。</p>
<p>TODO6：gradle-task-incremental-build.jpg</p>
<ul>
<li>ABI 级别-implement </li>
</ul>
<p>3.x 版本之后升级成了 implement 来隔离模块，compile 时，修改底层模块，会造成依赖链上的模块都编译，十几分钟又过去了。。。compile 需要 9m，implement 只需要 5m。</p>
<p>TODO7：gradle-abi.jpg</p>
<p><strong>我们的增量编译 == 全量</strong></p>
<p>猜猜有多少生效？？？</p>
<ul>
<li>Parallel</li>
<li>Compiler daemon</li>
</ul>
<p>也就这两个可以留着！what？听我仔细道来：</p>
<p>甚至有时候编译时，会执行 GC。：）</p>
<h1 id="三、Our-Problem–rerun-tasks"><a href="#三、Our-Problem–rerun-tasks" class="headerlink" title="三、Our Problem–rerun-tasks"></a>三、Our Problem–rerun-tasks</h1><p><strong>运行项目 20多分钟，最后失败了？一脸懵逼。。。</strong></p>
<h2 id="3-1-gradle-的问题（APT、ABI、Version）"><a href="#3-1-gradle-的问题（APT、ABI、Version）" class="headerlink" title="3.1 gradle 的问题（APT、ABI、Version）"></a>3.1 gradle 的问题（APT、ABI、Version）</h2><ul>
<li>如果想知道 compile 执行过程，可以执行如下 command:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 会把 gradle 执行结果上传到服务器，帮助我们更加精细化的分析编译中遇到的问题</div><div class="line">./gradlew run --scan</div></pre></td></tr></table></figure>
<p>TODO8：gradle-task-run-scan.jpg</p>
<ul>
<li>改一行底层 core 模块，一个八竿子打不着的模块产生了编译？</li>
</ul>
<h3 id="3-1-1-ABI"><a href="#3-1-1-ABI" class="headerlink" title="3.1.1 ABI"></a>3.1.1 ABI</h3><p>正常 ABI 编译过程</p>
<p>TODO9：gradle-abi-normal.jpg </p>
<p>失效 ABI</p>
<p>Core -&gt; module A -&gt; module B</p>
<p>只改了 core，造成了 module A 中使用 APT 组件（EventBus等）产生了编译，再造成了 module B 产生了编译。</p>
<p>TODO10：gradle-abi-invalid.jpg </p>
<h3 id="3-1-2-APT"><a href="#3-1-2-APT" class="headerlink" title="3.1.2 APT"></a>3.1.2 APT</h3><ul>
<li>APT 产生了问题</li>
</ul>
<p>Java 语法很少，为什么从 96年活到现在，就是因为可以动态生成代码，扩充很多功能。</p>
<p>看到下面这种图，你可能会想到，如果我们 APT 生成的文件每次都不一样，那么整个编译就毁了。</p>
<p>TODO11：gradle-task-apt.jpg </p>
<p><strong>防止 APT 生成随机文件</strong></p>
<p>TODO12：gradle-apt-fix.jpg </p>
<p>自己写的 APT 组件可以修复下，EventBus 就没法修复了。解决：简单粗暴点，在 debug 环境下把 EventBus 关闭了，哈哈。</p>
<ul>
<li>ABI 好了，增量编译又失效了？</li>
</ul>
<p>apt 修复好了，但是和 core 模块相关的，增量编译时会产生一次全量编译。</p>
<p>TODO13：gradle-apt-processor-path.jpg</p>
<p>要使用 apt，需要告诉 gradle apt 文件在哪里？扫描 apt，在扫描文件看有没有变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">javaCompileOptions &#123;</div><div class="line">    annotationProcessorOptions &#123;</div><div class="line">        // compile 项目模块的源文件</div><div class="line">        includeCompileClasspath = true</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 includeCompileClasspath 为 true，当你修改模块一行代码，会造成 apt 重新全量编译，整个模块全量编译，天呐！</p>
<p>TODO14：gradle-apt-processor-path-fix.jpg</p>
<ul>
<li>APT 增量编译</li>
</ul>
<p>gradle 5.x 之后 APT 支持增量编译，官方文档：<a href="https://blog.gradle.org/incremental-compiler-avoidance" target="_blank" rel="external">https://blog.gradle.org/incremental-compiler-avoidance</a></p>
<p>TODO15：gradle-apt-increment.jpg</p>
<ul>
<li>RenderScript Src 设置错误导致 core 重复编译</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">renderscript.srcDirs = [&apos;src&apos;]</div></pre></td></tr></table></figure>
<p>renderscript 编译造成了 resource 重新编译，引起了 R 文件重新编译，于是我们项目又开始了重新编译，很可怕！可以算工伤。</p>
<h3 id="3-1-3-AGP-amp-Gradle-version"><a href="#3-1-3-AGP-amp-Gradle-version" class="headerlink" title="3.1.3 AGP &amp; Gradle version"></a>3.1.3 AGP &amp; Gradle version</h3><ul>
<li>升级 AGP 与 Gradle </li>
</ul>
<p>Gradle 和 AGP 不一样，Gradle 支持增量编译，AGP 不一定支持增量编译，只能同时升级。</p>
<p>TODO15：gradle-vs-agp.jpg</p>
<p><strong>以上 gradle 修改后，该一行 core 代码，编译时间从 9:00 -&gt; 5:00 </strong></p>
<h2 id="3-2-AGP-Transform-优化"><a href="#3-2-AGP-Transform-优化" class="headerlink" title="3.2 AGP-Transform 优化"></a>3.2 AGP-Transform 优化</h2><p>优化完 gradle，在看来 AGP，Google 坑挺多，如图，dexBuider &amp; dexMerger 2个任务会卡很久</p>
<p>TODO16：gradle-apg-transform.jpg</p>
<h3 id="3-2-1-Transform-流程"><a href="#3-2-1-Transform-流程" class="headerlink" title="3.2.1 Transform 流程"></a>3.2.1 Transform 流程</h3><p>TODO17: gradle-agp-transform-flow.jpg</p>
<p>之前加一点功能，需要 hook gradle task，加一些任务进去，hook debugCompileClass,aptClass 等，特别恶心，版本兼容性也不好。所以开放了 transform API 来解决，</p>
<ul>
<li>Android Transform API</li>
</ul>
<p>看到 transform API，甚至怀疑都是照着 task API 抄的！</p>
<p>TODO18: gradle-apg-transform-api.jpg</p>
<ul>
<li>DexArchive &amp; DexBuilder &amp; DexMerger</li>
</ul>
<p>TODO19: gradle-apg-transform-dex.jpg</p>
<p>分为 DirInput 和 JarInput 2 种情况，顶层项目 CRMApp （apply andorid plugin）生成 dir，其它所有 module 都会变成 jar 包，传进去 transform 里。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">* DirInput</div><div class="line">* Jar -&gt; 解压 -&gt; class -&gt; D8/DX(脱糖) -&gt; class -&gt; 合并 -&gt; dex</div><div class="line"></div><div class="line">java 1.8 ，Android 真正可以执行 1.6，需要进行处理。</div></pre></td></tr></table></figure>
<p>如果在 module 中改了一行代码，造成了 class 修改，transform 只知道 jar 包变了，不知道哪个 class 变了，只能解压，编译以下，合并到一个 dex 中，就这么可怕！</p>
<h3 id="3-2-2-Transform-增量优化"><a href="#3-2-2-Transform-增量优化" class="headerlink" title="3.2.2 Transform 增量优化"></a>3.2.2 Transform 增量优化</h3><ul>
<li>Transform-Incremental-Build</li>
</ul>
<ol>
<li>DexBuilder</li>
</ol>
<p>TODO20: gradle-transform-incremental-build.jpg</p>
<p>Jar To Dir: 先把 Jar 解压了，变成 Dir，在塞进 Transform。</p>
<p>问题：怎么知道哪个 class 增量编译下？</p>
<p>只能解压出来，计算下 diff，看哪些变化了，哪些被删除了。我们需要算每个文件的 md5 值，要哪个是加的哪个是减的哪个是删的，很慢！</p>
<p>所有的 task 利用线程池并行执行，比如解压计算 CRC32-类似 MD5，好多都是同步执行，这里利用协程并行解压 Diff</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">所有 Module 全量解压 20s -&gt; 2s</div><div class="line">Core 增量解压 2s -&gt; 600ms</div></pre></td></tr></table></figure>
<p>结果：DexBuilder: 30s -&gt; 5s</p>
<ol>
<li>DexMerger</li>
</ol>
<p>暂时没有好的办法 :(</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. API 21 以上，每个 JarInput 作为一个dex，每个Dir 作为一个Dex</div><div class="line">2. 21、22 有 100 个 dex 的限制</div><div class="line">3. 设置 minSdk 23 能加快 10s</div></pre></td></tr></table></figure>
<p>5.0,6.0 有个 bug，如果 dex 超过 100个的话，会把所有 dex 合起来再打个大的 dex，打到一起很慢~</p>
<p>可以升级 minSdk 23 来解决，但是升级后，打出来的 dex 数量超多，2000 多个，安装很慢~</p>
<h2 id="3-3-Avoid-Compile"><a href="#3-3-Avoid-Compile" class="headerlink" title="3.3 Avoid Compile"></a>3.3 Avoid Compile</h2><p>APT 加速后，9m -&gt; 5m -&gt; 3:30m 还是太慢</p>
<ul>
<li>思考一个问题：Core 模块修改了，关 module A 啥事？</li>
</ul>
<p>更多是一层校验，其实我们写代码都很规范了，修改 Core 时都会 find usage 以下，所以，基本不会出现找不到函数的情况。</p>
<p>TODO21: gradle-abi-aggressive.jpg</p>
<p>那么依赖 core 的就先别编译了，激进一点的做法，hook 所有task 做处理，同样算下所有 Input 文件的 Diff，当发现没有变化时， 就直接跳过去！目前谨慎的跳过了 compile 编译 task，annotation 这个毒瘤，</p>
<p>TODO22: gradle-abi-avoid-compile.jpg</p>
<ul>
<li>AnnotationProcessor 分离</li>
</ul>
<p>TODO23：gradle-apt-seperate.jpg</p>
<p>目前关联 Core 的模块不用编译了，但是 Core 里面使用了 APT 还是很慢。</p>
<p>假如 Core 模块是纯 Java 代码，不是 KAPT，APT 和 Compile 都是由 JavacCompile Task 执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Google 提供的 API，但有个风险，会造成不拷贝资源文件</div><div class="line">android.enableSeparateAnnotationProcessing=true</div></pre></td></tr></table></figure>
<p>经常造成 Singleton.getxxx，找不到资源的问题。</p>
<p>修复分离后没有 copy res</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">## 3.4 我们还做了很多</div><div class="line"></div><div class="line">1. 增强 InvokerPlugin，修复 Class 重复或 Jar 包找不到</div><div class="line"></div><div class="line">解决 duplicate class 问题，虽然你可以快速编译，但是来个这个幺蛾子错误，又得重新编译，10m 又过去了。省的时间又还给你们了。</div><div class="line"></div><div class="line">2. 兼容处理 AS 和 Shell混编，不需要频繁 clean</div><div class="line">3. AnnotationWrap 分离，减少 APT 扫描耗时</div><div class="line">4. 等等等</div></pre></td></tr></table></figure>
<h2 id="3-4-我们还能做什么"><a href="#3-4-我们还能做什么" class="headerlink" title="3.4 我们还能做什么"></a>3.4 我们还能做什么</h2><ol>
<li>AS 3.5 apply change &amp; InstantRun</li>
<li>类似 Freeline class 和 res 增量</li>
<li>Core 分离</li>
</ol>
<ul>
<li>AS 3.5 删除了 InstantRun（插件化都在超 InstantRun 代码），变成了 apply change</li>
<li><p>Freeline 虽然可以增量，但是是个危险的操作，Android 每个版本都在改，gradle 也再改，AGP 也再改，各个手机厂商也再改，所以 BUG 特别多，所以你会发现市面上所有的编译插件项目都已经不再维护了。Android 新出的 jetpack 都不支持。</p>
</li>
<li><p>TODO24: gradle-apt-seperate.jpg</p>
</li>
<li>Core 中心节点依赖分离</li>
</ul>
<h3 id="3-4-1-开发一套支持动态配置快速编译方案"><a href="#3-4-1-开发一套支持动态配置快速编译方案" class="headerlink" title="3.4.1 开发一套支持动态配置快速编译方案"></a>3.4.1 开发一套支持动态配置快速编译方案</h3><p><strong>如何开启</strong></p>
<p>cp local_config.json.sample local_config.json</p>
<p>json 配置文件</p>
<p>TODO25: gradle-polish-setting.jpg</p>
<h1 id="四、还有很长的路要走。。。"><a href="#四、还有很长的路要走。。。" class="headerlink" title="四、还有很长的路要走。。。"></a>四、还有很长的路要走。。。</h1><p>。。。</p>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>断点调试 APT 和 Gradle Plugin</title>
    <url>/2020/04/03/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95-APT-%E5%92%8C-Gradle-Plugin/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文会讲解如何在 IDE（AS、Intellij）下 debug 断点调试注解处理器 APT(Annotation Processing Tool) 和 gradle plugin，帮你摆脱只能打印日志调试的窘境。</p>
<h2 id="调试步骤"><a href="#调试步骤" class="headerlink" title="调试步骤"></a>调试步骤</h2><ol>
<li>设置 Remote configuration</li>
</ol>
<ul>
<li>打开 Edit Configurations，</li>
</ul>
<p><img src="https://image1.guazistatic.com/qn1911282107012828065451f541cd5512d0dfd9bf8bf8.jpg" alt="toolbar-edit configurations"></p>
<ul>
<li>点击左上角 + 号，创建一个 Remote configuration，上面名字随便写，我写了 debug，port 端口设置为 5005，点击 ok 即可。</li>
</ul>
<p><img desc="设置界面" src="https://image1.guazistatic.com/qn191128210752b85aa9396306c8838e02e502e92c7fbe.jpg" width="80%"></p>
<ol>
<li>在 IDE Terminal 下，输入如下命令：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./gradlew clean :moduleName:assembleDebug -Dorg.gradle.debug=true --no-daemon</div></pre></td></tr></table></figure>
<p>之后这个进程就会一直等待，知道我们 attach 我们的调试进程进来。执行命令后如图：</p>
<p><img desc="执行等待命令" src="https://image1.guazistatic.com/qn1911282059391cf902285a7c7a8fc3ef15159358051c.jpg" width="80%"></p>
<ol>
<li>下断点</li>
</ol>
<p>这一步需要你去具体代码里打上断点，比如：android apt 去具体 abstractProcessor 处理器类打断点。</p>
<ol>
<li>启动远程调试器 </li>
</ol>
<ul>
<li>点击 debug 按钮连接上远程调试器进行调试</li>
</ul>
<p><img src="https://image1.guazistatic.com/qn191128212058c8e88a495726ac17909467fb58da15b9.jpg" alt="debug attach"></p>
<ul>
<li>可以看到 connected to target VM 等信息输出就表示已连接到了远程服务器，之后就是正常的调试了</li>
</ul>
<p><img desc="已连接到了远程服务器" src="https://image1.guazistatic.com/qn19112821222494af55a04963cca7187c8c9e5c659103.jpg" width="80%"></p>
<ul>
<li>连接上远程服务器之后，可以发现我们刚刚运行的命令已经开始执行了，这时候静代码执行到我们断点处</li>
</ul>
<p><img desc="远程代码执行" src="https://image1.guazistatic.com/qn191128212554777807d61da6abaa9a2a0ede3c077daf.jpg" width="80%"></p>
<p>最后附上一张调试的图片：</p>
<p><img desc="断点调试情景图" src="https://image1.guazistatic.com/qn1911282129395953b4742da1182a129b4e2f00cdb5aa.jpg" width="80%"></p>
<h2 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h2><ul>
<li>Android APT 死活不能自动生成？</li>
</ul>
<p>由于 Android Gradle 构建版本问题引起，之前设置的是 gradle 版本 5.1.1 + android gradle 3.4.1，修改成 4.4 + 3.1.4 解决。建议 3.3.2 + 4.10.1 以下都可以。具体可以参考<a href="https://blog.csdn.net/allenli0413/article/details/90602402" target="_blank" rel="external">这篇博客</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>调试步骤其实很简单，分如下两步即可：</p>
<ul>
<li>新建 remote target</li>
<li>在命令行输入执行 <code>./gradlew --no-daemon -Dorg.gradle.debug=true :moduleName:assembleDebug</code></li>
<li>之后选择刚刚创建的 remote target，然后点击调试按钮即可</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.jianshu.com/p/cc369dca20d1" target="_blank" rel="external">调试Annotation Processor编译时注解器</a></li>
<li><a href="https://fucknmb.com/2017/07/05/%E5%8F%88%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E9%A1%B9%E6%96%B0%E6%8A%80%E8%83%BD-%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95Gradle%E6%8F%92%E4%BB%B6/" target="_blank" rel="external">又掌握了一项新技能 - 断点调试 Gradle 插件</a></li>
<li><a href="https://fsilence.github.io/2017/04/11/gradle-debug/" target="_blank" rel="external">gradle调试断点</a></li>
<li><a href="https://blog.csdn.net/allenli0413/article/details/90602402" target="_blank" rel="external">Android APT不能自动生成文件</a></li>
</ul>
]]></content>
      <categories>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>个人简历</title>
    <url>/2020/03/15/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h1 id="雷志辉"><a href="#雷志辉" class="headerlink" title="雷志辉"></a><strong>雷志辉</strong></h1><ul>
<li>男/1992-03-15</li>
<li>本科/中北大学/软件工程</li>
<li>工作年限：5年</li>
<li>山西省/吕梁市/孝义市</li>
<li>技术博客：<a href="http://lzhblog.site/" target="_blank" rel="external">http://lzhblog.site/</a></li>
<li>Github：<a href="https://github.com/qq451682583" target="_blank" rel="external">https://github.com/qq451682583</a></li>
<li>期望职位：Android高级程序员</li>
<li>期望城市：北京<h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a><strong>联系方式</strong></h1></li>
<li>WeChat：18235139300     <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- Email：hy04150829gmail.com</div><div class="line">- Phone: 17610769559</div><div class="line"># **个人优势**</div><div class="line">- 5年Android开发经验，完成多款App的开发到上线</div><div class="line">- 丰富的架构设计和SDK开发能力</div><div class="line">- 丰富的卡顿优化/内存优化/APK大小优化相关经验</div><div class="line">- 熟悉的代码设计原则和常见设计模式设计和实现</div><div class="line">- 熟悉 Android Framework 源码,四大组件/消息传递/事件分发/View绘制/应用启动流程/进程间通信等相关知识</div><div class="line">- 熟悉常见开源框架 Glide/Arouter/Okhttp/EventBus/Rxjava 的原理和使用</div><div class="line">- 熟悉Android动画和各大UI组件，以及JectPack组件开发</div><div class="line">- 熟悉 Gradle 构建工具/gradle plugin 开发</div><div class="line">- 熟悉 APT/AOP/Transform 相关原理及开发</div><div class="line">- 熟悉组件化，插件化，热修复的原理和实践</div><div class="line">- 熟悉android ndk开发以及基本数据结构和算法</div><div class="line">- 熟悉Java/Kotlin/Dart/Groovy，并发编程，多线程开发等</div><div class="line">- 熟悉Http/Https/Tcp/Socket网络协议</div><div class="line">- 熟练掌握Git版本控制协作开发</div><div class="line">- 热爱技术，自学能力强</div><div class="line"># **工作经历**</div><div class="line">&lt;style&gt;</div><div class="line">table th:first-of-type &#123;</div><div class="line">	width: 80px;</div><div class="line">&#125;</div><div class="line">table th:nth-of-type(2) &#123;</div><div class="line">	width: 80px;</div><div class="line">&#125;</div><div class="line">table th:nth-of-type(3) &#123;</div><div class="line">	width: 80px;</div><div class="line">&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">|时间|公司|职位|工作内容|</div><div class="line">|:----:|:----:|:----:|:--------|</div><div class="line">|2019年4月~至今|瓜子二手车|高级Android开发工程师|负责瓜子二手车CRM平台型应用```向日葵```的开发和维护，在整个二手车售车交易环节中，您都看到```向日葵```的身影。```向日葵```作为平台型应用，为二手车各业线的销售铁军提供了强有力的线上化支持，也为一线管理者提供了强有力的抓手，为公司业绩保驾护航。使用场景覆盖了从工单、带看、客户维护、搓合交易、合同签署、支付、预约过户、办理过户、已售提交等整个交易流程所有节点，同时也为其它业务绩做了强有力的赋能，车务产品营销售卖、保卖收车任务、直播在线化等。|</div><div class="line">|2016年4月~2019年4月|北京秒啊科技有限公司|Android开发工程师|负责公司移动端技术选型，调研和Android端开发，与产品对接需求，和后台开发人员对接输出API文档，其中主要的工作有三部分：1.  Android端架构设计开发等相关工作 2. 后台部分API编写，Spring Boot部分模块开发 3. 项目协调，工作内容分布，已经进度把控相关工作|</div><div class="line">|2014年11月~2016年4月|北京融易通信息技术有限公司|Android开发工程师|期间主要负责EMP产品 Android SDK 功能开发，模块设计和维护，emp是所在公司客户端框架，emp客户端组件从平台伊始就致力于Native和Web的结合，通过将一部分HTML和CSS子集映射到Native UI的实现，比React Native更早的跨平台公司自用框架。|</div><div class="line"></div><div class="line"># **项目经历**</div><div class="line">### 向日葵```瓜子二手车</div></pre></td></tr></table></figure></li>
</ul>
<p>向日葵——集团to b方向平台型应用，覆盖整个二手车交易环节。 </p>
<p>我参与的工作内容:</p>
<p> 主要负责交付履约，过户，合同签署相关环节的业务需求的开发，售前售后过户，手续快递，全国购车辆物流，GPS管理监控，任务工单处理，等业务。 </p>
<p>期间负责一些技术需求的开发:</p>
<ol>
<li>gradle plugin+transform实现组件之间的解偶 </li>
<li>适配组件化接入sonar监控项目代码质量并输出报告 </li>
<li>利用apt技术实现自动生成recycleview adapter，代码更简洁 </li>
<li>结合matrix监控项目FPS，慢方法以及内存泄露，使用Profiler，MAT工具解决和监控项目的卡顿和内存并优化</li>
<li>matrix-apkChecker分析APK包大小并优化，引入andResguard资源混淆，gradle插件去除R文件优化包体积 </li>
<li>利用aop技术统计jsAction使用量以及项目流量统计 </li>
<li>基于replugin实现过户模块插件化，配合公司自研插件下发后台线上使用</li>
</ol>
<h3 id="秒啊-时间交易平台"><a href="#秒啊-时间交易平台" class="headerlink" title="秒啊(时间交易平台)"></a>秒啊(时间交易平台)<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">秒啊是一款全球首创的时间交易平台，从创投大咖，当红明星艺人到网红牛人，挖掘有潜力的人，售卖自己的时间，吸引粉丝和需求用户购买。用户通过购买名人时间（以秒为单位），兑换行权服务，例如线上聊天、线下共同进餐等。 在“秒啊”，行权最低只需1秒钟，内容包括在线聊天、语音、社交媒体回复转发、录制视频等；用户也可通过行权更多的时间，预约名人喝茶、吃饭、踢球、唱歌等互动形式，也可包含演出等商业活动。</div><div class="line"></div><div class="line">独立设计开发Android客户端，组件化和MVP方式构建代码框架，主要完成的内容包括：</div><div class="line"></div><div class="line">1. 公共的网络模块封装，Rxjava+Retrofit二次封装，拦截器封装公共参数，token认证，返回值统一封装，请求数据使用NDK方式加密，打包SO库等处理</div><div class="line">2. 封装公共的三级缓存处理，支持不同框架的图片加载模块封装，线程池的封装处理，权限处理封装，屏幕适配，主题切换等基础库</div><div class="line">3. Android5.0及以上新控件的学习及使用包括提示条，协调布局，导航视图，悬浮按钮，底部弹窗，应用栏和可折叠工具栏布局等</div><div class="line">4. 组件化相关构建脚本编写，Manifest和Application分解和整合，组件间通信的路由配置等</div><div class="line">5. 使用tinker热修复，达到用户无感的BUG修复和功能更新</div><div class="line">6. 进一步熟悉研究Android SDK 源码，Binder机制及AIDL使用，四大组件，消息机制，事件分发机制，View源码，dalvik虚拟机及编译过程等</div><div class="line">7. git, svn协作开发，git下新功能新建分支，合并主干，解决merge冲突，组员代码review等</div><div class="line">7. 基于GitHub,Hexo驱动加Next主题，GoDaddy搭建个人博客,输出技术积累</div><div class="line"></div><div class="line">### MiaoA(数字货币交易平台)```秒啊</div></pre></td></tr></table></figure></h3><p>MiaoA是一款ETH erc20智能合约代币TNB的落地Dapp。您可以使用TNB购买秒，TNB是专门为跨越国际边界的MiaoA交易所开发的一种新货币。这意味着，无论你身在何处，你都可以在没有国际货币壁垒的情况下，交易你最喜爱的名人的秒数。</p>
<p>期间完成的工作主要有:</p>
<ol>
<li>基于Web3J ETH规范，完成代币的钱包管理，充提币transaction的功能</li>
<li>mvvm+jetpack代码重构和解耦，组件的进一步封装和解耦</li>
<li>封装下沉UI组件和公共中间件</li>
<li>应用的各种持续优化工作</li>
</ol>
<h3 id="emp研发-交通银行，农业银行内核-融易通"><a href="#emp研发-交通银行，农业银行内核-融易通" class="headerlink" title="emp研发(交通银行，农业银行内核)融易通"></a>emp研发(交通银行，农业银行内核)<code>融易通</code></h3><p>emp是所在公司客户端框架，emp客户端组件从平台伊始就致力于Native和Web的结合，通过将一部分HTML和CSS子集映射到Native UI的实现，EMP客户端组件实现了一个跨平台的Web规范解析和渲染框架。具体来说，emp是一个简易的webKit，emp组件相当于浏览器，界面为传统的前端界面或者H5网页，以及lua脚本，emp框架负责解析html标签和lua脚本，再翻译成具体的android组件，经过一系列的渲染，布局，最后展示到客户端。</p>
<p>参与的工作主要有：</p>
<ul>
<li>emp editor(Atom插件)Android端支持</li>
<li>离线资源开发（提供Http/Tcp/WebSocket下载方式，支持插件下载，增量更新，大文件分段下载，webView加载离线H5资源）</li>
<li>Android SDK定制开发，自定义控件</li>
<li>Jni/Android NDK开发，封装C++加密库和网络库以及Lua脚本库</li>
<li>基于TLS1.1的信道重连机制，防重放机制开发。</li>
<li>APP防篡改功能开发</li>
<li>全局异常捕获机制开发<h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1>感谢您花时间阅读我的简历，期待能有机会和您公事</li>
</ul>
]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS双向认证</title>
    <url>/2020/03/10/HTTPS%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="HTTPS单向认证"><a href="#HTTPS单向认证" class="headerlink" title="HTTPS单向认证"></a>HTTPS单向认证</h2><h3 id="第一步：客户端发起ClientHello"><a href="#第一步：客户端发起ClientHello" class="headerlink" title="第一步：客户端发起ClientHello"></a>第一步：客户端发起ClientHello</h3><p>客户端向指定域名的服务器发起https请求，请求内容包括:</p>
<ul>
<li><p>客户端支持的SSL/TLS协议版本列表</p>
</li>
<li><p>支持的对称加密算法列表</p>
</li>
<li><p>客户端生成的随机数A</p>
</li>
</ul>
<h3 id="第二步：服务端回应SeverHello"><a href="#第二步：服务端回应SeverHello" class="headerlink" title="第二步：服务端回应SeverHello"></a>第二步：服务端回应SeverHello</h3><p>服务器收到请求后，回应客户端，回应的内容主要有：</p>
<ul>
<li><p>SSL/TLS版本。服务器会在客户端支持的协议和服务器自己支持的协议中，选择双方都支持的SSL/TLS的最高版本，作为双方使用的SSL/TLS版本。如果客户端的SSL/TLS版本服务器都不支持，则不允许访问</p>
</li>
<li><p>与1类似，选择双方都支持的最安全的加密算法。</p>
</li>
<li><p>从服务器密钥库中取出的证书</p>
</li>
<li><p>服务器端生成的随机数B</p>
</li>
</ul>
<h3 id="第三步：客户端回应"><a href="#第三步：客户端回应" class="headerlink" title="第三步：客户端回应"></a>第三步：客户端回应</h3><p>客户端收到后，检查证书是否合法，主要检查下面4点：</p>
<ul>
<li><p>检查证书是否过期</p>
</li>
<li><p>检查证书是否已经被吊销。</p>
</li>
<li><p>证书是否可信。</p>
</li>
<li><p>检查收到的证书中的域名与请求的域名是否一致。</p>
</li>
</ul>
<p>证书验证通过后，客户端使用特定的方法又生成一个随机数c，这个随机数有专门的名称“pre-master key”。接着，客户端会用证书的公钥对“pre-master key”加密，然后发给服务器。</p>
<h4 id="第四步，服务器的最后回应"><a href="#第四步，服务器的最后回应" class="headerlink" title="第四步，服务器的最后回应"></a>第四步，服务器的最后回应</h4><p>服务器使用密钥库中的私钥解密后，得到这个随机数c。此时，服务端和客户端都拿到了随机数a、b、c，双方通过这3个随机数使用相同的DH密钥交换算法计算得到了相同的对称加密的密钥。这个密钥就作为后续数据传输时对称加密使用的密钥。</p>
<p>服务器回应客户端，握手结束，可以采用对称加密传输数据了。</p>
<h2 id="这里注意几点："><a href="#这里注意几点：" class="headerlink" title="这里注意几点："></a>这里注意几点：</h2><p>1、整个验证过程，折腾了半天，其实是为了安全地得到一个双方约定的对称加密密钥，当然，过程中也涉及一些身份认证过程。既然刚开始时，客户端已经拿到了证书，里面包含了非对称加密的公钥，为什么不直接使用非对称加密方案呢，这是因为非对称加密计算量大、比较耗时，而对称加密耗时少。</p>
<p>2、对称加密的密钥只在这次连接中断前有效，从而保证数据传输安全。</p>
<p>3、为什么要用到3个随机数，1个不行吗？这是因为客户端和服务端都不能保证自己的随机数是真正随机生成的，这样会导致数据传输使用的密钥就不是随机的，时间长了，就很容易被破解。如果使用客户端随机数、服务端随机数、pre-master key随机数这3个组合，就能十分接近随机。</p>
<p>4、什么是信任库和密钥库。信任库前面已经说了，它是用来存放客户端信任的CA的证书。在程序交互中，需要确保你访问的服务器的证书在你的信任库里面。密钥库是用来存放服务器的私钥和证书。</p>
<p>5、中间人攻击问题。前面过程说明中，有一点，客户端是验证有问题的时候，是可以选择继续的。对浏览器而言，用户可以选择继续访问；对程序而言，有些系统为了处理简单，会选择信任所有证书，这样就给中间人攻击提供了漏洞。</p>
<p>中间人攻击时，它想办法拦截到客户端与服务器之间的通信。在客户端向服务器发信息时，中间人首先伪装成客户端，向真正的服务器发消息，获得真正的证书，接着伪装成服务器将自己的伪证书发给客户端。服务器向客户端发消息时，中间人伪装成客户端，接收消息，然后再伪装成服务器向客户端发消息。最后验证过程完成后，客户端的真实对称密钥被中间人拿到，而真正的服务器拿到的是中间人提供的伪密钥。后续数据传输过程中的数据就会被中间人窃取。</p>
<h2 id="HTTPS双向验证"><a href="#HTTPS双向验证" class="headerlink" title="HTTPS双向验证"></a>HTTPS双向验证</h2><p>单向验证过程中，客户端会验证自己访问的服务器，服务器对来访的客户端身份不做任何限制。如果服务器需要限制客户端的身份，则可以选择开启服务端验证，这就是双向验证。从这个过程中我们不难发现，<strong>使用单向验证还是双向验证，是服务器决定的。</strong></p>
<p>一般而言，我们的服务器都是对所有客户端开放的，<strong>所以服务器默认都是使用单向验证</strong>。如果你使用的是Tomcat服务器，在配置文件server.xml中，配置Connector节点的clientAuth属性即可。若为true，则使用双向验证，若为false，则使用单向验证。如果你的服务，只允许特定的客户端访问，那就需要使用双向验证了。</p>
<p>双向验证基本过程与单向验证相同，不同在于：</p>
<p>1）第二步服务器第一次回应客户端的SeverHello消息中，会要求客户端提供“客户端的证书”</p>
<p>2）第三步客户端验证完服务器证书后的回应内容中，会增加两个信息：</p>
<p>1、客户端的证书</p>
<p>2、客户端证书验证消息（CertificateVerifymessage）：客户端将之前所有收到的和发送的消息组合起来，并用hash算法得到一个hash值，然后用客户端密钥库的私钥对这个hash进行签名，这个签名就是CertificateVerifymessage</p>
<p>说明：这里关于客户端私钥的使用，网上有很多文章认为：在协商对称加密方案时，服务端先用客户端公钥加密服务器选定的对称加密方案，客户端收到后使用私钥解密得到。首先，对称加密方案就那么几种，逐个试试就能试出来，没必要为了这个增加一个客户端和服务端的交互过程。而这里关于CertificateVerifymessage的说法参考了维基百科关于“Transport Layer Security”一文中”Client-authenticated TLS handshake”的描述。<a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Client-authenticated_TLS_handshake" target="_blank" rel="external">链接</a></p>
<p>3）服务器收到客户端证书后：</p>
<p>a）确认这个证书是否在自己的信任库中（当然也会校验是否过期等信息），如果验证不通过则会拒绝连接；</p>
<p>b）用客户端证书中的公钥去验证收到的证书验证消息中的签名。这一步的作用是为了确认证书确实是客户端的。</p>
<p>所以，在双向验证中，客户端需要用到密钥库，保存自己的私钥和证书，并且证书需要提前发给服务器，由服务器放到它的信任库中。</p>
<h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>1、单向验证中，如果是你客户端，你需要拿到服务器的证书，并放到你的信任库中；如果是服务端，你要生成私钥和证书，并将这两个放到你的密钥库中，并且将证书发给所有客户端。</p>
<p>2、双向验证中，如果你是客户端，你要生成客户端的私钥和证书，将它们放到密钥库中，并将证书发给服务端，同时，在信任库中导入服务端的证书。如果你是服务端，除了在密钥库中保存服务器的私钥和证书，还要在信任库中导入客户端的证书。</p>
<p>3、再次强调，使用单向验证还是双向验证，是服务器决定的。</p>
<p>4、https的验证过程，不管是单向还是双向，只有四步，网上很多关于https验证过程的文章中，写了来来回回七八上十步。要真是这样，访问一个https地址，时间全花在了交互上了。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Handler消息传递机制全面解析</title>
    <url>/2020/03/09/Handler%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h3 id="Android的消息机制概述"><a href="#Android的消息机制概述" class="headerlink" title="Android的消息机制概述"></a>Android的消息机制概述</h3><p>Android的消息机制主要是指Handler的运行机制以及Handler所附带的MessageQueue和Looper工作过程。</p>
<p>handler发送Message给MessageQueue,Looper.loop循环读取MessageQueue中的msg，并调用msg.target.dispatchMessage(msg)<br>把消息交给handler去分发处理</p>
<p>handler和message是我们主动创建的，handler把message发送给MessageQueue，MessageQueue是在Looper的构造方法中初始化的，而Looper初始化的场景有2种，主线程中使用Looper可直接使用，因为应用启动的时候主线程ActivityThread的main方法中会通过Looper.prepareMainLooper()方法创建主线程的Looper，子线程使用的话必须先调用Looper.prepare()方法初始化Looper</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方式完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将Application中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
<p>Handler创建的时候，其构造方法中会有如下代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="string">''</span><span class="string">''</span></div><div class="line">mLooper = Looper.myLooper();</div><div class="line"><span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</div><div class="line">        <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</div><div class="line">&#125;</div><div class="line"><span class="string">''</span><span class="string">''</span>      </div><div class="line"></div><div class="line"><span class="comment">//获取Looper其实是从Looper的成员变量ThreadLocal对象sThreadLocal中获取</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> sThreadLocal.get();</div><div class="line">&#125;</div><div class="line"><span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</div></pre></td></tr></table></figure>
<p>可见在没有Looper的线程中是不能直接new Handler()的</p>
<p>整个机制所涉及到的内容：</p>
<ul>
<li>Handler</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MessageQueue和Looper是它的成员变量</div><div class="line"></div><div class="line">负责发送消息，是Message的载体 msg.target = 发送它的Handler</div><div class="line"></div><div class="line">也可以分发消息，交给msg.callback或者自己构造函数传进来的的callback或者自己本身的handleMessage(msg)方法来处理</div><div class="line"></div><div class="line"><span class="comment">//构造方法</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span></span></div><div class="line"></div><div class="line"><span class="comment">//如何分发</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> &#123;</div><div class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</div><div class="line">       <span class="comment">//mesage的callback</span></div><div class="line">        handleCallback(msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//构造方法传来的callback</span></div><div class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//我们平常覆写的方法</span></div><div class="line">        handleMessage(msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Subclasses must implement this to receive messages.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">线程切换，Handler在任意线程发送消息，最后都会切换回Looper所在的线程执行，因为最后分发消息回调callback都在Looper的loop方法执行的</div></pre></td></tr></table></figure>
<ul>
<li>Message</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">需要传递的消息，包含传递的数据，也可以设置处理消息的Callback</div><div class="line"></div><div class="line">知识点: 创建一个一个Message 对象的时候最好使用Message.obtain()</div><div class="line">而不是new Message();因为Message.obtain()实际是一个对象复用技术。</div><div class="line">可以减少内存的使用。</div><div class="line"></div><div class="line">Message中有个next对象保存下一个Message，这是Looper循环读取消息处理的原理所在</div><div class="line"></div><div class="line">public static Message obtain() &#123;</div><div class="line">    //sPool 会在创建的Message使用完之后赋值</div><div class="line">    //在recycleUnchecked()方法实现</div><div class="line">    //赋值之前会把之前的内容清空，重用内存空间</div><div class="line">    synchronized (sPoolSync) &#123;</div><div class="line">        if (sPool != null) &#123;</div><div class="line">            Message m = sPool;</div><div class="line">            sPool = m.next;</div><div class="line">            m.next = null;</div><div class="line">            m.flags = 0; // clear in-use flag</div><div class="line">            sPoolSize--;</div><div class="line">            return m;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //只有第一次使用会创建新的对象</div><div class="line">    return new Message();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>MessageQueue</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">阻塞队列(其实是单向链表实现)，因为入队出队以及延时消息会发生大</div><div class="line">量的插入和删除操作，所以链表的数据结构效率更高，MessageQueue</div><div class="line">中的mMessages保存链表的第一个元素</div><div class="line"></div><div class="line">主要关注点有两个方法</div><div class="line">enqueueMessage(Message msg, long when) 入队操作</div><div class="line">next() 出队操作，阻塞的根本原因</div><div class="line"></div><div class="line"></div><div class="line">首先说入队加入消息的操作：</div><div class="line"></div><div class="line">//msg handler发送来的消息  when 延时时间</div><div class="line">boolean enqueueMessage(Message msg, long when) &#123;</div><div class="line">        if (msg.target == null) &#123;</div><div class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</div><div class="line">        &#125;</div><div class="line">        if (msg.isInUse()) &#123;</div><div class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            //mQuitting 一般都为false,还有MessageQueue退出时才为true</div><div class="line">            if (mQuitting) &#123;</div><div class="line">                IllegalStateException e = new IllegalStateException(</div><div class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</div><div class="line">                Log.w(TAG, e.getMessage(), e);</div><div class="line">                msg.recycle();</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            msg.markInUse();</div><div class="line">            msg.when = when;</div><div class="line">            Message p = mMessages;</div><div class="line">            boolean needWake;</div><div class="line">            if (p == null || when == 0 || when &lt; p.when) &#123;</div><div class="line">                // New head, wake up the event queue if blocked.</div><div class="line">                msg.next = p;</div><div class="line">                //当链表为空的时候，把第一个进来的消息赋值给为mMessages，作为链表的第一个元素</div><div class="line">                mMessages = msg;</div><div class="line">                //当新进来的消息是第一个那么根据mBlocked判断是否需要唤醒线程，如果不是第一个一般情况下不需要唤醒（如果加入的消息是异步的需要另外判断）</div><div class="line">                needWake = mBlocked;</div><div class="line">            &#125; else &#123;</div><div class="line">                // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</div><div class="line">                // up the event queue unless there is a barrier at the head of the queue</div><div class="line">                // and the message is the earliest asynchronous message in the queue.</div><div class="line">                //是否唤醒线程的标记，只有链表的第一个消息为屏障消息，并且当前要插入的消息为异步消息并且当前线程阻塞的时候才为ture</div><div class="line">                //只有当p.target == null也就是说当前消息没有handler载体的时候才为屏障消息</div><div class="line">                //我们代码平常发送的消息都为同步消息</div><div class="line">                //msg.isAsynchronous()代表是否为异步消息，当消息队列中只要有一个屏障消息后，所有的同步消息都会被屏蔽，只有异步消息会被执行通过msg.setAsynchronous(true)设置为异步消息</div><div class="line">        </div><div class="line">        </div><div class="line">                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</div><div class="line">                Message prev;</div><div class="line">                for (;;) &#123;</div><div class="line">                    prev = p;</div><div class="line">                    p = p.next;</div><div class="line">                    if (p == null || when &lt; p.when) &#123;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    if (needWake &amp;&amp; p.isAsynchronous()) &#123;</div><div class="line">                        needWake = false;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                msg.next = p; // invariant: p == prev.next</div><div class="line">                prev.next = msg;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // We can assume mPtr != 0 because mQuitting is false.</div><div class="line">            if (needWake) &#123;</div><div class="line">                nativeWake(mPtr);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">主要就是加入链表的时候按时间顺序从小到大排序，然后判断是否需要唤醒(</div><div class="line">当没有消息时，如果需要唤醒则调用nativeWake(mPtr);来唤醒之前等待的线程</div><div class="line"></div><div class="line">    </div><div class="line">出队操作获取消息：</div><div class="line"></div><div class="line">Message next() &#123;</div><div class="line">        // Return here if the message loop has already quit and been disposed.</div><div class="line">        // This can happen if the application tries to restart a looper after quit</div><div class="line">        // which is not supported.</div><div class="line">        final long ptr = mPtr;</div><div class="line">        if (ptr == 0) &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        int pendingIdleHandlerCount = -1; // -1 only during first iteration</div><div class="line">        //MessageQueue阻塞nextPollTimeoutMillis毫秒的时间。</div><div class="line">//1.如果nextPollTimeoutMillis=-1，一直阻塞不会超时。</div><div class="line">//2.如果nextPollTimeoutMillis=0，不会阻塞，立即返回。</div><div class="line">//3.如果nextPollTimeoutMillis&gt;0，最长阻塞nextPollTimeoutMillis毫秒(超时)，如果期间有程序唤醒会立即返回。</div><div class="line">        int nextPollTimeoutMillis = 0;</div><div class="line">        for (;;) &#123;</div><div class="line">            if (nextPollTimeoutMillis != 0) &#123;</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            //执行阻塞，时长nextPollTimeoutMillis</div><div class="line">            nativePollOnce(ptr, nextPollTimeoutMillis);</div><div class="line"></div><div class="line">            synchronized (this) &#123;</div><div class="line">                // Try to retrieve the next message.  Return if found.</div><div class="line">                final long now = SystemClock.uptimeMillis();</div><div class="line">                Message prevMsg = null;</div><div class="line">                Message msg = mMessages;</div><div class="line">                if (msg != null &amp;&amp; msg.target == null) &#123;</div><div class="line">                    // Stalled by a barrier.  Find the next asynchronous message in the queue.</div><div class="line">                    //如果发现了一个消息屏障，会循环找出第一个异步消息（如果有异步消息的话）， </div><div class="line">                    //所有同步消息都将忽略（平常发送的一般都是同步消息），可以通过setAsynchronous(boolean async)设置为异步消息。</div><div class="line">                    do &#123;</div><div class="line">                        prevMsg = msg;</div><div class="line">                        msg = msg.next;</div><div class="line">                    &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                if (msg != null) &#123;</div><div class="line">                    //如果有消息需要处理，先判断时间有没有到，如果没到的话设置一下阻塞时间nextPollTimeoutMillis</div><div class="line">                    //，进入下次循环的时候会调用nativePollOnce(ptr, nextPollTimeoutMillis);阻塞；</div><div class="line">                    //否则把消息返回给调用者，并且设置mBlocked = false代表目前没有阻塞</div><div class="line">                    if (now &lt; msg.when) &#123;</div><div class="line">                        // Next message is not ready.  Set a timeout to wake up when it is ready.</div><div class="line">                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</div><div class="line">                    &#125; else &#123;</div><div class="line">                        // Got a message.</div><div class="line">                        mBlocked = false;</div><div class="line">                        if (prevMsg != null) &#123;</div><div class="line">                            prevMsg.next = msg.next;</div><div class="line">                        &#125; else &#123;</div><div class="line">                            mMessages = msg.next;</div><div class="line">                        &#125;</div><div class="line">                        msg.next = null;</div><div class="line">                        if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</div><div class="line">                        msg.markInUse();</div><div class="line">                        return msg;</div><div class="line">                    &#125;</div><div class="line">                &#125; else &#123;</div><div class="line">                    // No more messages.</div><div class="line">                    //没有消息设置-1 表示一直阻塞不会超时</div><div class="line">                    nextPollTimeoutMillis = -1;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // Process the quit message now that all pending messages have been handled.</div><div class="line">                if (mQuitting) &#123;</div><div class="line">                    dispose();</div><div class="line">                    return null;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                // If first time idle, then get the number of idlers to run.</div><div class="line">                // Idle handles only run if the queue is empty or if the first message</div><div class="line">                // in the queue (possibly a barrier) is due to be handled in the future.</div><div class="line">                if (pendingIdleHandlerCount &lt; 0</div><div class="line">                        &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</div><div class="line">                    pendingIdleHandlerCount = mIdleHandlers.size();</div><div class="line">                &#125;</div><div class="line">                //当没有消息或者需要延时执行时走到这 说明需要阻塞</div><div class="line">                if (pendingIdleHandlerCount &lt;= 0) &#123;</div><div class="line">                    // No idle handlers to run.  Loop and wait some more.</div><div class="line">                    mBlocked = true;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (mPendingIdleHandlers == null) &#123;</div><div class="line">                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</div><div class="line">                &#125;</div><div class="line">                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Run the idle handlers.</div><div class="line">            // We only ever reach this code block during the first iteration.</div><div class="line">            for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</div><div class="line">                final IdleHandler idler = mPendingIdleHandlers[i];</div><div class="line">                mPendingIdleHandlers[i] = null; // release the reference to the handler</div><div class="line"></div><div class="line">                boolean keep = false;</div><div class="line">                try &#123;</div><div class="line">                    keep = idler.queueIdle();</div><div class="line">                &#125; catch (Throwable t) &#123;</div><div class="line">                    Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (!keep) &#123;</div><div class="line">                    synchronized (this) &#123;</div><div class="line">                        mIdleHandlers.remove(idler);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // Reset the idle handler count to 0 so we do not run them again.</div><div class="line">            pendingIdleHandlerCount = 0;</div><div class="line"></div><div class="line">            // While calling an idle handler, a new message could have been delivered</div><div class="line">            // so go back and look again for a pending message without waiting.</div><div class="line">            nextPollTimeoutMillis = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">同步屏障消息：    </div><div class="line">使用MessageQueue.postSyncBarrier()向MessageQueue中插入了一个Message，</div><div class="line">并且未设置target。它的作用是插入一个消息屏障，</div><div class="line">这个屏障之后的所有同步消息都不会被执行，即使时间已经到了也不会执行。</div><div class="line">可以通过public void removeSyncBarrier(int token)来移除这个屏障，参数是post方法的返回值。</div><div class="line">这些方法是隐藏的或者是私有的，具体应用场景可以查看ViewRootImpl中的</div><div class="line">void scheduleTraversals()方法，它在绘图之前会插入一个消息屏障，绘制之后移除。</div><div class="line"></div><div class="line">1.首次进入循环nextPollTimeoutMillis=0，阻塞方法</div><div class="line">nativePollOnce(ptr,nextPollTimeoutMillis)会立即返回</div><div class="line">2.读取列表中的消息，如果发现消息屏障，则跳过后面的同步消息，总之会通过当前时间，是否遇到屏障来返回符合条件的待处理消息</div><div class="line">3.如果没有符合条件的消息，会处理一些不紧急的任务（IdleHandler），再次进入第一步</div><div class="line"></div><div class="line"></div><div class="line">队列退出</div><div class="line"></div><div class="line"> void quit(boolean safe) &#123;</div><div class="line">        if (!mQuitAllowed) &#123;</div><div class="line">            throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        synchronized (this) &#123;</div><div class="line">            if (mQuitting) &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            mQuitting = true;</div><div class="line"></div><div class="line">            if (safe) &#123;</div><div class="line">                removeAllFutureMessagesLocked();</div><div class="line">            &#125; else &#123;</div><div class="line">                removeAllMessagesLocked();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            // We can assume mPtr != 0 because mQuitting was previously false.</div><div class="line">            nativeWake(mPtr);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>Looper</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Looper在消息机制中扮演者消息循环的角色，具体来说就是他会不停的从MessageQueue中查看是否有新消息，有消息会立刻处理，否则就一直阻塞在那里。</div><div class="line"></div><div class="line">如果是在子线程中创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，负责这个字线程就会一直处于等待的状态，退出Looper后，这个线程就会立刻终止</div><div class="line"></div><div class="line">而主线程的Looper是不可以退出的 。</div><div class="line"></div><div class="line">//主线程的Looper</div><div class="line">public static void prepareMainLooper() &#123;</div><div class="line">        //false 代表不可退出</div><div class="line">        prepare(false);</div><div class="line">        synchronized (Looper.class) &#123;</div><div class="line">            if (sMainLooper != null) &#123;</div><div class="line">                throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</div><div class="line">            &#125;</div><div class="line">            sMainLooper = myLooper();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//子线程的Looper 默认可退出    </div><div class="line">public static void prepare() &#123;</div><div class="line">    prepare(true);</div><div class="line">&#125;</div><div class="line"></div><div class="line">阻塞的问题：</div><div class="line"></div><div class="line">Looper最重要得就是loop方法，loop方法是一个死循环，一直读取MessageQueue的消息，唯一跳出循环的</div><div class="line">条件就是MessageQueue.next()方法返回null,从前面MessageQueue的next方法源码中我们可以看到主线程阻</div><div class="line">塞的真正原因是因为消息队列的阻塞，当队列中没消息的时候nextPollTimeoutMillis =-1表示一直阻塞</div><div class="line">不会超时，这时候主线程会一直循环读取MessageQueue中的消息，直到MessageQueue的quit()方法被调用，</div><div class="line">这时候next()方法会返回null，这时候loop方法也会跳出循环，MessageQueue的quit()方法在哪被调用呢</div><div class="line">？其实是在Looper的的quit()和quitSafely()方法中调用的。</div><div class="line"></div><div class="line">quit():直接退出Looper</div><div class="line">quitSafely():已有消息处理完后退出Looper退出</div><div class="line"></div><div class="line">/**</div><div class="line"> * Run the message queue in this thread. Be sure to call</div><div class="line"> * &#123;@link #quit()&#125; to end the loop.</div><div class="line"> */</div><div class="line">public static void loop() &#123;</div><div class="line">    final Looper me = myLooper();</div><div class="line">    if (me == null) &#123;</div><div class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</div><div class="line">    &#125;</div><div class="line">    final MessageQueue queue = me.mQueue;</div><div class="line"></div><div class="line">    // Make sure the identity of this thread is that of the local process,</div><div class="line">    // and keep track of what that identity token actually is.</div><div class="line">    Binder.clearCallingIdentity();</div><div class="line">    final long ident = Binder.clearCallingIdentity();</div><div class="line"></div><div class="line">    for (;;) &#123;</div><div class="line">        Message msg = queue.next(); // might block</div><div class="line">        if (msg == null) &#123;</div><div class="line">            // No message indicates that the message queue is quitting.</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        &apos;&apos;&apos;&apos;&apos;&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public void quit() &#123;</div><div class="line">    mQueue.quit(false);</div><div class="line">&#125;</div><div class="line">public void quitSafely() &#123;</div><div class="line">    mQueue.quit(true);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>每个线程都可以有一个Looper。那么Handler如何把消息传递给正确的Looper去处理呢？</p>
<p>当我们new Handler()的时候，其构造方法中会从Looper的sThreadLocal对象中获取Looper对象并且通过获取的Looper对象从而获取MessageQueue,之后通过Handler发送的消息都会放到Looper中的MessageQueue中。</p>
<p>sThreadLocal.get()如何确保获取的Looper和Handler是在同一个线程中的呢。</p>
<p>这是因为sThreadLocal是一个ThreadLocal对象。</p>
<p>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其它线程来说则无法获取到数据。</p>
<p>sThreadLocal在哪存储值得呢：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">        &#125;</div><div class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在Looper.prepare()中会把创建的Looper存进去。</p>
<p>ThreadLocal如何实现不同线程存储对应的不同数据的呢：</p>
<p>存值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    //获取当前线程</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//根据当前线程获取线程池中的ThreadLocalMap对象    </div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//首次set会创建ThreadLocalMap对象并赋值给线程的 threadLocals成员变量   </div><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ThreadLocalMap是ThreadLocal内部的一个Map实现，然而它没有实现任何集合的接口规范，因为它仅供ThreadLocal内部使用，数据结构采用数组+开方地址法，内部有一个Entry类型的table数组,Entry继承WeakRefrence，是基于ThreadLocal这种特殊场景实现的Map</p>
<p>new ThreadLocalMap(this, firstValue); this代表当前Looper的sThreadLocal对象，值为new 出来的Looper。以Key-Value的形式存放到Entry中，并复制给ThreadLocalMap的table数组中，数组的下标的计算规则如下 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line"></div><div class="line">            // We don&apos;t use a fast path as with get() because it is at</div><div class="line">            // least as common to use set() to create new entries as</div><div class="line">            // it is to replace existing ones, in which case, a fast</div><div class="line">            // path would fail more often than not.</div><div class="line"></div><div class="line">            Entry[] tab = table;</div><div class="line">            int len = tab.length;</div><div class="line">            //计算数组下标</div><div class="line">            int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">            for (Entry e = tab[i];</div><div class="line">                 e != null;</div><div class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">                ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">                if (k == key) &#123;</div><div class="line">                    e.value = value;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                if (k == null) &#123;</div><div class="line">                    replaceStaleEntry(key, value, i);</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            tab[i] = new Entry(key, value);</div><div class="line">            int sz = ++size;</div><div class="line">            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">                rehash();</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>取值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//ThreadLocal</div><div class="line">public T get() &#123;</div><div class="line">        Thread t = Thread.currentThread();</div><div class="line">        ThreadLocalMap map = getMap(t);</div><div class="line">        if (map != null) &#123;</div><div class="line">            ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">            if (e != null) &#123;</div><div class="line">                @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">                T result = (T)e.value;</div><div class="line">                return result;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return setInitialValue();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //ThreadLocalMap</div><div class="line">    private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</div><div class="line">            int i = key.threadLocalHashCode &amp; (table.length - 1);</div><div class="line">            Entry e = table[i];</div><div class="line">            if (e != null &amp;&amp; e.get() == key)</div><div class="line">                return e;</div><div class="line">            else</div><div class="line">                return getEntryAfterMiss(key, i, e);</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Handler myHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">      updateUIHere();</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">new</span> Thread() &#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        doStuff();         <span class="comment">// 执行耗时操作</span></div><div class="line">        Message msg = myHandler.obtainMessage();</div><div class="line">        Bundle b = <span class="keyword">new</span> Bundle();</div><div class="line">        b.putString(<span class="string">"key"</span>, <span class="string">"value"</span>);</div><div class="line">        m.setData(b);    <span class="comment">// 向消息中添加数据</span></div><div class="line">        myHandler.sendMessage(m);    <span class="comment">// 向Handler发送消息，更新UI</span></div><div class="line">   &#125;</div><div class="line">&#125;.start();</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</div><div class="line">  *      <span class="keyword">public</span> Handler mHandler;</div><div class="line">  *</div><div class="line">  *      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  *          Looper.prepare();</div><div class="line">  *</div><div class="line">  *          mHandler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">  *              <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">  *                  <span class="comment">// process incoming messages here</span></div><div class="line">  *              &#125;</div><div class="line">  *          &#125;;</div><div class="line">  *</div><div class="line">  *          Looper.loop();</div><div class="line">  *      &#125;</div><div class="line">  *  &#125;</div></pre></td></tr></table></figure>
<p>可以理解handler的作用其实是用来把在子线程执行耗时操作的结果发送到Looper所在线程去处理的类。</p>
<p>比如上述的实例，其实就是利用handler在子线程中更新UI</p>
<p>为什么不能再子线程中直接更新UI呢？</p>
<p>其实是因为：</p>
<ol>
<li>ViewRootImp对UI操作做了验证(ViewRootImp是在OnResume启动后创建的，所以在onResume执行之前子线程其实也是可以更新UI的，相当于绕过了检查，但是不建议这么做)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException(</div><div class="line">                    <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>Android的UI控件不是线程安全的，多线程并发访问可能会导致UI控件处于不可预期的状态，为什么不对UI控件访问加上锁机制呢，缺点有2个，首先加上锁机制会让UI访问的逻辑变得复杂，其次锁机制会减低UI访问的效率，应为锁机制会阻塞某些线程的执行。</li>
</ol>
<p>为什么MessageQueue阻塞队列，不会导致ANR呢？</p>
<p>这是因为ANR其实是因为耗时任务执行超过一定的时间还没执行完导致的，而阻塞队列并没有执行耗时操作，只是等待消息的到来，不会阻塞线程，而且如果阻塞线程的话，后续的操作都不会执行了，但是从我们的应用启动到关闭，主线程是一直执行的，Looper并没有导致主线程不工作。</p>
<p>ANR超时时间的定义：</p>
<ul>
<li>1.broadcast超时时间为10秒</li>
<li>按键无响应的超时时间为5秒</li>
<li>前台service无响应的超时时间为20秒</li>
<li>后台service为200秒</li>
</ul>
<p>ANR文件的分析和获取</p>
<p>traces.txt系统自动生成的记录anr等异常的文件，只记录java代码产生的异常。</p>
<p>文件位置在/data/anr/traces.txt</p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令</title>
    <url>/2020/03/09/git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><ul>
<li>[x] git branch 查看本地当前所有分支;</li>
<li>[x] git branch -a 查看本地与远程的所有分支;</li>
<li>[x] git branch -d <branchname> 删除本地分支，此分支已经被合并;</branchname></li>
<li>[x] git branch -D <branchname> 强制删除本地分支;</branchname></li>
<li>[x] git push origin –delete <branchname> 删除远程分支</branchname></li>
<li>[x] git merge <branchname> 合并指定分支到当前分支;</branchname></li>
<li>[x] git merge –no-ff <branchname> 合并指定分支到当前分支,生成一个新的提交;</branchname></li>
<li>[x] git merge  –squash <branchname> 合并指定分支(不包含 commit 记录)到当前分支；</branchname></li>
<li>[x] git checkout <branchname> 切换分支</branchname></li>
<li>[x] git checkout -b <branchname> 创建并切换分支</branchname></li>
<li>[x] git branch remotes/origin/<branchname> git checkout -b <branchname>切换远程分支</branchname></branchname></li>
<li>[x] git branch -vv 查看本地分支与远程分支映射关系</li>
<li>[x] git branch -u origin/<bracnname> 或 git branch –set-upstream-to origin/<branchname> 关联当前分支与远程分支</branchname></bracnname></li>
<li><p>[x] git branch –unset-upstream 取消当前分支与远程分支关联</p>
<h3 id="保存操作"><a href="#保存操作" class="headerlink" title="保存操作"></a>保存操作</h3></li>
<li><p>[x] git stash 保存暂缓区和工作区</p>
</li>
<li>[x] git stash pop 释放保存到暂缓区和工作区</li>
<li>[x] git stash list 显示保存列表</li>
<li>[x] git stash pop stash@{1} 释放指定指定序列</li>
<li>[x] git stash drop stash@{1} 删除指定序列</li>
<li>[x] git stash clear 删除所有</li>
</ul>
<h4 id="回滚操作"><a href="#回滚操作" class="headerlink" title="回滚操作"></a>回滚操作</h4><ul>
<li>[x] git log 查看提交记录</li>
<li>[x] git reset –soft <commit id=""> 只回滚提交记录,代码依然为当前代码</commit></li>
<li>[x] git reset –hard <commit id=""> 回滚到指定提交记录</commit></li>
<li>[x] git reflog 看查看操作记录</li>
<li>[x] git reset –soft HEAD@{number} 只回滚操作记录，代码依然为当前代码 </li>
<li>[x] git reset –hard HEAD@{number} 回滚到指定操作步骤，代码依然回滚</li>
</ul>
<h3 id="提交操作"><a href="#提交操作" class="headerlink" title="提交操作"></a>提交操作</h3><ul>
<li>[x]  git status 查看当前状态</li>
<li>[x]  git add -A 添加至暂缓区</li>
<li>[x]  git commit -m “message” 提交至本地</li>
<li>[x]  git commit –amend 以补丁形式提交至上一个分支</li>
<li>[x]  git push origin HEAD:refs/for/<branchname> 提交至远程进行review</branchname></li>
<li>[x]  git push 提交至远程分支</li>
<li>[x]  git pull 拉取并合并到当前分支</li>
<li>[x]  git pull –rebase  拉取并进行rebase</li>
<li>[x]  git rebase –continue 继续当前余下的补丁</li>
<li>[x]  git reabse –abort 终止当前 rebase</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>事件分发</title>
    <url>/2020/03/09/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="点击事件的传递规则"><a href="#点击事件的传递规则" class="headerlink" title="点击事件的传递规则"></a>点击事件的传递规则</h2><p>当屏幕接收到用户的输入的时候，底层会把事件包装成一个MotionEvent,所谓的点击事件的分发就是系统把一个MontionEvent事件传递给一个具体的View，这个传递过程就是分发过程。</p>
<p>分发过程由三个重要的方法来共同完成：</p>
<ul>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li>onTouchEvent</li>
</ul>
<p>对于一个根viewGroup来说，点击事件产生后，首先会传递给它，它的dispatchTouchEvent方法被调用，然后判断onInterceptTouchEvent的返回值，如果为true，表示事件由当前viewGroup处理，即他的onTouchEvent会被调用，如果返回false表示不拦截，则传递给它的子元素，接着子元素的dispatchTouchEvent方法会被调用，如此反复知道事件最终被处理。</p>
<p>当一个View需要处理事件的时候，</p>
<p>它如果设置了onTouchListener那么onTouchListener中的onTouch方法会被回调，后续如何处理还得看onTouch的返回值，返回false，view的onTouchEvent才会被调用，返回true,则不会回调onTouchevent。在onTouchEvent中如果当前有设置onClickListener，那么它的onClick方法会被调用。</p>
<p>所以执行顺序</p>
<p>onTouchListener-onTouch() - &gt;<br>onTouchEvent() -&gt;<br>onClickListener-onClick()</p>
<ul>
<li><p>viewGroup默认不拦截任何事件，android源码中ViewGroup的onInterceptTouchEvent方法默认返回false</p>
</li>
<li><p>view没有onInterceptTouchEvent方法，一旦事件传递给它，那么它的onTouchEvent方法就会被调用</p>
</li>
</ul>
<h2 id="传递顺序"><a href="#传递顺序" class="headerlink" title="传递顺序"></a>传递顺序</h2><p>DecorView -&gt; Activity -&gt; PhoneWindow -&gt; DecorView传递事件</p>
<p>为什么这么做：</p>
<p>解耦! ViewRootImpl并不知道有Activity这种东西存在！它只是持有了DecorView。所以，不能直接把触摸事件送到Activity.dispatchTouchEvent()；那么，既然触摸事件已经到了Activity.dispatchTouchEvent()中了，为什么不直接分发给DecorView，而是要通过PhoneWindow来间接发送呢？因为Activity不知道有DecorView！但是，Activity持有PhoneWindow ，而PhoneWindow当然知道自己的窗口里有些什么了，所以能够把事件派发给DecorView。在Android中，Activity并不知道自己的Window中有些什么，这样耦合性就很低了。我们换一个Window试试？不管Window里面的内容如何，只要Window任然符合Activity制定的标准，那么它就能在Activity中很好的工作。当然，这就是解耦所带来的扩展性的好处。</p>
<h2 id="滑动冲突的处理"><a href="#滑动冲突的处理" class="headerlink" title="滑动冲突的处理"></a>滑动冲突的处理</h2><p>外部拦截和内部拦截法</p>
<p>外部拦截：父ViewGroup中的onInterceptTouchEvent()方法中去处理 ，根据手指移动的距离或者角度，或者一些业务关系来判断父View是否拦截。拦截返回true 由父控件处理</p>
<p>内部拦截: 在子View的dispatchTouchEvent()方法中去处理，逻辑一样，不过当需要父控件处理时需要配合requestDisallowInterceptTouchEvent()方法才能正常工作。</p>
<p>requestDisallowInterceptTouchEvent方法失效 ？</p>
<p>因为在ViewGroup的ACTION_DOWN时，FLAG_DISALLOW_INTERCEPT标志位被置为false</p>
<p>怎么解决这个问题呢？只有重写自己用到的View的dispatchTouchEvent方法，在其ACTION_DOWN的时候，调用父View的requestDisallowInterceptTouchEvent(true)方法设置，在ACTION_UP或者ACTION_CANCEL的时候，调用调用父View的requestDisallowInterceptTouchEvent(false)方法重置。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://wanandroid.com/wenda/show/12119" target="_blank" rel="external">https://wanandroid.com/wenda/show/12119</a></p>
]]></content>
      <categories>
        <category>Android源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>父子仓库操作</title>
    <url>/2020/03/09/%E7%88%B6%E5%AD%90%E4%BB%93%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h3 id="1-添加-submodule"><a href="#1-添加-submodule" class="headerlink" title="1 添加 submodule"></a>1 添加 submodule</h3><p>在父仓库 git 目录下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git submodule add ssh://ip/[path]/xxx.git</div></pre></td></tr></table></figure></p>
<h4 id="父仓库的变化："><a href="#父仓库的变化：" class="headerlink" title="父仓库的变化："></a>父仓库的变化：</h4><ol>
<li>新增了子仓库的内容文件夹</li>
<li>新增（如果之前没有）.gitmodules</li>
<li>.git/config中增加了section：[submodule “modulename”]</li>
<li>.git/modules中增加了module的文件夹，里面有所有自仓库的git信息文件夹</li>
</ol>
<h3 id="2-第一次clone主项目"><a href="#2-第一次clone主项目" class="headerlink" title="2 第一次clone主项目"></a>2 第一次clone主项目</h3><p>需要手动更新一下子module的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git submodule init</div><div class="line">git submodule update</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git submodule update --init --recursive</div></pre></td></tr></table></figure></p>
<h3 id="3-遍历拉取所有子module的更新"><a href="#3-遍历拉取所有子module的更新" class="headerlink" title="3 遍历拉取所有子module的更新"></a>3 遍历拉取所有子module的更新</h3><p>git submodule foreach git pull origin master</p>
<h3 id="4-子module修改提交"><a href="#4-子module修改提交" class="headerlink" title="4 子module修改提交"></a>4 子module修改提交</h3><ol>
<li>先在submodule的目录下push代码，这是单独更新submodule的内容</li>
<li>然后在父仓库的目录下push代码，这是更新父仓库的submodule信息</li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP握手和挥手</title>
    <url>/2020/03/09/TCP%E6%8F%A1%E6%89%8B%E5%92%8C%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>先来了解一下三次握手。</p>
<p>在通过 TCP 传输数据时，第一步就是要先建立一个连接。TCP 建立连接的过程，就是我们常说的三次握手。</p>
<p>我们经常将三次握手，描述成「请求 → 应答 → 应答之应答」。</p>
<p>至于 TCP 握手为什么是三次，其实就是要让双端都经历一次「请求 → 应答」的过程，来确认对方还在。网络情况是多变的，双端都需要一次自己主动发起的请求和对方回复的应答过程，来确保对方和网络是正常的。</p>
<p>下面这张图，是比较经典的 TCP 三次握手的消息和双端状态的变化。</p>
<p><img src="https://s2.ax1x.com/2020/03/09/8pHvJ1.png" alt="8pHvJ1.png"></p>
<p>我们先来解释一下这张图：</p>
<ol>
<li><p>在初始时，双端处于 CLOSE 状态，服务端为了提供服务，会主动监听某个端口，进入 LISTEN 状态。</p>
</li>
<li><p>客户端主动发送连接的「SYN」包，之后进入 SYN-SENT 状态，服务端在收到客户端发来的「SYN」包后，回复「SYN,ACK」包，之后进入 SYN-RCVD 状态。</p>
</li>
<li><p>客户端收到服务端发来的「SYN,ACK」包后，可以确认对方存在，此时回复「ACK」包，并进入 ESTABLISHED 状态。</p>
</li>
<li><p>服务端收到最后一个「ACK」包后，也进入 ESTABLISHED 状态。</p>
</li>
</ol>
<p>正常的三次握手之后，双端都进入 ESTABLISHED 状态，在此之后，就是正常的数据传输过程。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>先来简单了解一下 TCP 的四次挥手。</p>
<p>当数据传输完成，需要断开连接的时候，TCP 会采取四次挥手的方式，来安全的断开连接。</p>
<p>为什么握手需要三次，而挥手需要四次呢？</p>
<p>本质上来说，双端都需要经过一次「分手」的过程，来保证自己和对端的状态正确。本着友好协商的态度，你先提出的分手，也要把最大的善意給对方，不能打了对方一个措手不及。你说不玩了就不玩了，那以后谁还敢和你玩。</p>
<p>下面这张图，是比较经典的 TCP 四次挥手的消息和双端状态的变化。</p>
<p><img src="https://s2.ax1x.com/2020/03/09/8pqN4A.png" alt="8pqN4A.png"></p>
<p>我们解释一下这张图：</p>
<ol>
<li><p>初始时双端还都处于 ESTABLISHED 状态并传输数据，某端可以主动发起「FIN」包准备断开连接，在这里的场景下，是客户端发起「FIN」请求。在发出「FIN」后，客户端进入 FIN-WAIT-1 状态。</p>
</li>
<li><p>服务端收到「FIN」消息后，回复「ACK」表示知道了，并从 ESTABLISHED 状态进入 CLOSED-WAIT 状态，开始做一些断开连接前的准备工作。</p>
</li>
<li><p>客户端收到之前「FIN」的回复「ACK」消息后，进入 FIN-WAIT-2 状态。而当服务端做好断开前的准备工作后，也会发送一个「FIN,ACK」的消息給客户端，表示我也好了，请求断开连接，并在发送消息后，服务端进入 LAST-ACK 状态。</p>
</li>
<li><p>客户端在收到「FIN,ACK」消息后，会立即回复「ACK」表示知道了，并进入 TIME_WAIT 状态，为了稳定和安全考虑，客户端会在 TIME-WAIT 状态等待 2MSL 的时长，最终进入 CLOSED 状态。</p>
</li>
<li><p>服务端收到客户端回复的「ACK」消息后，直接从 LAST-ACK 状态进入 CLOSED 状态。</p>
</li>
</ol>
<p>正常的经过四次挥手之后，双端都进入 CLOSED 状态，在此之后，双端正式断开了连接。</p>
<h2 id="TCP状态"><a href="#TCP状态" class="headerlink" title="TCP状态"></a>TCP状态</h2><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.</p>
<p>其中，对于我们日常的分析有用的就是前面的五个字段。</p>
<p>它们的含义是：</p>
<ul>
<li><p>SYN表示建立连接，</p>
</li>
<li><p>FIN表示关闭连接，</p>
</li>
<li><p>ACK表示响应，</p>
</li>
<li><p>PSH表示有 DATA数据传输，</p>
</li>
<li><p>RST表示连接重置。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>FrieBase调研</title>
    <url>/2020/02/12/FrieBase%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<p><strong>Firebase简介</strong></p>
<ul>
<li><a href="https://firebase.google.cn/docs/android/setup" target="_blank" rel="external">将 Firebase 添加到您的 Android 项目</a></li>
<li><a href="https://firebase.google.cn/docs/reference/android/packages" target="_blank" rel="external">FireBase Packges</a> </li>
</ul>
<p>Firebase是谷歌旗下的一个强大的工具，使用Firebase需要翻墙。Firebase提供了以下几大功能：</p>
<p><strong>app埋点：Analytics</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">应用内数据上报，帮助分析用户在app内的行为</div></pre></td></tr></table></figure></p>
<p><strong>云消息推送：Firebase Cloud Message</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">即：FCM，帮助app推送通知</div></pre></td></tr></table></figure></p>
<p><strong>身份验证：Authentication</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">方便的实现google登录，facebook登录，twitter登录，github登录，邮箱登录，电话登录以及自定义验证登录</div></pre></td></tr></table></figure></p>
<p><strong>实时数据库：Database和最新的Firestore</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">无需搭建服务器就能拥有一个实时的数据库，可以用来保存自己想要保存的任何数据。</div></pre></td></tr></table></figure></p>
<p><strong>云仓库：Cloud Storage</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">无需搭建服务器就能拥有一个云仓库，可以用来保存文件，如图片、音频、视频。不过免费版最多保存1个G的文件。</div></pre></td></tr></table></figure></p>
<p><strong>app崩溃报告：Firebase Crashlytics</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">自动记录应用内崩溃信息，只需简单的几步，就可以将Firebase Crashlytics添加到安卓工程中，然后Firebase Crashlytics就会自动的收集应用内崩溃信息，包括错误类型，代码定位等等，非常的方便实用</div></pre></td></tr></table></figure></p>
<p><strong>Firebase远程配置：Remote Config</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">相当于在服务器上设置几个key-value字段，我们在应用内可以请求这几个字段，通过value值设置我们的app。</div><div class="line"></div><div class="line">比如：将app页面的背景色放在远程配置中，启动app时拉取远程配置，根据远程配置中的value值设置页面背景色。这样就实现了动态配置app的背景色。</div><div class="line">读者可能会疑惑：使用实时数据库是不是也一样能实现这个功能？只要在数据库里设置几个用于app配置的字段就可以了。或者使用云仓库是不是也能实现这个功能？保存一个用于app配置的文件，每次打开app拉取此文件，然后根据读取的内容动态配置app就可以了?</div><div class="line"></div><div class="line">是的，这两种方法一样可以实现远程配置。只是用Firebase远程配置实现的话，对app的性能影响最低，实现起来也更优雅。</div></pre></td></tr></table></figure></p>
<p><strong>A/B测试</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">通过Firebase远程配置的A/B测试，帮助了解哪种配置用户更喜欢。</div><div class="line"></div><div class="line">比如：如果你想了解用户更喜欢红色风格的充值页面还是绿色风格的充值页面，那么你就可以使用A/B测试，在远程配置中设置A方案：红色和B方案：绿色，并设置A方案和B方案的比例，比如各占50%。这样用户拉取配置的时候，50%的用户会拉取到红色，50%的用户会拉取到绿色。再配合在用户充值时埋点，分析出红色页面和绿色页面的充值比例。这样你就可以选出更好的方案，获得更多的收益。</div></pre></td></tr></table></figure></p>
<p><strong>动态链接：Dynamic Link</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">生成一个根据不同的场景响应不同行为的链接。</div><div class="line"></div><div class="line">比如：你想要为app添加一个房间内邀请好友的功能，如果好友也安装了此app，点击分享链接就进入此房间，如果好友没有安装此app，那就跳转到Google Play下载页面（或者你自定义的任何页面），如果好友没有安装此app，而且他是苹果手机，那就跳转到苹果商店的应用下载页面。这个功能就可以使用Firebase的动态链接实现。</div></pre></td></tr></table></figure></p>
<p><strong>邀请：Firebase invites</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">邀请好友，基于Firebase动态链接。使用邀请功能让用户邀请好友下载或打开app更加的方便。</div></pre></td></tr></table></figure></p>
<p><strong>AdWords</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">帮助投放app，就是给钱让谷歌给你打广告。主要有以下几种渠道：</div><div class="line"></div><div class="line"><span class="number">1</span>. 买关键词</div><div class="line"></div><div class="line">平时我们用搜索引擎的时候，搜索的结果中一般都有几条广告。这就是广告主买关键词的作用。广告主买一些关键词，当用户用谷歌搜索这些关键词的时候，就展示你的app下载链接。</div><div class="line"></div><div class="line">买个Google Play关键词，用户一搜Google Play就搜到你的应用了，是不是很舒服。当然，没有这么简单，你想得到别人也想得到。买Google Play关键词的人非常多，Google的策略大致就是价高者得。所以越火的关键词就会越贵，想要赚钱就需要权衡广告投入成本和应用的收益。</div><div class="line"></div><div class="line"><span class="number">2</span>. 买应用内广告或网页广告</div><div class="line"></div><div class="line">访问一些app或者网站时，边边角角会有一些广告弹出，这也是广告主买的。</div></pre></td></tr></table></figure></p>
<p><strong>AdMob</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在自己的app里面打广告，赚取收益。和AdWords对应着看，举个例子：你用AdWords买一个广告位，展示一千次自己app的广告给了谷歌1美元，再使用AdMob展示别人的广告赚取收益，展示了一千次赚取了0.1美元。</div><div class="line"></div><div class="line">以上只是Firebase的大部分功能，Firebase还有机器学习套件，网页托管等等功能。</div></pre></td></tr></table></figure></p>
<h2 id="接入Firebase-Crashlytics"><a href="#接入Firebase-Crashlytics" class="headerlink" title="接入Firebase Crashlytics"></a><strong>接入Firebase Crashlytics</strong></h2><p><a href="https://github.com/firebase/quickstart-android" target="_blank" rel="external">官方Demo</a></p>
<p><a href="https://firebase.google.com/docs/crashlytics/?hl=zh-CN" target="_blank" rel="external">官方文档</a></p>
<p><a href="https://console.firebase.google.com/project/_/crashlytics" target="_blank" rel="external">Firebase 控制台</a></p>
<h4 id="一、配置Android应用并下载google-service-json文件"><a href="#一、配置Android应用并下载google-service-json文件" class="headerlink" title="一、配置Android应用并下载google-service.json文件"></a>一、配置Android应用并下载google-service.json文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在Firebase控制台新建项目（需要使用Google账户登录），配置好Android应用后下载google-service.json文件，将google-service.json文件添加到项目的app目录下即可。</div></pre></td></tr></table></figure>
<ul>
<li>添加项目</li>
<li>添加Android应用</li>
<li>下载google-service.json文件加入项目</li>
</ul>
<h4 id="二、集成Crashlytics-SDK"><a href="#二、集成Crashlytics-SDK" class="headerlink" title="二、集成Crashlytics SDK"></a>二、集成Crashlytics SDK</h4><ul>
<li>项目级 build.gradle：添加classpath和maven</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line"><span class="keyword">buildscript</span> &#123;</div><div class="line">    <span class="keyword">repositories</span> &#123;</div><div class="line">        ...</div><div class="line">        maven &#123; url <span class="string">'https://maven.google.com'</span>  &#125;</div><div class="line">        maven &#123; url <span class="string">'https://maven.fabric.io/public'</span> &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">dependencies</span> &#123;</div><div class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.1.3'</span></div><div class="line">        <span class="keyword">classpath</span> <span class="string">'com.google.gms:google-services:4.1.0'</span></div><div class="line">        <span class="keyword">classpath</span> <span class="string">'io.fabric.tools:gradle:1.25.1'</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">allprojects</span> &#123;</div><div class="line">    <span class="keyword">repositories</span> &#123;</div><div class="line">        ...</div><div class="line">        maven &#123; url <span class="string">'https://maven.google.com'</span> &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<ul>
<li>应用级 build.gradle(&lt;项目&gt;/&lt;应用模块&gt;/build.gradle)，添加implementation和apply plugin</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//Twitter将Fabric卖给Google了</span></div><div class="line">apply plugin: <span class="string">'io.fabric'</span></div><div class="line">android&#123;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    ...</div><div class="line">    implementation <span class="string">'com.google.firebase:firebase-core:16.0.3'</span></div><div class="line">    implementation <span class="string">'com.crashlytics.sdk.android:crashlytics:2.9.5'</span></div><div class="line">&#125;</div><div class="line">apply plugin: <span class="string">'com.google.gms.google-services'</span></div></pre></td></tr></table></figure>
<p>做完这一步后，就可以启动app并制造一个crash，到Firebase 控制台中的 Crashlytics页面查看是否有数据上报即可。Firebase的数据上报实时性很高，尤其是新建的项目，数据量很少，出现crash后几秒钟就能在Firebase Crashlytics的平台上看到了。</p>
<p>建议在debug模式下添加 ext.alwaysUpdateBuildId = false标志来阻止 Crashlytics 不断更新其构建 ID，优化日常开发的编译速度。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line">android &#123;</div><div class="line">  ...</div><div class="line">  buildTypes &#123;</div><div class="line">    debug &#123;</div><div class="line">      ext.alwaysUpdateBuildId = <span class="keyword">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>（可选） Crashlytics SDK NDK Crash监控</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><div class="line">Firebase Crashlytics的官方文档只列出来了Java代码的Crash监控使用方式，并没有提及NDK Crash的监控。</div><div class="line">对于大部分Android开发者来说，NDK的Crash也确实没有监控的必要，但是考拉这边用了很多第三方so库，这些so库也是有必要监控起来的。</div><div class="line">Firebase Crashlytics是由Firebase收购Fabric而来的项目，技术方案也几乎没有变化，所以可以用Fabric监控NDK Crash的使用方式使用Firebase Crashlytics。</div><div class="line">Fabric NDK Crash Reporting</div><div class="line"></div><div class="line">在应用级 build.gradle 中，添加 Crashlytics NDK Crash Reporting 相关配置</div><div class="line"></div><div class="line">apply plugin: <span class="string">'com.android.application'</span></div><div class="line">apply plugin: <span class="string">'io.fabric'</span></div><div class="line"></div><div class="line"><span class="comment">// set NDK Crash Reporting enable</span></div><div class="line">crashlytics &#123;</div><div class="line">    enableNdk <span class="keyword">true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">dependencies</span> &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    implementation <span class="string">'com.google.firebase:firebase-core:16.0.6'</span></div><div class="line"></div><div class="line">    implementation <span class="string">'com.crashlytics.sdk.android:crashlytics:2.9.8'</span></div><div class="line">    <span class="comment">// Add ndk dependency</span></div><div class="line">    implementation <span class="string">'com.crashlytics.sdk.android:crashlytics-ndk:2.0.5'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在manifest中声明Crashlytics手动初始化</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!--手动初始化firebase Crashlytics sdk--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"firebase_crashl</span></div><div class="line">        ytics_collection_enabled"</div><div class="line">    <span class="attr">android:value</span>=<span class="string">"false"</span>/&gt;</div></pre></td></tr></table></figure>
<p>根据自身app启动流程，选择合适时机手动初始化Crashlytics<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureCrashReporting</span><span class="params">()</span> </span>&#123;</div><div class="line">        CrashlyticsCore crashlyticsCore = <span class="keyword">new</span> CrashlyticsCore.Builder()</div><div class="line">                .disabled(BuildConfig.DEBUG)</div><div class="line">                .build();</div><div class="line">        Fabric.with(<span class="keyword">this</span>, <span class="keyword">new</span> Crashlytics.Builder().core(crashlyticsCore).build());</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果是本地源码编译的so而不是直接使用第三方提供的so，可以生成并上传符号表来辅助分析crash信息，执行 ./gradlew crashlyticsUploadSymbolsRelease即可上传符号表。</p>
<h4 id="三、错误数据上报分析"><a href="#三、错误数据上报分析" class="headerlink" title="三、错误数据上报分析"></a>三、错误数据上报分析</h4><p><img src="https://img-blog.csdn.net/20180906100828240?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FscGluaXN0V2FuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="错误面板"></p>
<p>通过以上步骤的配置，现在Firebase Crashlytics已经可以正常工作了。并且还附带了发生Crash的时间，机型，系统版本，应用版本等信息以供分析。</p>
<p><img src="https://img-blog.csdnimg.cn/20190127174334220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdjaGVueHVhbmZlbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>除了这些基础信息，我们可以自定义添加更多数据,比如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//用户id</span></div><div class="line">Crashlytics.setUserIdentifier(builder.getUserId());</div><div class="line"><span class="comment">//用户渠道</span></div><div class="line">Crashlytics.setString(<span class="string">"Channel"</span>, builder.getChannelInfo());</div><div class="line"><span class="comment">//用户补丁版本</span></div><div class="line">Crashlytics.setString(<span class="string">"Version"</span>, builder.getUserTag());</div><div class="line"><span class="comment">//用户当前WebView UA</span></div><div class="line">Crashlytics.setString(<span class="string">"WebView UA"</span>, WebViewSettings.getUserAgent());</div><div class="line"><span class="comment">//打包机名称</span></div><div class="line">Crashlytics.setString(<span class="string">"BuildHost"</span>, BuildInfo.BUILD_HOST);</div><div class="line"><span class="comment">//打包时间</span></div><div class="line">Crashlytics.setString(<span class="string">"BuildTime"</span>, BuildInfo.BUILD_TIME);</div><div class="line"><span class="comment">//最新提交commit id</span></div><div class="line">Crashlytics.setString(<span class="string">"GitLog"</span>, BuildInfo.BUILD_GIT_LOG);</div></pre></td></tr></table></figure>
<p>这些自定义的数据可以在，Firebase Crashlytics的“键”选项卡下面看到。<br><img src="https://img-blog.csdnimg.cn/20190127175450347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdjaGVueHVhbmZlbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>通过<a href="">setUserIdentifier</a>所设置的用户Id还可以用于搜索。</p>
<p><img src="https://img-blog.csdnimg.cn/20190127175929869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdjaGVueHVhbmZlbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>还可以通过<a href="">Crashlytics.log</a>方法，打入自定义日志用于分析。</p>
<p><img src="https://img-blog.csdnimg.cn/20190127180206168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdjaGVueHVhbmZlbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>开发过程中，还会遇到通过<a href="">try catch</a>捕获了异常，不造成崩溃，但是又希望能够统计上报该异常的情况。这个时候，可以使用<a href="">Crashlytics.logException(throwable)</a>方法将异常统计上来。<br>在Firebase的过滤条件中选择，不严重的事件类型，即可过滤该异常。</p>
<p><img src="https://img-blog.csdnimg.cn/20190127180623407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmdjaGVueHVhbmZlbmc=,size_16,color_FFFFFF,t_70" alt=""></p>
<p>如果之前的项目使用的是Fabric Crashlytics，那你可以直接使用<a href="https://fabric.io/firebase_migration" target="_blank" rel="external">Fabric迁移流程</a>来快速迁移到Firebase Crashlytics。</p>
<h2 id="Firebase比较有用的地方"><a href="#Firebase比较有用的地方" class="headerlink" title="Firebase比较有用的地方"></a><strong>Firebase比较有用的地方</strong></h2><ul>
<li><p>支持对每个用户设置唯一标识，我们可以用服务传递回来的用户id 或者 手机号码，然后再排查问题的时候通过这个唯一标识去定位，很方便。</p>
<p>  <a href="">Crashlytics.setUserIdentifier(“user123456789”);</a></p>
</li>
<li><p>添加自定义日志消息</p>
<p>  <a href="">Crashlytics.log(Log.DEBUG, “customCrashLog” , e.toString());</a></p>
<p>  第一个参数int 类型，可以填info，debug，error ；我们可以通过这些 类型，区分日志的重要程度；第二个参数为 自定义 key。</p>
<p>  要为导致崩溃的事件提供更多背景信息，您可以向您的应用添加自定义 Crashlytics 日志。Crashlytics 会将日志与您的崩溃数据相关联，并在 <a href="https://console.firebase.google.com/project/_/crashlytics" target="_blank" rel="external">Firebase 控制台</a>中显示这些日志。</p>
<p>  在 Android 上，请使用 Crashlytics.log 来帮助查明问题。Crashlytics.log 既可以将日志写入崩溃报告并执行 Log.println()，也可以仅继续写入下一个崩溃报告：</p>
<ul>
<li>崩溃报告和 Log.println：Crashlytics.log(Log.DEBUG, “tag”, “message”);</li>
<li>仅崩溃报告：Crashlytics.log(“message”);</li>
</ul>
</li>
<li><p>记录非严重异常</p>
<p>  除了自动报告您的应用中出现的崩溃，Crashlytics 还可让您记录非严重异常。</p>
<p>  在 Android 上，这意味着您可以在应用的 catch 块中记录已捕获到的异常：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    methodThatThrows();</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    Crashlytics.logException(e);</div><div class="line">    <span class="comment">// handle your exception here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  所有记录的异常在 Firebase 控制台中均显示为非严重问题。问题摘要中会包含您通常从崩溃中可以获得的所有状态信息，以及按 Android 版本和硬件设备细分的数据。</p>
<p>  Crashlytics 在一个专用的后台线程中处理异常，所以对您的应用性能的影响极小。为了减少用户的网络流量，Crashlytics 会将已记录的异常汇集到一起，并在下次应用启动时批量发送这些异常。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>SonarQube gradle plugin for Android</title>
    <url>/2020/01/16/SonarQube-gradle-plugin-for-Android/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<blockquote>
<p><a href="https://github.com/SonarSource/sonar-scanner-gradle" target="_blank" rel="external">User documentation</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文包含了官方SonarQube Plugin介绍、自定义适合多组件plugin、官方SonarQube Plugin实现多组件等内容，你可以直接使用tech-sonar plugin来实现多组件工程sonar统计。其中，tech-sonar插件是基于<a href="https://github.com/SonarSource/sonar-scanner-gradle" target="_blank" rel="external">官方SonarQube plugin</a>二次开发的。</p>
<h1 id="1、SonarQube-Plugin如何工作"><a href="#1、SonarQube-Plugin如何工作" class="headerlink" title="1、SonarQube Plugin如何工作"></a>1、SonarQube Plugin如何工作</h1><p>当将插件应用于项目时，他将向该项目添加sonarqube task，它还将添加到项目及其所有子项目SonarQube extension。对于多模块项目，该插件仅适用于调用它的第一个项目。建议：在<code>subprojects {}</code>中添加sonar配置对所有子module生效！</p>
<ul>
<li><p>SonarQube Extension</p>
<p>  SonarQube扩展可以使用DSL轻松配置项目，你可以在DSL里设置自定义属性，详细使用属性请看<a href="https://docs.sonarqube.org/latest/analysis/analysis-parameters/" target="_blank" rel="external">这里</a>。</p>
</li>
<li><p>SonarQube Task </p>
<p>  SonarQube task的名称为<code>sonarqube</code>，因此可以通过调用<code>./gradlew sonarqube</code>来执行。他从项目及其所有子项目中收集信息，生成分析属性。然后，它使用所有这些属性运行SonarQube分析。task依赖于于所有项目的compile和test task（跳过的项目除外）。如果跳过所有项目（通过向sonarqube DSL添加skipProject = true），则不会执行分析。</p>
</li>
</ul>
<h1 id="2、tech-sonar-plugin"><a href="#2、tech-sonar-plugin" class="headerlink" title="2、tech-sonar plugin"></a>2、tech-sonar plugin</h1><p>对于目前多组件结构的Android工程，官方SonarQube Plugin插件只能实现项目整体统计，不能单独生成某个模块的报告。因此，在官方plugin基础上开发了适合多组件的tech-sonar 插件。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="1-添加依赖和配置"><a href="#1-添加依赖和配置" class="headerlink" title="1. 添加依赖和配置"></a>1. 添加依赖和配置</h3><p>根project build.gradle 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">    classpath <span class="string">'xxxx'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">sonarConfig &#123;</div><div class="line">    onlyFullReport = findProperty(<span class="string">'sonarOnlyFull'</span>) ?: <span class="keyword">false</span> </div><div class="line">    hostUrl = <span class="string">'xxxx'</span></div><div class="line">    login = <span class="string">'xxx'</span></div><div class="line">    projectKey = <span class="string">'xxx'</span></div><div class="line">    projectName = <span class="string">'xxxx'</span></div><div class="line">    projectVersion = VERSION_NAME</div><div class="line">    ignoredProjects = [<span class="string">'xxxx'</span>, <span class="string">'xxxx'</span>]</div><div class="line">    enableTestTask = <span class="keyword">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字段说明：</p>
<ul>
<li>onlyFullReport：一个标记，用来指示tech-sonar plugin内部来执行task使用</li>
<li>hostUrl：服务端url</li>
<li>login：登录签名</li>
<li>projectKey：总工程key，子模块的key默认为 「rootProjectName:moduleName」</li>
<li>projectName：总工程name，子模块的name默认为 「rootProjectName:moduleName」</li>
<li>projectVersion：项目版本号</li>
<li>ignoredProjects：要忽略的模块</li>
<li>enableTestTask：是否要执行测试任务</li>
</ul>
<h3 id="2-执行"><a href="#2-执行" class="headerlink" title="2. 执行"></a>2. 执行</h3><ul>
<li>./gradlew sonarqube -PsonarOnlyFull=true 生成项目sonar总报告，但不包含所有module sonar总报告</li>
<li>./gradlew sonarFullReport 生成所有module的sonar报告，但不包含项目总报告</li>
<li>./gradlew :moduleName:sonarqube 生成单个module的sonar报告</li>
</ul>
<h3 id="3-Jenkins配置"><a href="#3-Jenkins配置" class="headerlink" title="3. Jenkins配置"></a>3. Jenkins配置</h3><p>项目-&gt; Configure -&gt; Build -&gt; 执行 shell 添加如下command即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">./gradlew clean &amp; ./gradlew sonarqube -PsonarOnlyFull=<span class="keyword">true</span> &amp; ./gradlew sonarFullReport</div></pre></td></tr></table></figure>
<hr>
<h1 id="3、官方SonarQube实现多模块方案"><a href="#3、官方SonarQube实现多模块方案" class="headerlink" title="3、官方SonarQube实现多模块方案"></a>3、官方SonarQube实现多模块方案</h1><p><em>提示：这部分内容只是为了展示官方插件实现多组件工程统计，实现起来比较丑陋，如果不感兴趣，可以忽略这部分！</em></p>
<h2 id="3-1、单个module"><a href="#3-1、单个module" class="headerlink" title="3.1、单个module"></a>3.1、单个module</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 当要生成2.3项目总sonar结果，需要去掉这个依赖plugin，在根module的build.gradle中添加一次即可！</span></div><div class="line">apply plugin: <span class="string">'org.sonarqube'</span></div><div class="line"></div><div class="line"><span class="comment">// List of modules that skip by sonarqube plugin</span></div><div class="line">def ignoredBySonar = [</div><div class="line">        <span class="string">'app'</span></div><div class="line">]</div><div class="line"></div><div class="line">sonarqube &#123;</div><div class="line">    properties &#123;</div><div class="line">        property <span class="string">"sonar.host.url"</span>, <span class="string">"xxx"</span></div><div class="line">        property <span class="string">"sonar.login"</span>, <span class="string">"xxx"</span></div><div class="line">        property <span class="string">"sonar.language"</span>, <span class="string">"java"</span></div><div class="line">        <span class="comment">// 工程名：根工程:module名称</span></div><div class="line">        property <span class="string">"sonar.projectName"</span>, <span class="string">"$&#123;rootProject.name&#125;:$&#123;project.name&#125;"</span></div><div class="line">        property <span class="string">"sonar.projectKey"</span>, <span class="string">"$&#123;rootProject.name&#125;:$&#123;project.name&#125;"</span></div><div class="line">        <span class="comment">// 项目版本号</span></div><div class="line">        property <span class="string">"sonar.projectVersion"</span>, <span class="string">'1.0.0'</span></div><div class="line"></div><div class="line">        <span class="comment">// Defines where the java files are</span></div><div class="line">        property <span class="string">"sonar.sourceEncoding"</span>, <span class="string">"UTF-8"</span></div><div class="line">        <span class="comment">//property "sonar.sources", "src/main/java"</span></div><div class="line">        properties[<span class="string">"sonar.sources"</span>] = android.sourceSets.main.java.srcDirs</div><div class="line"></div><div class="line">        <span class="comment">// Analyze tests classes</span></div><div class="line">        property <span class="string">"sonar.exclusions"</span>, <span class="string">"src/test/java, src/androidTest/java"</span></div><div class="line">        property <span class="string">"sonar.java.test.binaries"</span>, <span class="string">"build/intermediates/classes/debug"</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    skipProject = ignoredBySonar.contains(project.name)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// disable all test task for sub project</span></div><div class="line">project.afterEvaluate &#123;</div><div class="line">    project.tasks.all &#123; task -&gt;</div><div class="line">        def ignoreTask = task.name.contains(<span class="string">"test"</span>) || task.name.contains(<span class="string">"Test"</span>)</div><div class="line">        <span class="keyword">if</span> (ignoreTask) &#123;</div><div class="line">            <span class="comment">//println "disable test task  : + $&#123;task.name&#125;"</span></div><div class="line">            task.setEnabled <span class="keyword">false</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">task <span class="title">sonarExec</span><span class="params">(dependsOn: [<span class="string">'sonarqube'</span>])</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">gradle.ext.ignoredBySonar = ignoredBySonar</div></pre></td></tr></table></figure>
<p>以上配置可以单独写到一个xx.gradle文件（如android-sonarqube.gradle），并依赖到root project build.gradle的subprojects中。即可生成单个module的sonar结果，如：<code>./gradlew :moduleOne:sonarqube</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">subprojects &#123;</div><div class="line">    apply from: rootProject.getRootDir().getAbsolutePath() + <span class="string">"/scripts/sonar/android-sonarqube.gradle"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-2、一次所有单个module"><a href="#3-2、一次所有单个module" class="headerlink" title="3.2、一次所有单个module"></a>3.2、一次所有单个module</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">apply plugin: <span class="string">'org.sonarqube'</span></div><div class="line"></div><div class="line"><span class="function">task <span class="title">sonarFullReport</span><span class="params">()</span> </span>&#123;</div><div class="line">    group = <span class="string">'Reporting'</span></div><div class="line">    description = <span class="string">'Generates an aggregate report from all subprojects'</span></div><div class="line"></div><div class="line">    <span class="comment">// Get list of projects which should be included in the report</span></div><div class="line">    def projects = []</div><div class="line">    subprojects.each &#123; prj -&gt;</div><div class="line">        <span class="keyword">if</span> (!gradle.ignoredBySonar.contains(prj.name)) &#123;</div><div class="line">            projects.add(prj)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//noinspection GrUnresolvedAccess</span></div><div class="line">    dependsOn(projects.sonarExec)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上配置可以单独写到一个xx.gradle文件（如android-sonarqube-full.gradle），并依赖到root project build.gradle中。即可一次生成所有单个module的sonar结果，等同于分开执行<code>./gradlew moduleOne:sonarqube</code>，<code>./gradlew moduleTwo:sonarqube</code>…</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">apply from: <span class="string">'scripts/sonar/android-sonarqube-full.gradle'</span></div></pre></td></tr></table></figure>
<h2 id="3-3、汇总"><a href="#3-3、汇总" class="headerlink" title="3.3、汇总"></a>3.3、汇总</h2><p>Generates an aggregate report from all subprojects</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">apply plugin: <span class="string">'org.sonarqube'</span></div><div class="line">subprojects &#123;</div><div class="line">    <span class="comment">// 配置所有子module sonar DSL</span></div><div class="line">    apply from: rootProject.getRootDir().getAbsolutePath() + <span class="string">"/scripts/sonar/android-sonarqube.gradle"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Generates an aggregate report from all subprojects.</div><div class="line"> */</div><div class="line">sonarqube &#123;</div><div class="line">    properties &#123;</div><div class="line">        property <span class="string">"sonar.host.url"</span>, <span class="string">"xxxx"</span></div><div class="line">        property <span class="string">"sonar.login"</span>, <span class="string">"xxx"</span></div><div class="line">        property <span class="string">"sonar.language"</span>, <span class="string">"java"</span></div><div class="line">        property <span class="string">"sonar.projectName"</span>, <span class="string">"xxx"</span></div><div class="line">        property <span class="string">"sonar.projectKey"</span>, <span class="string">"xxx"</span></div><div class="line">        property <span class="string">"sonar.projectVersion"</span>, VERSION_NAME</div><div class="line"></div><div class="line">        property <span class="string">"sonar.sourceEncoding"</span>, <span class="string">"UTF-8"</span></div><div class="line">        property <span class="string">"sonar.sources"</span>, <span class="string">"src/main/java"</span></div><div class="line">        property <span class="string">"sonar.exclusions"</span>, <span class="string">"src/test/java, src/androidTest/java"</span></div><div class="line">        property <span class="string">"sonar.java.test.binaries"</span>, <span class="string">"build/intermediates/classes/debug"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成项目sonar总报告，需要为所有module和根module配置sonar DSL，在根module的build.gradle配置，执行<code>./gradlew sonarqube</code>即可生成当前项目sonar总报告。</p>
<h1 id="4、问题"><a href="#4、问题" class="headerlink" title="4、问题"></a>4、问题</h1><ul>
<li>Q：<code>Cannot add extension with name &#39;sonarqube&#39;, as there is an extension already registered with that name.</code></li>
</ul>
<blockquote>
<p>由于sonarqube plugin插件只能在工程中apply一次，所以上面抽取的2个文件android-sonarqube.gradl和android-sonarqube-full.gradle都关联了插件，会报错。目前还不能同时要统计2.2、2.3，这个问题目前还在研究中。。。也可以在Stack Overflow上关注这个 <a href="https://stackoverflow.com/questions/48866378/make-sonarqube-gradle-plugin-available-in-root-project-and-subprojects" target="_blank" rel="external">问题</a>！<br>「后续」：这个问题已经通过tech-sonar plugin解决！！！</p>
</blockquote>
<h1 id="5、参考"><a href="#5、参考" class="headerlink" title="5、参考"></a>5、参考</h1><ul>
<li><a href="https://github.com/sogilis/sonarqube-for-android-example/blob/master/android-sonarqube.gradle" target="_blank" rel="external">sample-android-sonarqube</a></li>
<li><a href="https://github.com/SonarSource/sonarqube" target="_blank" rel="external">SonarSource/sonarqube</a></li>
<li><a href="https://github.com/SonarSource/sonar-scanner-gradle" target="_blank" rel="external">SonarSource/sonar-scanner-gradle</a></li>
<li><a href="https://docs.sonarqube.org/display/SCAN/Analyzing+with+SonarQube+Scanner+for+Gradle" target="_blank" rel="external">User documentation</a></li>
<li><a href="https://docs.sonarqube.org/latest/analysis/analysis-parameters/" target="_blank" rel="external">SonarQubeExtension-analysis properties</a></li>
<li><a href="https://github.com/weikipeng/Android-SonarQube-MultiProject/blob/master/build.gradle" target="_blank" rel="external">weikipeng/Android-SonarQube-MultiProject</a></li>
<li><a href="https://github.com/hallatech/gradle-sonar-multi-atg-project/blob/master/sonar.gradle" target="_blank" rel="external">sonar.gradle</a></li>
<li><a href="https://github.com/sogilis/sonarqube-for-android-example/blob/master/android-app/build.gradle" target="_blank" rel="external">android-app/build.gradle</a></li>
<li><a href="https://github.com/hallatech/gradle-sonar-multi-atg-project/blob/master/sonar.gradle" target="_blank" rel="external">sonar.gradle</a></li>
<li><a href="https://medium.com/@nielsz/android-quality-with-sonarqube-bf907e614aed" target="_blank" rel="external">Medium/Android quality with SonarQube</a></li>
<li><a href="https://github.com/hallatech/gradle-sonar-multi-atg-project/blob/master/README.md" target="_blank" rel="external">hallatech/gradle-sonar-multi-atg-project</a></li>
</ul>
<h1 id="6、联系我"><a href="#6、联系我" class="headerlink" title="6、联系我"></a>6、联系我</h1><ul>
<li>Email: hy04150829@gmail.com</li>
</ul>
]]></content>
      <categories>
        <category>Plugin</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化之内存优化-操作篇</title>
    <url>/2019/12/30/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E6%93%8D%E4%BD%9C%E7%AF%87/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>内存泄漏的排查我们主要结合以下两个工具:</p>
<ul>
<li>Memory Profiler</li>
<li><a href="https://github.com/Tencent/matrix" target="_blank" rel="external">Matrix</a> &amp; <a href="https://www.eclipse.org/downloads/download.php?file=/mat/1.9.1/rcp/MemoryAnalyzer-1.9.1.20190826-macosx.cocoa.x86_64.zip" target="_blank" rel="external">MAT</a></li>
</ul>
<h2 id="Memory-Profiler使用"><a href="#Memory-Profiler使用" class="headerlink" title="Memory Profiler使用"></a><strong>Memory Profiler使用</strong></h2><ul>
<li><p>如何打开Memory Profiler？</p>
<p>  Android Studio -&gt; View -&gt; Tool Windows -&gt; Profiler</p>
<p>  <a href="https://imgchr.com/i/lsU8iD" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/06/lsU8iD.md.jpg" alt="lsU8iD.md.jpg"></a></p>
<p>  最后进入Memory Profiler</p>
<p>  <a href="https://imgchr.com/i/lsUJRH" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/06/lsUJRH.md.jpg" alt="lsUJRH.md.jpg"></a></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line">为什么要去观察应用内存的使用情况？</div><div class="line"></div><div class="line">之前也提到了内存泄漏和抖动,会触发频繁的GC，导致应用卡顿，anr，oom问题</div><div class="line"></div><div class="line">在Android系统内存管理上，它是提供一套内存回收机制去</div><div class="line"></div><div class="line">回收无用的对象，其实就是Dalvik虚拟机的垃圾回收器，</div><div class="line"></div><div class="line">当垃圾回收器启动回收机制的时候，其实会对应用的运行产</div><div class="line"></div><div class="line">生一点影响，但是这种影响来说一般微乎其微，察觉不到。</div><div class="line"></div><div class="line">但是如果你的内存分配比垃圾回收快很多，这种情况可能导</div><div class="line"></div><div class="line">致垃圾回收器回收内存不及时，从而导致应用出现卡顿的现</div><div class="line"></div><div class="line">象.(这其实就是内存抖动所产生的影响). 另外一个问题就</div><div class="line"></div><div class="line">是内存泄漏，内存的持续泄漏可能导致内存溢出，从而app</div><div class="line"></div><div class="line">运行出现outofmem异常。</div><div class="line"></div><div class="line">Memory Profiler通过以下方面防治上面出现的问题：</div><div class="line"></div><div class="line"><span class="number">1</span>，观察不必要的内存分配。（这种内存分配导致效率降低）</div><div class="line"></div><div class="line"><span class="number">2</span>，Dump the Java heap 去观察指定时间对象的在内存中</div><div class="line"></div><div class="line">的分配情况，若干次Dump能够帮助你发现内存泄漏</div><div class="line"></div><div class="line"><span class="number">3</span>，测试极端的用户交互情况下的内存分配（比如说狂点某个</div><div class="line"></div><div class="line">请求按钮），看看内存使用情况如何，是否出现内存抖动.</div></pre></td></tr></table></figure>
</li>
<li><p>Memory Profiler主面板介绍</p>
<p>  <a href="https://imgchr.com/i/lsUGJe" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/06/lsUGJe.md.jpg" alt="lsUGJe.md.jpg"></a></p>
<ol>
<li><p>添加需要观察的线程</p>
</li>
<li><p>开始／停止记录内存分配情况</p>
</li>
<li>强制内存回收按钮</li>
<li>Dump the Java heap (获取内存快照)</li>
<li>缩小／放大时间线</li>
<li>实时播放内存分配情况（这个按钮点下试试便清楚了）</li>
<li>发生一些事件的记录(如Activity的跳转，事件的输入，屏幕的旋转)</li>
<li><p>内存使用时间线包含多少内存被使用（左边的y轴），还有顶上的颜色标记内存的类型，<br>右边的y轴表明分配对象的个数,另外出现垃圾回收事件会有一个小图标.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">关于顶部的几种内存类型介绍：</div><div class="line"></div><div class="line">Java : java代码分配的内存</div><div class="line"></div><div class="line">Native:c/c++代码分配的内存(有时候其实并没有使用到c/c++代码,但还是会有Native的内存分配，因为Android Framework会去通过java代码访问一些需要使用Native的资源，如图像资源Bitmap)</div><div class="line"></div><div class="line">Graphics:图像缓存等，包括GL surfaces, GL textures等.</div><div class="line"></div><div class="line">Stack:栈内存（包括java和c/c++）</div><div class="line"></div><div class="line">Code:代码的内存分配（例如代码，资源，libs等等）</div><div class="line"></div><div class="line">Other:这个是连系统都不知道是什么类型的内存，放在这里.</div><div class="line"></div><div class="line">Allocated: java分配的对象个数 (在Android7.1和以下的设备，这个计数是在设备连接后开始，所以并不是app启动时候的计数。Android8.0或更高，在系统里面内置的Profiler工具，所以无论什么时候连接，都是app启动时候的计数)</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>如何观察对象分配的情况？</p>
<p>  我们需要关注如下信息：</p>
<ol>
<li><p>什么类型对象被分配，分配了多大的空间</p>
</li>
<li><p>对象分配的栈调用，是在哪个线程中调用的</p>
</li>
<li><p>对象的释放时间</p>
<p><a href="https://imgchr.com/i/lsyHpV" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/06/lsyHpV.md.jpg" alt="lsyHpV.md.jpg"></a></p>
<p>下面是重头戏，查看对象分配情况，也就是我们前面提到需要关注什么类型对象被分配，分配了多大的空间。</p>
<ol>
<li>在Class Name列看一下有没有异常分配的对象，个数很多，占用内存比较大。点击头部Class Name进行一个按字母排序操作，点击Class Name面板下面的类名可以看到Instance View面板详细的对象信息.</li>
</ol>
</li>
<li><p>点击Instance View面板中的对象，可以看到调用栈信息和调用的线程.</p>
</li>
<li>在Call Stack中点击可以跳转到实际的代码.<br>以上是捕获一段时间的内存分配情况，如果想捕获一瞬间的内存分配需要用到heap dump.</li>
</ol>
</li>
<li><p>捕获一个heap dump</p>
<p>  捕获一个heap dump观察某一个时间点的对象分配情况，注<br>  意之前介绍是一个时间段，而这里是时间点。它有助于帮助我<br>  们分析内存泄漏，比如当我应用使用一段时候后，捕获了一个<br>  heap dump，这个heap dump里面发现了并不应该存在的对<br>  象分配情况，这说明是存在内存泄漏的。通过一个heap<br>  dump你可以看到以下内容：</p>
<ol>
<li><p>你的app分配了什么样的对象类型，每个类型分配了多少个数和大小。</p>
</li>
<li><p>使用了多少内存</p>
</li>
<li>每个对象在代码中的使用位置</li>
<li><p>对象分配的调用栈情况</p>
<p>捕获一个heap dump在工具栏中点击之前面板介绍中的按钮<br>4，稍等一会儿便能够看到类似于之前记录内存分配后的面板弹出。</p>
<p><a href="https://imgchr.com/i/lsWU6P" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/06/lsWU6P.md.png" alt="lsWU6P.md.png"></a></p>
<p>在上面图片中可以看到如下列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Class Name : 这个很好理解，就是类名</div><div class="line"></div><div class="line">Alloc Count : 对象个数</div><div class="line"></div><div class="line">Native Size : c/c++层内存大小(bytes)</div><div class="line"></div><div class="line">Shallow Size : java层内存大小(bytes)</div><div class="line"></div><div class="line">Retained Size : 这个是这个类中所引用到的对象的总大小 * 该类对象的个数</div></pre></td></tr></table></figure>
<p>当点击app heap下拉列表会出现3个选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Default heap: 默认堆</div><div class="line"></div><div class="line">App heap: app中的堆分配</div><div class="line"></div><div class="line">Image heap: 图像的堆分配</div><div class="line"></div><div class="line">Zygote heap: 这个按照官方的解释是来自安卓系统fork进程的地方产生的写数据备份</div></pre></td></tr></table></figure>
<p>当点击Arrange by class下拉列表会出现3个选项</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Arrange by class:根据类名进行分组</div><div class="line"></div><div class="line">Arrange by package:根据包名进行分组</div><div class="line"></div><div class="line">Arrange by callstack:根据调用栈进行分配</div></pre></td></tr></table></figure>
<p>当我们点击其中一个类的时候会弹出一个新的Instance View面板，见上图:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">每列中包括以下：</div><div class="line"></div><div class="line">Depth: GC root到达该实例的最短跳数.</div><div class="line"></div><div class="line">Native Size: c/c++层中内存的大小(bytes)</div><div class="line"></div><div class="line">Shallow Size:java层内存大小(bytes)</div><div class="line"></div><div class="line">Retained Size:这个类中所引用到的对象的总大小(bytes)</div><div class="line"></div><div class="line">另外补充一下，heap dump是看不到调用栈信息的.也就是时间段图中的Call Stack面板.</div><div class="line"></div><div class="line">分析你的heap,按照一下步骤.</div><div class="line"></div><div class="line">1,浏览Class Name列表,看看有没有大量对象存在，并且</div><div class="line">这些对象你认为是不应该存在的，可能存在内存泄漏的情况. 点击类名可以看到详细的对象信息.</div><div class="line"></div><div class="line">2,在这个Instance View面板中，点击一个实例References面板就会显示出来，里面都是使用该Instance的Reference，点击剪头可以看到引用它的所有区域。点击鼠标右键可以选择go to instance去看到引用该引用的引用，或者jump to source去看调用的源代码.</div><div class="line"></div><div class="line">另外heap dump也是可以保存成为HPROF文件的,点击上图左侧Heap Dump按钮即可保存起来，用于以后分析，或用作其它工具分析(MAT).</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h2 id="MAT的使用"><a href="#MAT的使用" class="headerlink" title="MAT的使用"></a><strong>MAT的使用</strong></h2><p>heap dump生成的hprof文件并不是标准的，还需要将它转换为标<br>准的hprof文件，这样才会被MAT识别从而进行分析，可以使用<br>SDK自带的hprof-conv进行转换，它的路径在sdk/<br>platform-tools中，进入到该路径执行以下语句即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hprof-conv before.hprof after.hprof</div></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/lc3nFe" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/07/lc3nFe.md.jpg" alt="lc3nFe.md.jpg"></a></p>
<p>Histogram</p>
<ul>
<li>列出内存中的对象，对象的个数以及大小，并支持正则表达式查找</li>
</ul>
<p>Dominator Tree</p>
<ul>
<li>列出最大的对象以及其依赖存活的Object （大小是以Retained Heap为标准排序的）。</li>
</ul>
<p>Top Consumers</p>
<ul>
<li>通过图形列出最大的object。</li>
</ul>
<p>Duplicate Classes</p>
<ul>
<li>检测由多个类加载器加载的类。</li>
</ul>
<p>Shallow heap</p>
<ul>
<li>Shallow size就是对象本身占用内存的大小，不<br>包含其引用的对象。针对非数组类型的对象，它的大小就是对象与<br>它所有的成员变量大小的总和。当然这里面还会包括一些java语言<br>特性的数据存储单元。针对数组类型的对象，它的大小是数组元素对象的大小总和。</li>
</ul>
<p>Retained Heap</p>
<ul>
<li>是当前对象大小与当前对象可直接或间接引用到的对象大小总和，包括被递归释放的。也可以理解为，Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存大小。</li>
</ul>
<p>我们常用Histogram来分析内存，点击Histogram:</p>
<p><a href="https://imgchr.com/i/lcJvc9" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/07/lcJvc9.md.png" alt="lcJvc9.md.png"></a></p>
<p>然后输入您需要定位的Activity页面的名字，查看该Activity所发生的内存泄漏的源头页面</p>
<p>选中并作这样的操作，就能够看到具体发生内存泄漏的位置，<br>查看GC引用链，显示距GC Roots最短的路径，并排除虚引用，<br>弱引用及软引用</p>
<p><a href="https://imgchr.com/i/lcNbAP" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/07/lcNbAP.md.png" alt="lcNbAP.md.png"></a></p>
<p>最后得到这样的结果</p>
<p><a href="https://imgchr.com/i/lcaeG8" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/07/lcaeG8.md.png" alt="lcaeG8.md.png"></a></p>
<p>然后结合代码分析并解决问题。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a><strong>案例分析</strong></h2><p><a href="https://imgchr.com/i/lcdbA1" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/07/lcdbA1.md.jpg" alt="lcdbA1.md.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//com.cars.crm.tech.cache.util.FileUtil</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStringFromLocal</span><span class="params">(File cache)</span> </span>&#123;</div><div class="line">        ObjectInputStream ois;</div><div class="line">        FileInputStream fis;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            fis = <span class="keyword">new</span> FileInputStream(cache);</div><div class="line">            ois = <span class="keyword">new</span> ObjectInputStream(fis);</div><div class="line">            Object mObject = ois.readObject();</div><div class="line">            <span class="keyword">if</span> (mObject != <span class="keyword">null</span> &amp;&amp; mObject <span class="keyword">instanceof</span> String) &#123;</div><div class="line">                <span class="keyword">return</span> (String) mObject;</div><div class="line">            &#125;</div><div class="line">            ois.close();</div><div class="line">            fis.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="comment">//修改</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStringFromLocal</span><span class="params">(File cache)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> (FileInputStream fis = <span class="keyword">new</span> FileInputStream(cache);</div><div class="line">             ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(fis)) &#123;</div><div class="line">            Object mObject = ois.readObject();</div><div class="line">            <span class="keyword">if</span> (mObject != <span class="keyword">null</span> &amp;&amp; mObject <span class="keyword">instanceof</span> String) &#123;</div><div class="line">                <span class="keyword">return</span> (String) mObject;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//com.cars.crm.scaffold.webview.ResourceManager(72)</span></div><div class="line"><span class="function">WebResourceResponse <span class="title">fetchResource</span><span class="params">(<span class="keyword">final</span> String mime, <span class="keyword">final</span> String code, String url)</span> </span>&#123;</div><div class="line">        Request request = <span class="keyword">new</span> Request.Builder().get().url(url).build();</div><div class="line">        <span class="keyword">final</span> Call call = mHttpClient.newCall(request);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Callable&lt;WebResourceResponse&gt; mCallable = <span class="keyword">new</span> Callable&lt;WebResourceResponse&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                    Response rep = call.execute();</div><div class="line">                    <span class="keyword">if</span> (rep.isSuccessful() &amp;&amp; rep.body() != <span class="keyword">null</span>) &#123;</div><div class="line">                        InputStream is = rep.body().byteStream();</div><div class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> WebResourceResponse(mime, code, is);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            Future&lt;WebResourceResponse&gt; future = mExecutorService.submit(mCallable);</div><div class="line">            WebResourceResponse webRes = future.get(RESOURCE_WAIT_TIME, TimeUnit.MILLISECONDS);</div><div class="line">            Log.d(<span class="string">"ResourceManager"</span>, <span class="string">"load success url:"</span> + url);</div><div class="line">            <span class="keyword">return</span> webRes;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        Log.d(<span class="string">"ResourceManager"</span>, <span class="string">"load fail url:"</span> + url);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/lcDiNR" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/07/lcDiNR.md.png" alt="lcDiNR.md.png"></a></p>
<p>利用didi工具，在沙盒中找到cache-&gt;matrix_resource目录中找到泄漏的文件，导入到电脑后转换为MAT识别的标注格式分析。</p>
<p><a href="https://imgchr.com/i/l2HExf" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/08/l2HExf.md.jpg" alt="l2HExf.md.jpg"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//VMRecycleAdapterHelp.registerItemLisenter </span></div><div class="line"><span class="comment">//注册adapter持有外部引用</span></div><div class="line">mVMRecycleAdapterHelp.registerItemLisenter(<span class="keyword">new</span> VMRecycleAdapterHelp.ListViewEventListener() &#123;&#125;</div><div class="line"></div><div class="line"><span class="comment">//解决</span></div><div class="line"><span class="comment">//ItemViewModel中释放</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">    unregisterItemLisenter();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/lWGWdI" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/09/lWGWdI.md.png" alt="lWGWdI.md.png"></a></p>
<p><a href="https://imgchr.com/i/lWG4FP" target="_blank" rel="external"><img src="https://s2.ax1x.com/2020/01/09/lWG4FP.md.png" alt="lWG4FP.md.png"></a></p>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化之内存优化-实践篇</title>
    <url>/2019/12/04/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E5%AE%9E%E8%B7%B5%E7%AF%87/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>如果在内存泄漏发生后再去找原因并修复会增加开发成本，最好是在编写代码时就能够很好地考虑到内存问题，写出更高质量的代码。内存优化主要包含两个方面:</p>
<ul>
<li>避免内存泄漏</li>
<li>优化内存空间</li>
</ul>
<h2 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a><strong>避免内存泄漏</strong></h2><h3 id="资源对象未关闭"><a href="#资源对象未关闭" class="headerlink" title="资源对象未关闭"></a><strong>资源对象未关闭</strong></h3><hr>
<p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的代码，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<h3 id="监听器没有注销造成的内存泄漏"><a href="#监听器没有注销造成的内存泄漏" class="headerlink" title="监听器没有注销造成的内存泄漏"></a><strong>监听器没有注销造成的内存泄漏</strong></h3><hr>
<p>在Android程序里面存在很多需要register与unregister的监听器，我们需要确保及时unregister监听器。</p>
<h3 id="监听器没有注销造成的内存泄漏-1"><a href="#监听器没有注销造成的内存泄漏-1" class="headerlink" title="监听器没有注销造成的内存泄漏"></a><strong>监听器没有注销造成的内存泄漏</strong></h3><hr>
<p>我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，<br>并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。<br>所以要在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。</p>
<h3 id="持有Context造成的内存泄漏"><a href="#持有Context造成的内存泄漏" class="headerlink" title="持有Context造成的内存泄漏"></a><strong>持有Context造成的内存泄漏</strong></h3><hr>
<p>在Android中有两种context对象:Activity和Application.当我们给一个类传递context的时候经常使用第一种,而这样就导致了改类持有对Activity的全部引用,当Activity关闭的时候因为被其他类持有,而导致无法正常被回收,而导致内存泄漏</p>
<p><strong>解决方案:</strong></p>
<p>在给其他给传递context的时候使用Application对象,这个对象的生命周期和共存亡,而不依赖activity的声明周期.<br>而对context的引用不要超过他本身的生命周期,谨慎对context使用static关键字.</p>
<h3 id="使用单利模式造成的内存泄漏"><a href="#使用单利模式造成的内存泄漏" class="headerlink" title="使用单利模式造成的内存泄漏"></a><strong>使用单利模式造成的内存泄漏</strong></h3><hr>
<p>在我们使用单利模式的时候如果使用不当也会造成内存泄漏.因为单利模式的静态特征使得单利模式的生命周期和应用一样的长,这说明了当一个对象不需要使用了,而单利对象还存在该对象的引用,那么这个对象就不能正常的被回收,就造成了内存泄漏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//这句代码默认传入的是Activity的Context,而Activity是间接继承自Context的,当Activity退出之后,单例对象还持有他的引用</span></div><div class="line">XXUtils.getInstance(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p><strong>解决方案:</strong><br>在单例中通过传入的context获取到全局的上下文对象,而不使用Activity的Context就解决了这个问题.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">XXUtils</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">        mContext = context.getApplicationContext();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="类的静态变量持有大数据对象"><a href="#类的静态变量持有大数据对象" class="headerlink" title="类的静态变量持有大数据对象"></a><strong>类的静态变量持有大数据对象</strong></h3><hr>
<p>静态变量长期维持对象的引用，阻止垃圾回收，如果静态变量持有大的数据对象，如Bitmap等，就很容易引起内存不足的问题。</p>
<h3 id="WebView内存泄漏"><a href="#WebView内存泄漏" class="headerlink" title="WebView内存泄漏"></a><strong>WebView内存泄漏</strong></h3><hr>
<p>Android中的WebView不仅仅存在很大的兼容性问题，不同Android系统版本中的WebView会有较大的差异，加上不同厂商定制的ROM中的WebView也存在差异，更严重的是WebView都存在内存泄漏的问题，在应用中只要使用一个WebView，内存就不会被释放掉。通常解决这个问题的办法就是为WebView开启独立的一个进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以更具业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/aa5a99b565e7" target="_blank" rel="external">webview内存泄漏终极解决方案</a></p>
</blockquote>
<h3 id="内部类造成的内存泄漏"><a href="#内部类造成的内存泄漏" class="headerlink" title="内部类造成的内存泄漏"></a><strong>内部类造成的内存泄漏</strong></h3><hr>
<ul>
<li>举个例子<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> str = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methed1</span><span class="params">()</span></span>&#123;</div><div class="line">            System.out.println(str);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methed1</span><span class="params">()</span></span>&#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>同样这是一个简单的内部类，B为静态的内部类，使用jad反编译后可以看到如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methed1</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methed1</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">            System.out.println(str);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> MyClass <span class="keyword">this</span>$<span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span></div><div class="line">        &#123;</div><div class="line">            <span class="keyword">this</span>$<span class="number">0</span> = MyClass.<span class="keyword">this</span>;</div><div class="line">            <span class="keyword">super</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">        str = <span class="string">"hello"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String str;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到非静态的内部类会默认持有外部类的引用，这也是为什么内部类可以访问外部类的私有成员，而静态的内部类ClassB则不会有外部类的引用，所以不会造成内存泄漏。</p>
<h4 id="同样的原理，类似的问题还会发生在"><a href="#同样的原理，类似的问题还会发生在" class="headerlink" title="同样的原理，类似的问题还会发生在:"></a>同样的原理，类似的问题还会发生在:</h4><ul>
<li>Runnable</li>
<li>Handler</li>
<li>TimerTask</li>
<li>AsyncTask</li>
</ul>
<p>等类似的情况，所以我们平常使用的时候一定要在避免直接使用内部类，推荐的做法是使用静态内部类+弱应用去处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MESSAGECODE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler handler;<span class="comment">//静态</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        <span class="comment">/** 创建Handler */</span></div><div class="line">        handler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">/** 创建线程并且启动线程 */</span></div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/** 1、避免Handler引用activity造成的内存泄漏：使用静态内部类+ 使用弱引用 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        WeakReference&lt;MyActivity&gt; weakReference;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MyActivity activity)</span> </span>&#123;</div><div class="line">            weakReference = <span class="keyword">new</span> WeakReference&lt;MyActivity&gt;(activity);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.handleMessage(msg);</div><div class="line">            <span class="keyword">if</span> (weakReference.get() != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// update android ui</span></div><div class="line">                Log.d(<span class="string">"GLog"</span>, <span class="string">"handler "</span> + msg.what);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** 2、避免非静态Runnable内部类引用activity造成的内存泄漏 */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            handler.sendEmptyMessage(MESSAGECODE);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">8000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            handler.sendEmptyMessage(MESSAGECODE);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onDestroy();</div><div class="line">        <span class="comment">/** 3、如果参数为null的话，会将所有的Callbacks和Messages全部清除掉。 */</span></div><div class="line">        handler.removeCallbacksAndMessages(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="如何找到项目中存在的内存泄漏"><a href="#如何找到项目中存在的内存泄漏" class="headerlink" title="如何找到项目中存在的内存泄漏"></a>如何找到项目中存在的内存泄漏</h4><p>1、确定是否存在内存泄漏</p>
<ul>
<li><p>Android Monitors分析内存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">记录动作发生之前GC完的内存大小，然后记录动作发生之后GC完后的内存大小，两个比较大小，如果内存变大的话，则可能存在内存泄漏。</div></pre></td></tr></table></figure>
</li>
<li><p>使用MAT内存分析工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MAT分析heap的总内存占用大小来初步判断是否存在内存泄漏</div><div class="line">Heap视图中有一个Type叫data object,即数据对象，也就是我们程序中大量存在的类型的对象。</div><div class="line">在data object中有一项“Total Size”，其值就是当前进程中所有Java数据对象的内存总来过。</div><div class="line">进行操作前和操作后的内存的大小比较。正常情况下Total Size值都会稳定在一个有限的范围内，</div><div class="line">也就是没有内存泄漏。如果值不断增大，则可以初步判断这个操作导致了内存泄漏。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>2、先找到怀疑对象（哪些对象属于泄漏的）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">MAT对比操作前后的hprof来定位内存泄漏了什么数据对象。（这样做可以排除一些对象，不用后面去查看所有被引用的对象是否有嫌疑）。</div><div class="line">快速定位到操作前后所持有的对象哪些是增加了的（GC后还是比之前多出来的对象就可能是内存泄漏的源头）。</div><div class="line">技巧：Histogram中还可以对对象进行Grpup By Package更方便查看自己包里的对象信息。</div></pre></td></tr></table></figure></p>
<p>3、MAT分析hprof来定位内存泄漏的原因（哪个对象持有了上面怀疑出来的发生泄漏的对象）</p>
<ul>
<li><p>Dump出内存泄露“当时”的内存镜像hprof，分析怀疑泄露的类；</p>
</li>
<li><p>把上面2得出的这些嫌疑犯一个一个排查个遍。</p>
</li>
<li><p>hprof-conv D:\before.hprof D:\after.hprof</p>
</li>
</ul>
<h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li><p>进入Histogram，过滤出某一个嫌疑对象类</p>
</li>
<li><p>然后分析持有此类对象引用的外部对象（在该类上面点击右键List Objects—&gt;with incoming references）</p>
</li>
<li><p>再过滤掉一些弱引用、软引用、虚引用，因为它们迟早可以被GC干掉不属于内存泄露(在类上面点击右键Merge Shortest Paths to GC Roots—&gt;exclude all phantom/soft etc.references)</p>
</li>
<li><p>逐个分析每个对象的GC路径是否正常</p>
</li>
</ol>
<h4 id="退出app后，GC后，产看系统进程里的所有的View和Activity对象是否为0"><a href="#退出app后，GC后，产看系统进程里的所有的View和Activity对象是否为0" class="headerlink" title="退出app后，GC后，产看系统进程里的所有的View和Activity对象是否为0"></a>退出app后，GC后，产看系统进程里的所有的View和Activity对象是否为0</h4><p>Android Monitors–System Information–Memory Usage查看</p>
<h2 id="优化内存空间"><a href="#优化内存空间" class="headerlink" title="优化内存空间"></a><strong>优化内存空间</strong></h2><p>没有内存泄漏，并不意味着内存就不需要优化了，再移动设备上，由于物理设备的存储空间有限，Android系统对每个应用进程也都分配了有限的堆内存，因此使用最小内存的对象或者资源可以减少内存开销，同时让GC能更高效的回收不在需要使用的对象，让应用堆内存保持充足的可用内存，使应用更稳定高效的运行。</p>
<h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a><strong>对象引用</strong></h3><hr>
<p>在JDK1.2之前，“引用”的解释为：如果reference类型的数据中储存的数值代表的是另外一块内存的起始地址，就称这个数据代表着一个引用。在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用。</p>
<p>无论是引用计数法还是可达性分析算法，判断对象的存活与否都与“引用”有关。</p>
<p>从以上我们知道不同的引用类型，在GC时的策略是不同的，因此根据业务需求合理使用不同引用，以提高内存的使用效率。</p>
<h3 id="注解代替枚举"><a href="#注解代替枚举" class="headerlink" title="注解代替枚举"></a><strong>注解代替枚举</strong></h3><hr>
<ul>
<li>举个例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Number &#123;</div><div class="line">    One,</div><div class="line">    Two,</div><div class="line">    Three,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个简单的枚举类，javac编译Number后生成字节码， 我们看看Numbers.class到底有什么，因为字节码比较晦涩难懂，我们用jad反编译成Java来看看<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.</span></div><div class="line"><span class="comment">// Jad home page: http://www.kpdus.com/jad.html</span></div><div class="line"><span class="comment">// Decompiler options: packimports(3) </span></div><div class="line"><span class="comment">// Source File Name:   Number.java</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Number[] values()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Number[])$VALUES.clone();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Number <span class="title">valueOf</span><span class="params">(String s)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> (Number)Enum.valueOf(Number, s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Number</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">super</span>(s, i);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Number One;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Number Two;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Number Three;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Number $VALUES[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> </div><div class="line">    &#123;</div><div class="line">        One = <span class="keyword">new</span> Number(<span class="string">"One"</span>, <span class="number">0</span>);</div><div class="line">        Two = <span class="keyword">new</span> Number(<span class="string">"Two"</span>, <span class="number">1</span>);</div><div class="line">        Three = <span class="keyword">new</span> Number(<span class="string">"Three"</span>, <span class="number">2</span>);</div><div class="line">        $VALUES = (<span class="keyword">new</span> Number[] &#123;</div><div class="line">            One, Two, Three</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面得到如下结论：</p>
<ul>
<li><p>枚举类是继承于java.lang.Enum的类。</p>
</li>
<li><p>枚举值是类对象， 且是静态常量(被static final修饰)。</p>
</li>
<li><p>静态代码块内实例化枚举值，由于静态代码块的语法特性，该代码块只执行一次；</p>
</li>
<li><p>默认值0、1、2是在编译时生成的。</p>
</li>
<li><p>枚举类比常量更占内存， 因为一个Java对象至少占16个字节，  而Number包含了3个Java对象；而使用3个整型替换的话，只占用4 * 3即12个字节。</p>
</li>
<li><p>枚举的构造函数是私有的， 防止new出对象。</p>
</li>
</ul>
<p>下面改用注解实现， Android提供了IntDef和StringDef注解，用于编译期的类型检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ONE = <span class="number">1</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TWO = <span class="number">2</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREE = <span class="number">3</span>;</div><div class="line"> </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR_ONE = <span class="string">"ONE"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR_TWO = <span class="string">"TWO"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String STR_THREE = <span class="string">"THREE"</span>;</div><div class="line"> </div><div class="line">    <span class="meta">@IntDef</span>(&#123;ONE, TWO, THREE&#125;)</div><div class="line">    <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> NumberInt &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@StringDef</span>(&#123;STR_ONE, STR_TWO, STR_THREE&#125;)</div><div class="line">    <span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</div><div class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> NumberString &#123;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="减少不必要的内存开销"><a href="#减少不必要的内存开销" class="headerlink" title="减少不必要的内存开销"></a><strong>减少不必要的内存开销</strong></h3><hr>
<h4 id="AutoBoxing-自动装箱"><a href="#AutoBoxing-自动装箱" class="headerlink" title="AutoBoxing(自动装箱)"></a>AutoBoxing(自动装箱)</h4><p>Java 中的变量分为两种：原始型与引用型。</p>
<p>为了在泛型集合中使用基础类型的功能，Java 提供了对应的对象版本，提供了与基础整型相同的功能，但可以使用于泛型集合。</p>
<p>一共存在8个原始型变量以及与各个原始变量对应的8个引用变量(包装类)。</p>
<p>自动拆装箱的目的就是自动地将基础类型与它们的对象版本相互转化，这样你就不用操心你代码中的这些转化了。例如 Integer value = 0 当中，将整型的 0 自动的转化为 Integer 的对象。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Integer total = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">  total += i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看起来不需要写多余的代码就把事情完成了，事实上，第二个版本是这样子的：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Integer total = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</div><div class="line">  total += <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到每次加上之前都要创建新的整数对象，将这个和第一个基础版本相比有着双重影响。</p>
<ul>
<li><p>第一，这占用更多的内存，因为整形只有 4 字节，整数对象有 16 字节；</p>
</li>
<li><p>第二，创建对象需要耗费更多性能。不仅在循环中会出现这样的问题，当你在集合中使用基础类型时，也会出现这样的问题，特别地，对于 HashMap 这样的容器，只要你使用了基础类型，在进行插入、编辑或检索时就会产生一个基础类型和装箱对象。</p>
</li>
</ul>
<p>为了避免 HashMap 的自动装箱行为，Android 系统提供了 SparseBoolArray，SparseIntArray，SparseLongArray，LongSparseArray 等容器，可减少运行时间开支，减少内存使用。</p>
<h4 id="内存复用"><a href="#内存复用" class="headerlink" title="内存复用"></a>内存复用</h4><ul>
<li><p>有效利用系统自带的资源。<br>Android系统本身内置了大量的资源，比如一些通用的字符串、颜色定义、常用Icon图片，还有些动画和页面的样式以及简单布局。</p>
</li>
<li><p>视图复用。<br>出现大量重复子组件，而子组件是大量重复的，可以使用ViewHolder实现ConvertView复用，这基本上是所有容器控件的处理方式，如ListView、RecycleView、GridView等。</p>
</li>
<li><p>对象池。<br>可以在设计程序时显示地在程序中创建对象池，然后实现复用逻辑，对相同的类型数据使用同一块内存空间，也可以利用系统框架既有的具有复用特性的组件减少对象的重复创建，从而减少内存的分配与回收。</p>
<ul>
<li>SynchronizedPool</li>
<li><p>Message</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="keyword">public</span> String id;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> String name;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SynchronizedPool&lt;User&gt; sPool = <span class="keyword">new</span> SynchronizedPool&lt;User&gt;(</div><div class="line">      <span class="number">10</span>);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">obtain</span><span class="params">()</span> </span>&#123;</div><div class="line">  User instance = sPool.acquire();</div><div class="line">  <span class="keyword">return</span> (instance != <span class="keyword">null</span>) ? instance : <span class="keyword">new</span> User();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</div><div class="line">      sPool.release(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们在申请实例化时调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//从对象池中获取，第一次对象池没有，会直接new一个,如果有会复用</span></div><div class="line">User user = User.obtain();</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Bitmap对象的复用。<br>利用Bitmap中的inBitmap的高级特性，提高Android系统在Bitmap的分配与释放效率，不仅可以达到内存复用，还提高了读写速度。</p>
</li>
</ul>
<p>使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的Bitmap会尝试去使用之前那张Bitmap在Heap中所 占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放Bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小</p>
<h3 id="图片内存优化"><a href="#图片内存优化" class="headerlink" title="图片内存优化"></a><strong>图片内存优化</strong></h3><hr>
<ul>
<li><p>设置位图规格</p>
<p>  |  Format    | Bit Per Pixel  |<br>  |  :—-:    | :—-:         |<br>  | ARGB_8888  | 32             |<br>  | RGB_565    | 16             |<br>  | ARGB_4444  | 16             |<br>  | ALPHA_8    | 8              |</p>
<p>  除了大图模式，一般都可以使用，并且几乎看不出差别。只要满足以下其中一点就可以考虑使用RGB_565：</p>
<ul>
<li><p>显示局部图片，比如列表中的小图片</p>
</li>
<li><p>小屏幕手机或者对图片质量要求不高，不需要Alpha通道的场景，可以使用RGB_565。</p>
<p>如果需要更小的格式，但又需要透明通道，可以尝试ARGB_444图像格式。它减少了一半的数据，但保留了透明通道，视觉差异变化较大，一般用于用户头像，特别是圆角的头像，可以尝试使用ARGB_4444看看效果。</p>
<p>Alpha_8格式主要用于Alpha通道模板，相当于做一个染色。图像要渲染两次，虽然减少内存，但增加了绘制的开销。</p>
<p>在Android的基本文件结构中不支持PNG、JPEG、WEBP格式，因此，需要解码后的位图功能，通过设置inPreferredConfig参数来实现不同的位图规格，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">options.inPreferredConfig = Bitmap.Config.RGB_565;</div><div class="line">BitmapFactory.decodeStream(is, <span class="keyword">null</span>, options);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>inSampleSize</p>
</li>
</ul>
<p>如果内存中的图片大于屏幕显示出的图片大小，或者大于指定屏幕区域的大小，这些高分辨率图片会占用内存堆中的大量空间，使应用空间变小，然后重置这些图片大小，让它们符合实际显示的大小，既能减少内存的开销，也能提高显示的效率，这样载入内存的图片规格符合实际显示规格，而不是完整的分辨率。位图功能对象中的inSampleSize属性实现了位图的缩放功能，<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">options.inSampleSize = <span class="number">4</span>;</div><div class="line">BitmapFactory.decodeStream(is, <span class="keyword">null</span>, options);</div></pre></td></tr></table></figure>
<p>将这个属性设置为1时，可以在不加载完整大小的前提下，生成一张只有原始图片部分大小的新图片，如inSampleSize为2时获得只有1/2大小的图片，同理设置为4就是1/4大小的图片。</p>
<ul>
<li>inScaled，inDensity和inTargetDensity</li>
</ul>
<p>虽然inSampleSize可以实现图片的缩放，都是指数幂的缩放，如果想更细地缩放图片，就需要使用位图的inScaled、inDensity和inTargetDensity功能，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">options.inScaled = <span class="keyword">true</span>;</div><div class="line">options.inDensity = srcWidth; <span class="comment">//inDensity为资源文件夹对应的像素密度</span></div><div class="line">options.inTargetDensity = dstWidth; <span class="comment">//inTargetDensity为设备的像素密度</span></div><div class="line">BitmapFactory.decodeStream(is, <span class="keyword">null</span>, options);</div><div class="line"><span class="comment">//目标设备上图片的像素数的计算公式：(pixWidth / inDensity * inTargetDensity) * (pixHeight / inDensity * inTargetDensity)</span></div></pre></td></tr></table></figure>
<ul>
<li>inBitmap</li>
</ul>
<p>Android 3.0（API level 11）引进了BitmapFactory.Options.inBitmap字段，如果设置了该属性，那么当使用了带有该Options参数的decode方法加载内容时，decode方法会尝试重用一个已经存在的位图。这就意味着位图内存已经被重用了，从而改善了性能，并且没有内存的分配和释放过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//首先以原尺寸加载图片a，这里图片a和图片b的尺寸相同</span></div><div class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</div><div class="line">options.inMutable = <span class="keyword">true</span>;</div><div class="line">options.inDensity = <span class="number">160</span>;</div><div class="line">options.inTargetDensity = <span class="number">160</span>;</div><div class="line">Bitmap bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.a, options);</div><div class="line">Log.i(TAG, <span class="string">"bitmap = "</span> + bitmap);</div><div class="line">Log.i(TAG, <span class="string">"bitmap.size = "</span> + bitmap.getByteCount());</div><div class="line">Log.i(TAG, <span class="string">"bitmap.allocSize = "</span> + bitmap.getAllocationByteCount());</div><div class="line"></div><div class="line"><span class="comment">//然后复用a图片，解码b图片。</span></div><div class="line">options.inBitmap = bitmap;</div><div class="line"><span class="comment">//注意这里解码得到的图片宽高为原始尺寸的一半</span></div><div class="line">options.inDensity = <span class="number">160</span>;</div><div class="line">options.inTargetDensity = <span class="number">80</span>;</div><div class="line">options.inMutable = <span class="keyword">true</span>;</div><div class="line">options.inSampleSize = <span class="number">1</span>;</div><div class="line">Bitmap bitmapAIO = BitmapFactory.decodeResource(getResources(), R.drawable.b, options);</div><div class="line">Log.i(TAG, <span class="string">"bitmapAIO = "</span> + bitmapAIO);</div><div class="line">Log.i(TAG, <span class="string">"bitmap.size = "</span> + bitmap.getByteCount());</div><div class="line">Log.i(TAG, <span class="string">"bitmap.allocSize = "</span> + bitmap.getAllocationByteCount());</div><div class="line">Log.i(TAG, <span class="string">"bitmapAIO.size = "</span> + bitmapAIO.getByteCount());</div><div class="line">Log.i(TAG, <span class="string">"bitmapAIO.allocSize = "</span> + bitmapAIO.getAllocationByteCount());</div><div class="line"></div><div class="line">输出：</div><div class="line">bitmap = android.graphics.Bitmap@<span class="number">9f</span>b5d09</div><div class="line">bitmap.size = <span class="number">8294400</span></div><div class="line">bitmap.allocSize = <span class="number">8294400</span></div><div class="line"></div><div class="line">bitmapAIO = android.graphics.Bitmap@<span class="number">9f</span>b5d09</div><div class="line">bitmap.size = <span class="number">2073600</span></div><div class="line">bitmap.allocSize = <span class="number">8294400</span></div><div class="line">bitmapAIO.size = <span class="number">2073600</span></div><div class="line">bitmapAIO.allocSize = <span class="number">8294400</span></div></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/showdy/article/details/54378637" target="_blank" rel="external">浅谈BitmapFactory.Options</a></p>
</blockquote>
<h3 id="使用最优的数据类型"><a href="#使用最优的数据类型" class="headerlink" title="使用最优的数据类型"></a><strong>使用最优的数据类型</strong></h3><hr>
<p>使用ArrayMap/SparseArray来代替HashMap，ArrayMap/SparseArray是专门为移动设备设计的高效的数据结构。</p>
<ul>
<li><p>HashMap缺点</p>
<ul>
<li><p>HashMap内部使用一个默认容量为16的数组来存储数据，采用拉链法解决hash冲突（数组+链表），就算没有数据，也需要分配默认16个元素的数组</p>
</li>
<li><p>一旦数据量达到Hashmap限定容量的75%，就将按两倍扩容</p>
</li>
</ul>
</li>
<li><p>SparseArray</p>
<ul>
<li>支持int类型，避免自动装箱，但是也只支持int类型的key</li>
<li>内部通过两个数组来进行数据存储的，一个存储key，另外一个存储value</li>
<li>因为key是int，在查找时，采用二分查找，效率高，SparseArray存储的元素都是按元素的key值从小到大排列好的。 （Hashmap通过遍历Entry数组来获取对象）</li>
<li>默认初始size为0，每次增加元素，size++</li>
</ul>
</li>
<li><p>ArrayMap</p>
<ul>
<li><p>跟SparseArray一样，内部两个数组，但是第一个存key的hash值，一个存value，对象按照key的hash值排序，二分查找也是按照hash</p>
</li>
<li><p>查找index时，传入key，计算出hash，通过二分查找hash数组，确定index</p>
</li>
</ul>
</li>
</ul>
<h3 id="避免在onDraw方法里面执行对象的创建"><a href="#避免在onDraw方法里面执行对象的创建" class="headerlink" title="避免在onDraw方法里面执行对象的创建"></a><strong>避免在onDraw方法里面执行对象的创建</strong></h3><hr>
<p>类似onDraw等频繁调用的方法，一定需要注意避免在这里做创建对象的操作，因为他会迅速增加内存的使用，而且很容易引起频繁的gc，甚至是内存抖动。</p>
<h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a><strong>StringBuilder</strong></h3><hr>
<p>在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用StringBuilder来替代频繁的“+”。</p>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化之内存优化-理论篇</title>
    <url>/2019/12/03/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E7%90%86%E8%AE%BA%E7%AF%87/</url>
    <content><![CDATA[<p>[TOC]<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>Android应用都是在Android的虚拟机上运行，应用程序的内存分配与垃圾回收都是有虚拟机完成的。在Android系统，虚拟机有两种运行模式:Dalvik和ART。</p>
<p>这里简单介绍下Dalvik和ART在垃圾回收机制上的区别:</p>
<h3 id="首先介绍下dalvik的GC的过程。主要有有四个过程"><a href="#首先介绍下dalvik的GC的过程。主要有有四个过程" class="headerlink" title="首先介绍下dalvik的GC的过程。主要有有四个过程:"></a>首先介绍下dalvik的GC的过程。主要有有四个过程:</h3><ul>
<li><p>当gc被触发时候，其会去查找所有活动的对象，这个时候整个程序与虚拟机内部的所有线程就会挂起，这样目的是在较少的堆栈里找到所引用的对象；注意：这个回收动作和应用程序非并发；</p>
</li>
<li><p>gc对符合条件的对象进行标记；</p>
</li>
<li><p>gc对标记的对象进行回收；</p>
</li>
<li><p>恢复所有线程的执行现场继续运行。</p>
</li>
</ul>
<p>dalvik这么做的好处是，当pause了之后，GC势必是相当快速的。但是如果出现GC频繁并且内存吃紧势必会导致UI卡顿、掉帧、操作不流畅等。</p>
<h3 id="ART改善了这种GC方式，-主要的改善点在将其非并发过程改成了部分并发，还有就是对内存的重新分配管理。"><a href="#ART改善了这种GC方式，-主要的改善点在将其非并发过程改成了部分并发，还有就是对内存的重新分配管理。" class="headerlink" title="ART改善了这种GC方式， 主要的改善点在将其非并发过程改成了部分并发，还有就是对内存的重新分配管理。"></a>ART改善了这种GC方式， 主要的改善点在将其非并发过程改成了部分并发，还有就是对内存的重新分配管理。</h3><p>当ART GC发生时:</p>
<ul>
<li><p>GC将会锁住Java堆，扫描并进行标记；</p>
</li>
<li><p>标记完毕释放掉Java堆的锁，并且挂起所有线程；</p>
</li>
<li><p>GC对标记的对象进行回收；</p>
</li>
<li><p>恢复所有线程的执行现场继续运行；</p>
</li>
<li><p>重复2-4直到结束。</p>
</li>
</ul>
<p>可以看出整个过程做到了部分并发使得时间缩短。据官方测试数据说GC效率提高2倍。</p>
<p>虽然ART做了很多优化，但是如果出现GC频繁并且内存吃紧势必会导致UI卡顿、掉帧、操作不流畅等。</p>
<p>另一方面大量的内存消耗，最后也会导致OOM，这里我们以dalvik虚拟机描述：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我们知道，Heap(堆)内存是由程序员控制的，用C/C++申请的内存空间在native heap中，</div><div class="line"></div><div class="line">而java申请的内存空间则在dalvik heap中.</div><div class="line"></div><div class="line">那么为什么会出现OOM的情况呢？</div><div class="line"></div><div class="line">这个是因为Android系统对dalvik虚拟机的heap大小作了硬性限制，当java进程申请的空间超过这个阈值时，就会抛出OOM异（这个阈值可以是48M、24M、16M等，视机型而定）。</div><div class="line"></div><div class="line">也就是说，程序发生OMM并不表示RAM不足，而是因为程序申请的java heap对象超过了dalvik vm heapgrowthlimit。也就是说，在RAM充足的情况下，也可能发生OOM。</div><div class="line"></div><div class="line">这样设计的目的是为了让Android系统能同时让比较多的进程常驻内存(RAM)，这样程序启动时就不用每次都重新加载到内存，能够给用户更快的响应。</div><div class="line"></div><div class="line">迫使每个应用程序使用较小的内存，移动设备非常有限的RAM就能使比较多的app常驻其中。</div><div class="line"></div><div class="line">java程序发生OMM并不是表示RAM不足，如果RAM真的不足，Android的memory killer会起作用，当RAM所剩不多时，</div><div class="line"></div><div class="line">memory killer会杀死一些优先级比较低的进程来释放物理内存，让高优先级程序得到更多的内存。</div></pre></td></tr></table></figure></p>
<h3 id="注-不同版本dalvik虚拟机对堆内存的区别"><a href="#注-不同版本dalvik虚拟机对堆内存的区别" class="headerlink" title="注: 不同版本dalvik虚拟机对堆内存的区别"></a>注: 不同版本dalvik虚拟机对堆内存的区别</h3><ul>
<li><p>ActivityManager.getMemoryClass()可以查询当前APP的Heap Size阈值，单位是MB。</p>
</li>
<li><p>在3.x以前，Bitmap分配在Native heap中，而在4.x之后，Bitmap分配在Dalvik或ART的Java heap中。</p>
</li>
<li><p>Android 2.x系统，当dalvik allocated + native allocated + 新分配的大小 &gt;= dalvik heap 最大值时候就会发生OOM，也就是说在2.x系统中，考虑native heap对每个进程的内存限制。</p>
</li>
<li><p>Android 4.x系统，废除了native的计数器，类似bitmap的分配改到dalvik的java heap中申请，只要allocated + 新分配的内存 &gt;= dalvik heap 最大值的时候就会发生OOM（art运行环境的统计规则还是和dalvik保持一致），也就是说在4.x系统中，不考虑native heap对每个进程的内存限制，native heap只会收到本机总内存（包括RAM以及SWAP区或分页文件）的限制。</p>
</li>
</ul>
<p>基于这两方面，内存优化在我们平时的开发中是非常值得重视的。</p>
<p>下面首先我们先了解一下Java对象的生命周期。</p>
<h2 id="Java对象生命周期"><a href="#Java对象生命周期" class="headerlink" title="Java对象生命周期"></a><strong>Java对象生命周期</strong></h2><p>在Android应用程序中，大部分是Java程序，而Java对象被创建的Java类字节码(编译后的.class文件)需要从文件系统加载到虚拟机。Java对象在虚拟机上运行有7个阶段，也就是对象的生命周期:</p>
<ul>
<li><p>创建阶段(Created)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">创建Java对象阶段的具体步骤如下：</div><div class="line"></div><div class="line">1. 为对象分配存储空间</div><div class="line"></div><div class="line">2. 构造对象</div><div class="line"></div><div class="line">3. 从父类到子类对static成员进行初始化，类的static成员的初始化再ClassLoader加载该类时进行。</div><div class="line"></div><div class="line">4. 父类成员变量按顺序初始化，递归调用父类的构造方法。</div><div class="line"></div><div class="line">5. 子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值，完成后这个对象的状态就切换到了应用阶段</div></pre></td></tr></table></figure>
</li>
<li><p>应用阶段(InUse)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">对象至少被一个强引用(Strong Reference)持有，除非在系统中显示地使用了</div><div class="line"></div><div class="line">软引用(Soft Reference)、弱引用(Weak Reference)或虚引用(Phantom Reference).</div></pre></td></tr></table></figure>
</li>
<li><p>不可见阶段(Invisible)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">处于不可见阶段的对象在虚拟机的对象引用根集合中再也找不到直接或间接的强引用，</div><div class="line"></div><div class="line">这些对象一般是所有线程栈中的临时变量。所有已经装载的静态变量或者是对本地代码接口的引用。</div><div class="line"></div><div class="line">当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然对象仍然是存在的。</div><div class="line"></div><div class="line">简单的例子就是程序的执行已经超出了该对象的作用域了，改对象仍有可能被虚拟机下的某些已经装载的</div><div class="line"></div><div class="line">静态变量线程或JNI等强引用持有，这些特殊强引用称为Gc Root。存在这些GC Root会导致对象的内存泄漏，无法被回收。</div></pre></td></tr></table></figure>
</li>
<li><p>不可达阶段(Unreadchable)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">对象处于不可达阶段是指该对象不再被任何强引用持有，回收器发现该对象已经不可达。</div></pre></td></tr></table></figure>
</li>
<li><p>收集阶段(Collected)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当垃圾回收器发现该对象已经处于&quot;不可达阶段&quot;并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，对象进入&quot;收集阶段&quot;。</div><div class="line"></div><div class="line">如果该对象已经重写了finalize()方法,则执行该方法的操作。</div></pre></td></tr></table></figure>
</li>
<li><p>终结阶段(Finalized)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当对象执行完成finalized()方法后仍然处于不可达状态时，该对象进入终结阶段，等待垃圾回收器回收该对象空间。</div></pre></td></tr></table></figure>
</li>
<li><p>对象空间重新分配阶段(Deallocated)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">若垃圾回收器对该对象占用的内存空间进行回收或者再分配，则该对象彻底消失，这个阶段称为&quot;对象重新分配阶段&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>注意：</p>
<p>创建对象后，在确定不需要使用对象时，使对象置空，这样更符号垃圾回收标准。比如Object = null，</p>
<p>可以提高内存使用效率，并且不要采用过深的继承层次。访问本地变量优于访问类中的变量。</p>
<h2 id="JVM内存分配"><a href="#JVM内存分配" class="headerlink" title="JVM内存分配"></a><strong>JVM内存分配</strong></h2><p>平时我们对于Java内存都有一个比较粗略的概念，就是分堆和栈，但实际上还是复杂得多，以下给出完整内存模型：</p>
<p><img src="https://user-images.githubusercontent.com/11883853/70790060-3b62fc00-1dcf-11ea-912f-9eeea722bf96.png" alt="image"></p>
<h3 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h3><ul>
<li><p>这一区域不会出现OOM（Out Of Memory）错误的情况</p>
</li>
<li><p>属于线程私有，因为每一个线程都有自己的一个程序计数器，来表示当前线程执行的字节码行号</p>
</li>
<li><p>标识Java方法的字节码地址，而不是Native方法</p>
</li>
<li><p>处于CPU上，我们无法直接操作这块区域</p>
</li>
</ul>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>这个区域也是我们平时口中说的堆栈的栈，关于这个块区域有如下要点：</p>
<ul>
<li><p>属于线程私有，与线程的生命周期相同</p>
</li>
<li><p>每一个java方法被执行的时候，这个区域会生成一个栈帧</p>
</li>
<li><p>栈帧中存放的局部变量有8种基本数据类型，以及引用类型（对象的内存地址）</p>
</li>
<li><p>java方法的运行过程就是栈帧在虚拟机栈中入栈和出栈的过程</p>
</li>
<li><p>当线程请求的栈的深度超出了虚拟机栈允许的深度时，会抛出StackOverFlow的错误</p>
</li>
<li><p>当Java虚拟机动态扩展到无法申请足够内存时会抛出OutOfMemory的错误</p>
</li>
</ul>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul>
<li><p>这个区域，属于线程私有，顾名思义，区别于虚拟机栈，这里是用来处理Native方法（Java本地方法）的，而虚拟机栈是处理Java方法的。对于Native方法，Object中就有不少的Native的方法，hashCode,wait等，这些方法的执行很多时候都是借助于操作系统。</p>
</li>
<li><p>这一区域也有可能抛出StackOverFlowError 和 OutOfMemoryError</p>
</li>
</ul>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>我们平时说得最多，关注得最多的一个区域，就是他了。我们后期进行的性能优化主要针对这部分内存，GC的主战场，这个地方存放的几乎所有的对象实例和数组数据。这里我大概进行了如下概括：</p>
<ul>
<li><p>Java堆属于线程共享区域，所有的线程共享这一块内存区域</p>
</li>
<li><p>从内存回收角度，Java堆可被分为新生代和老年代，这样分能够更快的回收内存</p>
</li>
<li><p>从内存分配角度，Java堆可划分出线程私有的分配缓存区（Thread Local Allocation Buffer,TLAB）,这样能够更快的分配内存</p>
</li>
<li><p>当Java虚拟机动态扩展到无法申请足够内存时会抛出OutOfMemory的错误</p>
</li>
</ul>
<blockquote>
<p>新生代<br> <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">新生代存储新创建的对象。新生代由Eden和两块大小相同的Survivor space组成（又叫S0、S1或者From、To）构成，Eden和S0、S1的比例一般为8：1，具体大小细节以及分配原因，将在后面的垃圾回收机制里面介绍。</div></pre></td></tr></table></figure></p>
<p>老年代<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">老年代一般存储经历了多次新生代GC还未被回收的对象。老年代的内存区域一般都比较大，主要是为了减少老年代的GC（major GC）的次数（该种类型的GC比较耗时），同时为了防止OOM。</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区主要存放的是已被虚拟机加载的类信息、常量、静态变量、编译器编译后的代码等数据。GC在该区域出现的比较少。概括如下：</p>
<ul>
<li><p>也称为“永久代”</p>
</li>
<li><p>方法区属于线程共享区域</p>
</li>
<li><p>垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载</p>
</li>
<li><p>常量池用于存放编译期生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量</p>
</li>
<li><p>运行期间的常量也可以添加进入常量池中，比如string的intern()方法。</p>
</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池也是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。单独拿出来说明一下，是因为我们平时使用String比较多，涉及到这一块的知识，但这一块区域不会抛出OutOfMemoryError</p>
<h3 id="Dalvik堆"><a href="#Dalvik堆" class="headerlink" title="Dalvik堆"></a>Dalvik堆</h3><p>Dalvik VM的堆结构相对于JVM的堆结构有所区别，只而主要体现在Dalvik将堆分成了Active堆和Zygote堆。</p>
<p>Zygote是一个虚拟机进程，同时也是一个虚拟机实例的孵化器——那么同样的，zygote堆是Zygote进程在启动时的预加载的类、资源和对象；除此之外所有的对象,包括我们在代码中创建的实例、静态域和数组，都是储存在Active堆里边的。
  </p>
<p>为什么要把Dalvik堆分成Zygote堆和Active堆？</p>
<p>这主要是因为Android通过fork方法创建一个新的zygote进程，为了尽可能的避免父进程和子进程之间的数据拷贝，fork方法使用写时拷贝技术，简单讲就是fork的时候不立即拷贝父进程的数据到子进程中，而是在子进程或者父进程对内存进行写操作时才对内容进行复制。
  </p>
<p>Dalvik的Zygote堆存放的预加载类都是Android核心类和Java运行时库，这部分很少被修改，大多数情况下父进程和子进程共享这块区域，因此没有必要对这部分类进行垃圾回收之类的修改，直接复制即可。而Active堆作为我们程序代码中创建实例对象的存放堆，是垃圾回收的重点区域，因此将两个堆分开。</p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a><strong>内存回收</strong></h2><p>说起内存回收，我们考虑以下几件事情。</p>
<ol>
<li>内存回收的区域?</li>
<li>哪些内存需要回收?</li>
<li>如何回收?</li>
</ol>
<h3 id="内存回收的区域"><a href="#内存回收的区域" class="headerlink" title="内存回收的区域"></a>内存回收的区域</h3><ul>
<li><p>程序计数器、本地方法栈、虚拟机栈：这几块内存都是随线程而生，随线程而灭。栈中的栈帧，随着方法的调用入栈和出栈，栈帧的内存大小在编译器就已经可知了，因此内存的分配和回收是确定的，故不需要参加GC。</p>
</li>
<li><p>堆：内存回收的主力区域，对象和数组都保存在此区域。</p>
</li>
<li><p>方法区 ：无用的类型信息以及常量都是回收的目标，但是一般进行GC的概率不大，主要是性价比不高。</p>
</li>
</ul>
<h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><p>要确定哪些内存需要回收，目前有以下几种判定方案:</p>
<h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a><strong>引用计数算法</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">给对象添加一个引用计数器，每当有一个地方引用它的时候，</div><div class="line"></div><div class="line">计数器的值就加1；当引用失效的时候，计数器的值就减1；任何时刻计数器为0的对象是不可能再被引用的。</div><div class="line"></div><div class="line">  这种方法实现简单，判断效率也很高；但是该算法有一个致命的缺点就是难以解决对象相互引用的问题：</div><div class="line"></div><div class="line">试想有两个对象，相互持有对方的引用，而没有别的对象引用到这两者，那么这两个对象就是无用的对象，</div><div class="line"></div><div class="line">理应被回收，但是由于他们互相持有对方的引用，因此他们的引用计数器不为0，因此他们不能被回收。</div></pre></td></tr></table></figure>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">为了解决上面循环引用的问题，Java采用了一种全新的算法——可达性分析算法。这个算法的核心思想是，</div><div class="line"></div><div class="line">通过一系列称为“GC Roots”的对象作为起始点，从这些结点开始向下搜索，搜索所走过的路径成为“引用链”，</div><div class="line"></div><div class="line">当一个对象到GC Roots没有一个对象相连时，则证明此对象是不可用的(不可达)。</div></pre></td></tr></table></figure>
<p><img src="https://user-images.githubusercontent.com/11883853/70894604-4a90b680-2028-11ea-8428-72d065404617.png" alt="image"></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ol>
<li>上面说的JVM栈(栈帧数据中的本地变量表)中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>Native方法栈中JNI引用的对象。</li>
</ol>
<p>需要注意一点，即使在可达性分析算法中不可达对象，也并非是“非死不可”的，要真正宣告一个对象的死亡，至少需要经历两次标记的过程：</p>
<p>  如果一个对象在进行可达性分析之后发现没有与GC Roots相连的引用链，那么他将会第一次标记。</p>
<p>当对象没有复写finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机讲着两种情况都视为“没有必要执行finalize()方法”。</p>
<p>  如果这个对象被判定为有必要执行finalize()方法，那么这个对象会被加入一个“F-Queue”队列中，并在稍后由一个虚拟机建立的、优先级低的Finalize线程，去触发这个方法，但并不承诺会等待他运行结束。</p>
<p>  finalize()方法是对象逃脱死亡厄运的最后一次机会，稍后的GC会对在“F-Queue”队列中的对象进行第二次小规模的标记；</p>
<p>  如果对象要在finalize()中拯救自己，只需要重新与引用链上的对象就行关联即可，那么在第二次标记时它将被移出“即将回收”的集合；</p>
<p>  如果对象这个时候还是没有逃脱，那基本上他就真的被回收了。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a><strong>引用</strong></h4><p>无论是引用计数法还是可达性分析算法，判断对象的存活与否都与“引用”有关。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在JDK1.2之前，“引用”的解释为：</div><div class="line"></div><div class="line">如果reference类型的数据中储存的数值代表的是另外一块内存的起始地址，就称这个数据代表着一个引用。</div><div class="line"></div><div class="line">在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>强引用：就是指在程序代码之中普遍存在的，类似于“Object obj = new Object();”这样的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用：用来描述一些还有用但并非必须的对象。对于软引用关联的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收的范围，进行第二次回收——如果这次回收还没有腾出足够的内存，才会内存溢出抛出异常。在JDK1.2之后，提供了SoftReference来实现软引用。</p>
</li>
<li><p>弱引用：也是用来描述非必须对象的，但是他的强度比软引用更弱一些。被弱引用引用的对象，只能生存到下一次GC之前，当GC发生时，无论无论当前内存是否足够，都会回收掉被弱引用关联的对象。JDK1.2之后，提供了WeakRefernce类来实现弱引用。</p>
</li>
<li><p>虚引用：是最弱的一种引用，一个对象有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置一个虚引用关联的唯一目的就是能够在这个对象呗收集器回收的的时候收到一个系统的通知。</p>
</li>
</ul>
<h3 id="如何回收"><a href="#如何回收" class="headerlink" title="如何回收"></a><strong>如何回收</strong></h3><ul>
<li>标记清除算法 (Mark-Sweep)<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">标记-清除算法分为两个阶段：标记阶段和清除阶段。</div><div class="line"></div><div class="line">标记阶段的任务是标记出所有需要被回收的对象，</div><div class="line"></div><div class="line">清除阶段就是回收被标记的对象所占用的空间。</div><div class="line"></div><div class="line">  这种算法的缺点是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4IDD1.png" alt="Q4IDD1.png"></p>
<ul>
<li>复制算法 (Copying)<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，</div><div class="line"></div><div class="line">然后再把已使用的另一半内存空间中的对象一次性全部清理掉，这样一来就不容易出现内存碎片的问题。</div><div class="line"></div><div class="line">这种算法的优点就是，实现简单，运行高效且不容易产生内存碎片；缺点也显而易见：将可用内存缩小为了原来的一半，代价非常高昂。</div><div class="line"></div><div class="line">从算法原理我们可以看出Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，</div><div class="line"></div><div class="line">那么Copying算法的效率将会大大降低（要复制的对象比较多）。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4Ic4O.png" alt="Q4Ic4O.png"></p>
<ul>
<li>标记整理算法 (Mark-Compact)<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</div><div class="line"></div><div class="line">  这种算法特别适用于存活对象多，回收对象少的情况，因为回收的对象少，标记完了之后需要移动的对象就相对较少。</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4I2CD.png" alt="Q4I2CD.png"></p>
<ul>
<li>分代回收算法<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当前的商业虚拟机的垃圾收集器都采用“分代收集”算法，这种算法并没有什么新的思想，</div><div class="line"></div><div class="line">只是根据对象的存活的周期不同将内存划分为几块。</div><div class="line"></div><div class="line">前面我们说过，</div><div class="line"></div><div class="line">复制算法：适用于存活对象很少，回收对象多；</div><div class="line"></div><div class="line">标记整理算法：适用于存活对象多，回收对象很少的情况。这两种算法情况正好互补！</div><div class="line"></div><div class="line">一般情况下我们把Java的对分为新生代和老年代，在新生代，每次垃圾收集时，都会有大批的对象死去，</div><div class="line"></div><div class="line">只有少量存活，因此适用复制算法；而在老年代，因为对象存活率高、没有额外的空间对它进行分配担保，</div><div class="line"></div><div class="line">就必须使用“标记-清除”或者“标记-整理”算法来进行回收。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>下面我们详细了解下分代回收：</p>
<p>上面我们已经简略的说过Java堆和Dalvik堆的区别，这里我们复习一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Java堆用于存放对象实例，几乎所有的对象(实例变量，数组)都</div><div class="line"></div><div class="line">在该区域分配,是内存回收的主要区域；Dalvik将堆分成了</div><div class="line"></div><div class="line">Active堆和Zygote堆，zygote堆是Zygote进程在启动时的预加</div><div class="line"></div><div class="line">载的类、资源和对象；除此之外所有的对象,包括我们在代码中创</div><div class="line"></div><div class="line">建的实例、静态域和数组，都是储存在Active堆里边。</div></pre></td></tr></table></figure></p>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4o5z4.png" alt="Q4o5z4.png"></p>
<ul>
<li><p>Java堆按照对象存活的时间可分为新生代和老年代</p>
</li>
<li><p>新生代又分为三个部分：一个内存较大的Eden区，和两个内存较小且大小相同的Survivor区，比例为8：1：1.</p>
</li>
<li><p>Eden区存放新生的对象</p>
</li>
<li><p>Survivor存放每次垃圾回收后存活的对象</p>
</li>
</ul>
<h4 id="新生代又分为三个部分：一个内存较大的Eden区，和两个内存较小且大小相同的Survivor区，比例为8：1：1"><a href="#新生代又分为三个部分：一个内存较大的Eden区，和两个内存较小且大小相同的Survivor区，比例为8：1：1" class="headerlink" title="新生代又分为三个部分：一个内存较大的Eden区，和两个内存较小且大小相同的Survivor区，比例为8：1：1."></a>新生代又分为三个部分：一个内存较大的Eden区，和两个内存较小且大小相同的Survivor区，比例为8：1：1.</h4><p>对象的内存分配，主要分配在新生代的Eden(伊甸园)区上，当Eden区没有足够的空间进行分配时，虚拟机将发起一次“复制算法”的GC，在这个过程中，存活下来的对象被放到Survivor 0区；当第二次GC来临的时候，Survivor 0空间的存活对象也需要再次用复制算法，放到Survivor 1空间，二把刚刚分配对象的Survivor 0空间和Eden空间清除；第三次GC时，又把Survivor 1空间的存活对象复制到Survivor 0的空间，就这样来回倒腾。</p>
<p>  通过上面的分析我们不难理解新生代为什么这么分配了：Eden区是对象分配的主要区域，这是很频繁的，尤其是大量的局部变量产生的临时对象，因此他占的比例为8/10，</p>
<p>这个区域分配的对象大多数都是“朝生夕灭”，因此存活下来的对象较少，故采用“复制算法”； 至于两个Survivor的比例为什么是1:1，这个应该很好理解。</p>
<blockquote>
<p>注：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> GC是统计学测算出当内存使用超过98%以上时，内存就应该被minor gc时回收一次。但是实际应用中，</div><div class="line"></div><div class="line">我们不能较真的只给他们留下2%，换句话说当内存使用达到98%时才GC 就有点晚了，应该是多一些预留10%内存空间，</div><div class="line"></div><div class="line">这预留下来的空间我们称为S区（有两个s区  s1 和  s0），S区是用来存储新生代GC后存活下来的对象，</div><div class="line"></div><div class="line">而我们知道新生代GC算法使用的是复制回收算法。</div><div class="line"></div><div class="line"> 所以我们实际GC发生是在，新生代内存使用达到90%时开始进行，复制存活的对象到S1区，</div><div class="line"></div><div class="line">要知道GC结束后在S1区活下来的对象，需要放回给S0区，也就是对调(对调是指，两个S区位置互换,</div><div class="line"></div><div class="line">意味着再一次minor gc 时的区域  是eden 加，上一次存活的对象放入的S区)，既然能对调，其实就是两个区域一般大。</div><div class="line"></div><div class="line">这也是为什么会再有个10%的S0区域出来。</div><div class="line"></div><div class="line">这样比例就是8:1:1了!!（80%：s1:s0=80%:10%:10%=8:1:1）这里的eden区（80%） 和其中的一个  S区（10%） 合起来共占据90%，</div><div class="line"></div><div class="line">GC就是清理的他们，始终保持着其中一个  S  区是空留的，保证GC的时候复制存活的对象有个存储的地方。</div></pre></td></tr></table></figure>
<h4 id="什么样的对象会被移入老生带？"><a href="#什么样的对象会被移入老生带？" class="headerlink" title="什么样的对象会被移入老生带？"></a>什么样的对象会被移入老生带？</h4><ul>
<li><p>新生代中经历过15次GC的对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">虚拟机给每个对象定义了一个对象年龄计数器，如果对象在Eden出生并经过第一次GC后仍然存活，</div><div class="line"></div><div class="line">将被移动到Survivor空间中，并且对象的年龄设为1；对象在Survivor区中每“熬过”一个GC，</div><div class="line"></div><div class="line">年龄就增加1岁，当它年龄增加到一定程度(默认为15岁)，就会晋升到老年带中。</div></pre></td></tr></table></figure>
</li>
<li><p>大对象直接进入老年代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">所谓大对象是指，需要连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组，</div><div class="line"></div><div class="line">虚拟机提供了一个PretenureSizeThreshold参数，令大于这个这个值的对象直接在老生代中分配。</div><div class="line"></div><div class="line">这样做主要是为了避免在Eden区和两个Survivor区之间复制算法执行的时候产生大量的内存复制。</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="触发GC的类型"><a href="#触发GC的类型" class="headerlink" title="触发GC的类型"></a>触发GC的类型</h4><p>了解这些是为了解决实际问题，Java虚拟机会把每次触发GC的信息打印出来来帮助我们分析问题，所以掌握触发GC的类型是分析日志的基础。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">GC_FOR_MALLOC: 表示是在堆上分配对象时内存不足触发的GC。</div><div class="line"></div><div class="line">GC_CONCURRENT: 当我们应用程序的堆内存达到一定量，或者可以理解为快要满的时候，系统会自动触发GC操作来释放内存。</div><div class="line"></div><div class="line">GC_EXPLICIT: 表示是应用程序调用System.gc、</div><div class="line">VMRuntime.gc接口或者收到SIGUSR1信号时触发的GC。</div><div class="line"></div><div class="line">GC_BEFORE_OOM: 表示是在准备抛OOM异常之前进行的最后努力而触发的GC。</div></pre></td></tr></table></figure>
<h4 id="安卓分配与回收"><a href="#安卓分配与回收" class="headerlink" title="安卓分配与回收"></a>安卓分配与回收</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Android系统并不会对Heap中空闲内存区域做碎片整理。系统仅仅会在新的内存分配之前判断Heap的尾端剩余空间是否足够，</div><div class="line"></div><div class="line">如果空间不够会触发gc操作，从而腾出更多空闲的内存空间。</div><div class="line"></div><div class="line">  在Android的高级系统版本里面针对Heap空间有一个Generational Heap Memory的模型，</div><div class="line"></div><div class="line">这个思想和JVM的逐代回收法很类似，就是最近分配的对象会存放在Young Generation区域，</div><div class="line"></div><div class="line">当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。</div><div class="line"></div><div class="line">系统会根据内存中不同的内存数据类型分别执行不同的gc操作。</div></pre></td></tr></table></figure>
<h2 id="内存优化意义"><a href="#内存优化意义" class="headerlink" title="内存优化意义"></a><strong>内存优化意义</strong></h2><p>通过上面的分析，可以总结出内存优化主要有以下几个意义:</p>
<ul>
<li><p>减少OOM，提高应用稳定性</p>
</li>
<li><p>减少卡顿，提高应用流畅度</p>
</li>
<li><p>减少内存占用，提高应用后台运行时的存活率</p>
</li>
<li><p>减少异常发生，减少代码逻辑隐患</p>
</li>
</ul>
]]></content>
      <categories>
        <category>优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github+Next+GoDaddy搭建博客</title>
    <url>/2019/07/13/Hexo-Github-Next-GoDaddy%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006cL6EBjw1f5z9r5crsqj30ys0hujts.jpg" alt=""><br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><hr>
<ul>
<li><font size="4">Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。<a href="https://github.com/hexojs/hexo" target="_blank" rel="external">hexo github链接</a><p></p></font></li>
<li><font size="4">Github开源社区<a href="https://github.com/" target="_blank" rel="external">Github</a></font></li>
<li><font size="4">Github Pages,用于介绍托管在GitHub的项目， 不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。<a href="https://pages.github.com/" target="_blank" rel="external">Github Pages</a></font></li>
<li><font size="4">Hexo主题中star最多的一种<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">Next</a></font></li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a><strong>准备工作</strong></h2><hr>
<ul>
<li><p><font size="4">GitHub(创建仓库,SSH,pages关联hexo,仓库分支)<a href="http://blog.sina.com.cn/s/blog_6e572cd60101qls0.html" target="_blank" rel="external">配置教程</a>)<p><br>-注：Github Pages的Repository名字是特定的(github账号.github.io)。</p>
<ul>
<li><font size="4">安转Node.js(<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js官网</a>下载相应平台的最新版本)<p></p></font></li>
<li><font size="4">安装<a href="https://git-scm.com/download" target="_blank" rel="external">Git</a><p></p></font></li>
<li><font size="4">Atom等MD编辑器.<h2 id="开始安装Hexo"><a href="#开始安装Hexo" class="headerlink" title="开始安装Hexo"></a><strong>开始安装Hexo</strong></h2></font></li>
</ul>
<hr>
<p><font size="4">Node.js和Git都安装好后,首先创建一个文件夹,如blog,用户自定义的hexo安装文件夹,然后cd进入blog目录里安装Hexo。</font></p>
<p><font size="4">执行如下命令安装Hexo：</font></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> cd 你的Hexo安装目录(blog) 执行</div><div class="line"></div><div class="line">sudo npm install-g hexo</div></pre></td></tr></table></figure>
<p><font size="4">然后初始化hexo,命令:</font></p>
<p><code>hexo init</code></p>
<p><font size="4">OK，至此，全部安装工作已经完成！blog就是你的博客根目录，所有的操作都在里面进行.之后的操作都需要cd 到你的blog目录.</font></p>
</font></p></li>
</ul>
<h2 id="静态页面"><a href="#静态页面" class="headerlink" title="静态页面"></a><strong>静态页面</strong></h2><hr>
<p> <font size="4">上一步我们已经安装了hexo,生成了blog.<p><br> 之后在blog目录,找到_config.yml文件,这就是我们的站点配置文件,可以在此文件中修改我们的配置信息.修改配置文件的教程不多说<a href="https://hexo.io/docs/configuration.html" target="_blank" rel="external">传送门</a></p>
<p> <font size="4">修改的差不多,就可以本地预览下我们的网站了:</font></p>
<p> 生成静态页:</p>
<p> <code>hexo generate</code>(简写hexo g)</p>
<p> 本地启动:</p>
<p> <code>hexo server</code>(简写hexo s)</p>
<p> 浏览器输入(localhost:4000),预览我们的博客了,如果打不开,有可能端口被占用了,这时候我们可以指定端口号,命令如下:</p>
<p> <code>hexo s -p 4001</code>(根据指定的端口号浏览博客)</p>
<h2 id="部署到GitHub上"><a href="#部署到GitHub上" class="headerlink" title="部署到GitHub上"></a><strong>部署到GitHub上</strong></h2><hr>
<p>上一步我们已经可以本地预览我们的blog了,当然本地看到是远远不够,现在开始关联github让我们的blog可以分享给更多的小伙伴.</p>
<h4 id="建立GitHub仓库"><a href="#建立GitHub仓库" class="headerlink" title="建立GitHub仓库"></a>建立GitHub仓库</h4><p>进入github账号,创建与你用户名对应的仓库，仓库名必须为[your_user_name.github.io]，固定写法不可修改</p>
<p>之后修改我们的配置文件_config.yml,翻到最下面,增加github配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">deploy:</div><div class="line"></div><div class="line">     type: git</div><div class="line"></div><div class="line">     repo: 你自己的仓库地址</div><div class="line"></div><div class="line">     branch: master</div></pre></td></tr></table></figure>
<p>然后执行命令(记住所有的操作都是在你的blog目录下)：</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>最后执行:</p>
<p><code>hexo deploy</code>(博客部署,提交到仓库)</p>
<h4 id="Hexo目录结构"><a href="#Hexo目录结构" class="headerlink" title="Hexo目录结构"></a>Hexo目录结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy_git：#将public文件夹的内容提交到Github后生成，内容与public文件夹基本一致</div><div class="line">├── node_modules：#用来存储已安装的各类依赖包</div><div class="line">├── public  #将source文件夹里的Markdown文档，转换成index.html。再结合主题进行渲染，就是我们最终看到的博客</div><div class="line">├── scaffolds #模板文件夹,当您新建文章时，根据 scaffold生成文件,包含page，post，draft三种模板，分别对应 页面、要发布的文章、草稿</div><div class="line">├── source  #资源文件夹,用来存放图片、Markdown文档（文章、草稿）、各种页面（分类、关于页面等）</div><div class="line">|   └── _posts #博客文章目录</div><div class="line">└── themes #主题 </div><div class="line">├── _config.yml   #网站的配置信息。标题、网站名称等</div><div class="line">├── db.json：#source解析所得到的</div><div class="line">├── package.json  # 用来查看Hexo的版本以及相关依赖包的版本</div></pre></td></tr></table></figure>
<h4 id="source-，-public-和-deploy-git"><a href="#source-，-public-和-deploy-git" class="headerlink" title="source ， public 和 .deploy_git"></a>source ， public 和 .deploy_git</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">这三者的关系大致是：source -&gt; public -&gt; .deploy_git</div><div class="line"></div><div class="line">执行hexo generate，根据source，更新 public。</div><div class="line">执行hexo deploy，根据public，更新 .deploy_git。</div></pre></td></tr></table></figure>
<p><a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="external">Hexo配置</a></p>
<h3 id="Hexo会默认安装"><a href="#Hexo会默认安装" class="headerlink" title="Hexo会默认安装"></a>Hexo会默认安装</h3><ul>
<li>hexo：主程序</li>
<li>hexo-deployer-git：实现git部署方式</li>
<li>hexo-generator-archive：存档页面生成器</li>
<li>hexo-generator-category：分类页面生成器</li>
<li>hexo-generator-index：index生成器</li>
<li>hexo-generator-tag：标签页面生成器</li>
<li>hexo-renderer-ejs：支持EJS渲染</li>
<li>hexo-renderer-marked：Markdown引擎</li>
<li>hexo-renderer-stylus：支持stylus渲染</li>
<li>hexo-server：支持本地预览，默认地址 localhost:4000</li>
</ul>
<p>之后我们就可以在浏览器输入[your_user_name.github.io],好了赶快撰写文章,分享你的blog吧.</p>
<h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a><strong>Hexo常用命令</strong></h2><hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo new&quot;postName&quot; #新建文章</div><div class="line"></div><div class="line">hexo new page&quot;pageName&quot; #新建页面</div></pre></td></tr></table></figure>
<p><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="external">传送门</a></p>
<h2 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a><strong>Next主题</strong></h2><hr>
<p>网站部署好后,开始设置Next主题</p>
<h4 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装Next主题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cd your-hexo-site</div><div class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
<h4 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h4><p>和所有的主题启动一样,打开_config.yml,找到theme字段,修改为next</p>
<p>之后我们可以hexo g ,hexo s,localhost:4000本地浏览一下</p>
<h4 id="主题类型设置"><a href="#主题类型设置" class="headerlink" title="主题类型设置"></a>主题类型设置</h4><p>选择 Scheme</p>
<p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme，他们是：</p>
<ul>
<li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白<p></p></li>
<li>Mist - Muse 的紧凑版本，整洁有序的单栏外观<p></p></li>
<li>Pisces - 双栏 Scheme，小家碧玉似的清新<p></p></li>
<li>Scheme 的切换通过更改 主题配置文件，搜索 scheme 关键字。 你会看到有三行 scheme 的配置，将你需用启用的 scheme 前面注释 # 即可</li>
</ul>
<p>这里我启用的是Mist</p>
<h4 id="Next配置修改"><a href="#Next配置修改" class="headerlink" title="Next配置修改"></a>Next配置修改</h4><ul>
<li>侧边栏头像  <code>avatar: /uploads/avatar.jpg(你头像的路径)</code><p></p></li>
<li>菜单   <code>menu</code><p></p></li>
<li>设置语言  <code>language: zh-Hans</code><p></p></li>
<li>修改背景色 next-&gt;source-&gt;css-&gt;_schemes(启用哪个类型选哪个文件夹)-&gt;Mist-&gt;index.styl 最上边第一行加<code>body { background:url(/images/background.jpg)(图片路径,或者#ffffff颜色);}</code><p></p></li>
<li>等等修改<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">官网教程</a><p></p></li>
</ul>
<h4 id="MarkDown语法简单介绍"><a href="#MarkDown语法简单介绍" class="headerlink" title="MarkDown语法简单介绍"></a>MarkDown语法简单介绍</h4><p><img src="https://user-images.githubusercontent.com/11883853/68834565-10fb2180-06f1-11ea-9af1-d977ac74aee7.png" alt="MarkDown"></p>
<blockquote class="blockquote-center">参考链接</blockquote>

<ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo中文文档</a></li>
<li><a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="external">绑定github个人博客到GoDaddy</a></li>
<li><a href="https://segmentfault.com/a/1190000017986794" target="_blank" rel="external">超详细Hexo+Github Page搭建技术博客教程</a></li>
<li><a href="https://www.jianshu.com/p/0b1fccce74e0" target="_blank" rel="external">利用Hexo在多台电脑上提交和更新github pages博客</a></li>
<li><a href="https://github.com/hexojs/hexo/wiki" target="_blank" rel="external">Themes</a></li>
<li><a href="https://dcc.godaddy.com/manage/lzhblog.site/dns" target="_blank" rel="external">GoDaddy</a></li>
</ul>
</font></p>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub</tag>
        <tag>Next</tag>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币闯关东03 | 探店中国首家区块链餐厅，开启高校撩妹之旅</title>
    <url>/2018/11/30/note/article11302/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>比特币闯关东03 | 探店中国首家区块链餐厅，开启高校撩妹之旅</strong><br> 镇赫啊，真担心你被妹子的男朋友暴打！<br> <img src="https://user-images.githubusercontent.com/11883853/49281293-2b7bc100-f4c7-11e8-9862-d283d4bac7a8.png" alt="1"></p>
<p> 在辽阳市告别“上古钱币”后，二饼兄弟一路颠簸来到了辽宁省省会——沈阳市！在沈阳站的附近，有一家区块链餐厅，是国内首家区块链主题餐厅。<br> <img src="https://user-images.githubusercontent.com/11883853/49281294-2c145780-f4c7-11e8-9397-6f4300273ee5.png" alt="2"><br> 在老板和老板娘的热心帮助下，二饼兄弟成功用比特币换到了接下来所有行程的火车票，简直机智爆表。<br> <img src="https://user-images.githubusercontent.com/11883853/49281296-2c145780-f4c7-11e8-99f2-344d859b53be.png" alt="3"><br> 在区块链餐厅吃饱喝足后，两人开始开始着手完成节目组发来的刁钻任务——给至少50个人讲明白区块链、比特币是什么。<br> <img src="https://user-images.githubusercontent.com/11883853/49281297-2cacee00-f4c7-11e8-8ae9-34abdb191833.png" alt="4"><br> 显然50个人的任务难度根本不足以难住他们，他们决定，转移战地至王浩的母校——沈阳建筑大学。<br> <img src="https://user-images.githubusercontent.com/11883853/49281298-2d458480-f4c7-11e8-8ded-2e1fc115088f.png" alt="5"><br> 在沈阳建筑大学创业孵化基地中，二饼兄弟为学弟学妹们讲解了区块链与比特币，并分享了他们的创业故事。<br> <img src="https://user-images.githubusercontent.com/11883853/49281301-2d458480-f4c7-11e8-8856-24ec66e3aa91.png" alt="6"><br> 最后，在温馨的小旅店中，二饼兄弟结束了一天的疲惫，睡个美容觉，迎接明天的挑战吧~<br><img src="https://user-images.githubusercontent.com/11883853/49281293-2b7bc100-f4c7-11e8-9862-d283d4bac7a8.png" alt="1"></p>
<p>旅程下一站是辽宁铁岭市，二饼兄弟又将遇到什么样的奇葩经历呢？<br>每周四晚20：00，锁定爱奇艺科技频道，<br>订阅“链客时间”<br>大型比特币生存挑战真人秀<br>《二饼兄弟比特币闯关东》震撼来袭！<br><img src="https://user-images.githubusercontent.com/11883853/49281068-92e54100-f4c6-11e8-9541-19ae2e9ff32c.png" alt="8"></p>
<p>《比特币漂游记》是全球首个中韩联合出品的比特币真人秀节目，爱奇艺科技频道独家首播推荐、映客直播top10顶级资源位推荐、全球领先的去中心化社交网络ONO与95后cool girl的娱乐社区不就提供社群支持。Facebook、youtube全球同步宣发，70余家区块链媒体战略合作。<br><img src="https://user-images.githubusercontent.com/11883853/49281070-937dd780-f4c6-11e8-983a-9f15c106f865.png" alt="9"></p>
]]></content>
  </entry>
  <entry>
    <title>比特币闯关东02 | 险些饿死火车上，再遭老板娘三连惨拒</title>
    <url>/2018/11/30/note/article1130/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>比特币闯关东02 | 险些饿死火车上，再遭老板娘三连惨拒</strong></p>
<p> <img src="https://user-images.githubusercontent.com/11883853/49281061-9082e700-f4c6-11e8-9ef5-af5790b69cee.png" alt="1"></p>
<p> 二饼兄弟继续北上，片尾有小姐姐，不要错过哦！</p>
<p><img src="https://user-images.githubusercontent.com/11883853/49281062-911b7d80-f4c6-11e8-972f-543478376523.png" alt="2"><br> 经过了24小时的漫长旅程，二饼兄弟还是没有成功用比特币吃到饭，生无可恋的他们差点饿死在火车上……<br> <img src="https://user-images.githubusercontent.com/11883853/49281063-911b7d80-f4c6-11e8-8313-52e5f860e1de.png" alt="3"></p>
<p> 到了辽阳市，接到了节目组发来的任务——带着比特币，到辽阳博物馆与古代钱币合影，并为镇赫讲解中国古代钱币文化。</p>
<p> <img src="https://user-images.githubusercontent.com/11883853/49281064-91b41400-f4c6-11e8-882f-14f673f533ff.png" alt="4"></p>
<p> 但是，他们决定，先找饭吃，去他的任务！<br> 然而现实却非常残酷，二饼兄弟遭遇了意料之中的三连拒……<br> <img src="https://user-images.githubusercontent.com/11883853/49281065-91b41400-f4c6-11e8-9033-4e25b71849ba.png" alt="5"></p>
<p> 直到他们走进了一家试营业的餐厅，成功说服了美腻的老板娘，接受了比特币支付，并且餐厅以后也长期接受比特币支付啦！<br> <img src="https://user-images.githubusercontent.com/11883853/49281066-924caa80-f4c6-11e8-9cf2-dbfc4db81971.png" alt="6"></p>
<p> 第二天上午，二饼兄弟来到了辽阳博物馆，成功完成了任务。“上古钱币”与比特币成功会面！<br> <img src="https://user-images.githubusercontent.com/11883853/49281067-92e54100-f4c6-11e8-9b6c-23d19cacd80e.png" alt="7"></p>
<p> 挑战下一站是辽宁沈阳市，二饼兄弟又将遇到什么样的奇葩经历呢？</p>
<p> <img src="https://user-images.githubusercontent.com/11883853/49281068-92e54100-f4c6-11e8-9541-19ae2e9ff32c.png" alt="8"></p>
<p> 每周四晚20：00，锁定爱奇艺科技频道，<br> 订阅“链客时间”<br> 大型比特币生存挑战真人秀<br> 《二饼兄弟比特币闯关东》震撼来袭！</p>
<p> 《比特币漂游记》是全球首个中韩联合出品的比特币真人秀节目，爱奇艺科技频道独家首播推荐、映客直播top10顶级资源位推荐、全球领先的去中心化社交网络ONO与95后cool girl的娱乐社区不就提供社群支持。Facebook、youtube全球同步宣发，70余家区块链媒体战略合作。<br> <img src="https://user-images.githubusercontent.com/11883853/49281070-937dd780-f4c6-11e8-983a-9f15c106f865.png" alt="9"></p>
<p> 更多区块链视频，欢迎关注链客时间</p>
]]></content>
  </entry>
  <entry>
    <title>比特币闯关东01 | 大连老司机：比特币谁不知道啊？</title>
    <url>/2018/11/09/note/article1109/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>比特币闯关东01 | 大连老司机：比特币谁不知道啊？</strong></p>
 <iframe height="498" width="510" src="http://player.youku.com/embed/XMzkxMDg4ODc0NA==" frameborder="0" 'allowfullscreen'=""></iframe>

<p> 《二饼兄弟比特币漂游记第一季—比特币闯关东》正式开播啦！10月23日，二饼兄弟王浩与李振赫分别从北京与韩国出发，到达了中国东北大连市，开始一场长达11天的比特币闯关东之旅。</p>
<p>一位94年的中国区块链媒体创始人，和一位精通中、韩、英三语的清华大学韩国留学生，一个搞笑担当，一个卖萌担当，就这么擦出了友（ji）谊（qing）的火花！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/N4SA3B9NqNjkXrRlemYUiaqDCTmwkRb9wAr2QqJxmBicX4IJK3ahcKVU4h0htV4gUnn0A9CvqIQibMQNWibOFMa0nw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="9"> <img src="https://mmbiz.qpic.cn/mmbiz_png/N4SA3B9NqNjkXrRlemYUiaqDCTmwkRb9wiaEgdeUCBgRMUeicSxtLITU6AzkXK6hYicicxxWQec4wFw4B3Xl2ckEnpA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="9"><br>在大连市，二饼兄弟不仅成功用比特币打到了出租车，而且还偶遇了一位从天而降的“东北活雷锋”，顺利完成了大连市的挑战任务——利用比特币解决住宿问题。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/N4SA3B9NqNjkXrRlemYUiaqDCTmwkRb9w8iaWbbScyTPkhFsiavYcoD5EstDVdjZPvDrSDic9un3kjVf0u1YiaN2uTw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="1"><br><img src="https://mmbiz.qpic.cn/mmbiz_png/N4SA3B9NqNjkXrRlemYUiaqDCTmwkRb9wibickEpXos6FMhbBUldQT4LYDyhF7JP5qRFWFOnQIaPibyUmic8Y6XGxvQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="2"><br>挑战下一站是东北辽阳市，二饼兄弟又将遇到什么样的奇葩经历呢？</p>
<p>每周四晚20：00，锁定爱奇艺科技频道，订阅“链客时间”</p>
<p>大型比特币生存挑战真人秀</p>
<p>《二饼兄弟比特币闯关东》震撼来袭！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/N4SA3B9NqNhCgKouKjthnSiaiaVwcjasNialjB6XqFKns2dOrU2w1z7rsTE0235M1g3TPhYX2g73pspnwPuyNnTvA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="3"></p>
]]></content>
  </entry>
  <entry>
    <title>每家交易所都有一个扭转熊市的梦想，币贝能实现吗</title>
    <url>/2018/10/31/note/article1031/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>每家交易所都有一个扭转熊市的梦想，币贝能实现吗</strong></p>
<p> 今年数字货币的风口换得很快，一波接着一波: 在2017年的时候，很多人觉得发币很赚钱，于是开始疯狂发币。等各家的项目人气攒得差不多时，准备上市; 然而面对交易所的高门槛，他们又想自己开交易所。于是一帮提着钱的非正规金融人，造就了今年的交易所遍地开花的空前盛事。</p>
<p>随后很多交易所快速膨胀，潮落后则销声匿迹。交易所也从之前的野蛮生长衰落到现在的纷纷歇业。交易所本来处于整个行业的上游，为何大部分交易所落得如此田地？说明这些交易所根本不具备核心竞争力。</p>
<p>然而在交易所市场热度下降的时候，有一个叫币贝(ExShell)的交易所逆势而为，还没上线就狂撒美金，团队阵容颇有气魄，所以，他们必然有自己的杀手锏，让我们来一起看看币贝交易所的核心竞争力吧！</p>
<p>一、币圈金融交易所，综合素质有待提高</p>
<p>全球数字货币交易所千家以上，但真正能够让人们脱口而出的交易所却是凤毛麟角，OKEX，币安，火币，Bithumb。据调查，他们普遍处于拓展版图阶段，靠交易抽佣和期货合约为交易所造血：</p>
<p>然而从金融服务的角度上来说，这些远远不够。 从金融衍生品和交易需求的层面的角度来说，有些交易所的功能已经跟不上用户的需要了，从商业价值来说，似乎这些老牌的一线交易所也没有更好的商业模式出现。</p>
<p>因此，交易所为了增加活跃用户，会接受一些质量不佳的项目方，以谋取高额上币费用。比如OKEX集团投资的WFEE项目，跑路前公然挑衅投资者，对交易所的品牌口碑和投资人带来了双向的伤害。</p>
<p>（嚣张的项目方）</p>
<p>现货市场行情不好，很多小伙伴开始玩起了合约，不知道你有没有听过这个段子“一买合约深似海，一买OK就爆仓。”</p>
<p>这不仅仅是段子，更是血淋淋的事实。据悉，大部分人是在做合约时，因人为因素被爆仓（比如在止损的瞬间突然黑屏闪退，无法交易）。“徐明星”和“OKEX交易所北京总部维权”等关键词一度成为热搜。</p>
<p>像OKex这样的交易所尚且有很多这样的事情出现，其他小的交易所更不用多说，在目前行情低迷的情况下他们如何谋生？每个月都要拿出高额的费用来维护，在寒冬中这些交易所能支撑多久？最终会不会被黑客攻破最终破产？</p>
<p>这些问题真的能够让投资人安心把钱放到这个交易所吗？很难!</p>
<p>二、币贝底层核心：三大保障，安全为王<br>很多新上线的交易所到底怎么样才能在没有行情、没有技术团队、没有风控下的情况下运营好一个交易所？当下，投资人一定是要找一个安全、可靠、有保障的交易所进行投资。</p>
<p>币贝交易所的注册地在塞舌尔，是全球首家数字金融交易所。旗下拥有两个科研公司。在服务器硬件、金融交易系统以及私钥管理和其它开发需求有着强有力的支持：</p>
<p>世界顶级的安全团队，并设立硅谷安全实验室，自主研发出单向传输光闸、冷热分离，币贝交易所采用了顶级安全加固的交易所系统+国家金融安全级冷钱包确保交易所资产的绝对安全。</p>
<p>（单项传输光闸）</p>
<p>（系统及硬件安全）</p>
<p>而对于软件方面，币贝拥有高效的金融交易系统，能够有效迎接海量用户同时交易：每秒超过百万级的高效撮合系统，具备无限制的横向扩展能力；基于内存数据库的实时处理能力，随时提供最佳的交易体验；Hadoop、Elastic Search等大数据系统的分析能力，全面保障实时风控和交易所业务决策。</p>
<p>除此之外，私钥的保护也很关键。每一个区块链账户都有一个私钥，这个私钥决定了整个账户的资产安全，就连头部交易所币安也有频繁的被盗事件。</p>
<p>（交易所成为黑客的眼里的肥肉）</p>
<p>币贝针对于黑客频繁攻击交易所的痛点，设计了一套防御方案：光电隔离技术，黑客没有办法通过网路手段访问系统的服务端口，而节点之间传输通过非对称密钥加密，可信任公钥通过离线方式配置进入离线签名机。机房则有着安全防护的设施，密码操作都在安全屋固定电脑上操作。同时机房有视频监控。</p>
<p>有了物理的安全与较为完善的金融操作系统，交易所和交易所内的其它金融产品也变得更加可靠。这些都是由币贝世界级精英团队开发的。币贝的管理团队来自华尔街、硅谷、伦敦证券交易所、港交所、IBM、BAT、汤森路透、火币等知名企业，在金融行业有着丰富的经验与行业资源。</p>
<p>（币贝将对标全球前五大金融交易所）</p>
<p>三、逆势杀手锏: 金融服务和社会使命</p>
<p>现在币圈的交易所产品线还较为单一，为了让金融交易所走向更为正规的发展方向，币贝开发了丰富的金融产品，包括币币交易、法币交易、贝壳宝、机构账户、量化云、期货合约、多倍杠杆、指数、数据服务、数字资产借贷、数字资产理财……满足全球投资者丰富的投资需求。</p>
<p>但是，一个真正能运作良好且正规的金融交易所，只维系好投资人关系还远远不够。币贝旗下有两个与金融强相关的公司，让币贝在资产管理方面更有理由做得更好。</p>
<p>新加坡的金融服务公司Global Linking服务全球区块链企业，为全球交易所提供运营、市场、金融、合规等服务；以及新加坡注册的ExShell Fund全球投资管理公司，在全球范围内甄选具备行业竞争力的企业进行投资，提供通证融资、上市和市值管理服务。这样一来，就能解决部分项目方因为只有科研能力，没有资产管理和维护的经验导致退市的问题。</p>
<p>由于币贝团队在金融领域颇有建树，因此也更容易定向邀约到一些机构投资者：如美国、中国、德国、日本、法国、英国、迪拜、阿联酋、瑞士、新加坡等国家投资基金以及美国的桥水联合基金、英国3i集团、巴菲特基金、索罗斯量子基金、软银集团愿景基金等投资型基金，高盛集团、摩根士丹利、花旗银行、摩根大通、蚂蚁金服等公司旗下投资基金。</p>
<p>（专业视角，专业建议）</p>
<p>对于股东管理方面，币贝采用 “弱中心化”管理模式，币贝每季度召开全球股东大会，核心管理团队拥有20%的决策权，特许邀约股东、全球社群股东和革新委员会（暂定）拥有80％的决策权。币贝由全球数十个知名投资机构与数百个社群共同投资，并作为币贝的股东参与核心经营决策。</p>
<p>币贝获得顶级资本的信任和全球社群资源的支持，股东们的专业态度和全球资源将最大程度地帮助币贝快速成长。币贝也会将交易所产生的大数据整理，定期发布币贝经营报告和财报，为全球机构用户提供全方位的数字金融投资服务。</p>
<p>投资人的每一次交易都能获得金融数字化的技术的帮助，投资决策会更加精准，并且通过足量咨询实时可以了解项目近况，真正做到投资心中有数，持币心中不慌的理性决策，形成良性的交易生态。</p>
<p>前段时间我的朋友和我说某某交易所跑路了，它里面还有几十个ETH，现在欲哭无泪。在我看来，不论你是新人也好老人也罢，选择交易所最重要的就是安全，其次才是盈利，而币贝这四把锁牢牢地锁住了安全。</p>
<p>币贝交易所的体系决定了它能在科技研发、资产管理、金融服务都有杰出表现，成为 “传统金融向数字金融” 进化的推动者。币贝对标全球前五大金融交易所的商业模式和金融产品，运用成熟的金融数字化技术，为全球价值投资者提供更加前沿、高效的数字金融产品服务。</p>
<p>币贝交易所将于11月1日正式面向全球用户，正值上线之际，币贝发起了一个充值即送美金的活动：<br>10月25日-10月31日期间，充值用户每人送100美金ET，并且可以额外瓜分666万美金ET。<br>10月25日-10月31日期间，充值价值超过20美金任一币种的，累计达到10万及以上充值用户，则共同瓜分价值100万美金等额的ET；累计达到20万及以上充值用户，共同瓜分价值300万美金等额的ET；累计达到30万及以上充值用户，共同瓜分价值666万美金等额的ET。目前公测阶段，需要在电脑端操作，后期APP上线可手机端操作。金融大玩家和币圈小白都适用，值得一看！网址：www.exshell.com</p>
<p>在行业鼎盛的时候做得好那是踩上风口，猪都可以起飞。在目前整个交易市场萎缩且交易所纷纷歇业的时间里，币贝交易所却逆势而为，币贝的团队对自己交易所的信心可见一斑。乱世出英豪，币贝数字金融交易所能否在交易所红海中杀出重围最终登顶？让我们拭目以待。</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>数字金融交易服务或成交易所发展的最终道路</title>
    <url>/2018/10/30/note/article1030/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>数字金融交易服务或成交易所发展的最终道路</strong></p>
<p> 世界正在悄悄改变——“币贝ExShell：对标全球前五大金融交易所的商业模式和金融产品的交易所”</p>
<p>在一次金融界的聚会中，和硅谷朋友聊到了“全球化”这个概念——如今的我们，置身于一个数据、科技、 市场与产品急速迭代、个性化交易与市场大混乱的时代，立足“交易所比项目方还多”的新形势下看待未来的交易，应该有什么改变？</p>
<p>交易所需要捕捉哪些正确的交易点？哪些布局，是一个优秀的交易所必须提前考虑的？哪些服务，目前看来无法盈利，其实未来会散发万丈光芒？</p>
<p>朋友们达成的最大共识就是，无论未来区块链的命运如何，优秀区块链企业的共性和想法都是近乎一致的。</p>
<p>无非几点：<br>定位<br>使命<br>价值观<br>文化<br>工作标准<br>行动优先级</p>
<p>区块链企业中，当然包括数字货币交易平台，因为单调枯燥的交易方式，相对于传统金融和股票行业，现有的数字货币交易平台的交易方式被戏谑为“跑得快”式交易平台。唯有解决目前多而杂的交易所暴露出的缺点，才能做出一个成熟、完美、稳健的交易平台。</p>
<p>许多交易平台产品如飞蛾扑火般贡献了自己的短暂生命，币贝（ExShell）交易所的出现将逐步扭转这样的颓势。</p>
<p>因为币贝一开始就不同于其他对行业认知度不高的“入场者”，他对交易对象行为有着高度的理解。</p>
<p>怎么说呢？</p>
<p>任何“交易所”都应该是一家大数据公司，本质上说更应该是数据分析公司。</p>
<p>他必须了解用户是在什么时空、什么驱动力、什么交易频次、什么预期、什么路径获得信息决定交易。交易所不能简单地像目前这样对用户的交易行为一无所知。</p>
<p>币贝是一家大数据技术交易所，它为市场提供金融级别的数据服务，甚至有计划以此盈利。这样的数据能力，面对小打小闹的波动，完全可以无所畏惧。</p>
<p>这也就是我为什么特别偏爱他的原因。</p>
<p>当然，数据服务只是币贝对标全球前五大金融交易所的商业模式和金融产品的冰山一角。未来币贝将向市场提供包括但不限于币币交易，法币交易，贝壳宝、机构账户、量化云、期货合约，多倍杠杆，指数，数字资产借贷，数字资产理财等服务，从广度和深度满足不同投资者的个性化投资需求。</p>
<p>为币贝的业务内容提供强有力支撑的，是币贝</p>
<p>高效的金融交易系统</p>
<pre><code>每秒超过百万级的高效撮合系统；
基于内存数据库的实时处理能力，提供最佳的交易体验；
金融级别的数据接入发布系统，支持量化交易策略；
Hadoop、Elastic Search等大数据系统的分析能力，全面保障实时风控和交易所业务决策；
交易系统具备无限制的横向扩展能力。
</code></pre><p>全球精英团队</p>
<pre><code>管理团队来自华尔街、硅谷、伦敦证券交易所、港交所、IBM、BAT、汤森路透、火币等知名企业。
</code></pre><p>弱中心化管理模式</p>
<pre><code>全球数十个知名投资机构和数百个社群共同投资币贝，并作为币贝的股东参与核心经营决策。核心管理团队拥有20%的决策权，特许邀约股东、全球社群股东和革新委员会（暂定）拥有80％的决策权。
</code></pre><p>与“跑得快”交易平台往往无安全团队或者安全意识差，服务器处于易被攻击的裸奔状态不同的是，币贝研发了高效的金融交易系统，每秒超过百万级的高效撮合系统，具备无限制的横向扩展能力；基于内存数据库的实时处理能力，随时提供最佳的交易体验；Hadoop、Elastic Search等大数据系统的分析能力，全面保障实时风控和交易所业务决策。</p>
<p>对投资者来说，区块链是一个有充分红利的市场。别看现在人人心有戚戚，其实大家都明白，目前的市场，处于去泡沫的过程中，所有人都在经历这一价值重估的阵痛期，但面对引领人类未来的科技发展趋势，我只想每天都劝你入场，因为每一天都是入场的最好时机。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47692343-417c3480-dc30-11e8-83b9-e5fdd2070ecf.png" alt="9"></p>
<p>2013年6月排名Top20的数字货币，只剩两个还留在2017年6月的Top20行列，也就是说除了比特币和莱特币，绝大部分都已经归零。</p>
<p>但是幸存下来的都成了这个时期的王者。</p>
<p>所以你会发现，区块链和互联网的投资逻辑实际是一致的——都是穿越牛熊，成为浪潮中的幸存者。</p>
<p>入场从币贝这样的区块链企业下手就很好。币贝获得了顶级资本的信任和全球社群资源的支持，股东们的专业态度和全球资源将最大程度地帮助币贝快速成长。成长的红利，有一份是你的。</p>
<p>币贝正把看似失控的东西，做得井井有条、有条不紊。</p>
<p>币贝还给新朋友们准备了一些福利：<br>10月25日-10月31日期间，充值用户每人送100美金ET，并且可以额外瓜分666万美金ET。<br>10月25日-10月31日期间，充值价值超过20美金任一币种的，累计达到10万及以上充值用户，则共同瓜分价值100万美金等额的ET；累计达到20万及以上充值用户，共同瓜分价值300万美金等额的ET；累计达到30万及以上充值用户，共同瓜分价值666万美金等额的ET。</p>
<p>目前公测阶段，需要在电脑端操作，后期APP上线可手机端操作。金融大玩家和币圈小白都适用，值得一看！网址：www.exshell.com</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>交易所获利固然重要，但是安全才是0前边的那个1</title>
    <url>/2018/10/29/note/article10291/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>交易所获利固然重要，但是安全才是0前边的那个1</strong></p>
<p> 从去年的ICO大混战，到平台币大混战，在到现在交易所大混战，我们看到了太多的故事、热点和新闻。<br>项目方跑路，平台币破发再到现在的交易所跑路，早期币圈的共识已经是一地鸡毛，在这样混沌的区块链空间中，在人性的斗争中，有多少人能够恪守本心？有多少项目方能够恪守本心？有多少交易所能恪守本心？<br>最近让人痛心的是某头部交易所竟然偷拔网线，导致众多投资人资金亏损，难道带钱进来的投资人不应该受到交易所的保护吗，交易所反倒成了收割投资人的帮凶？<br>在如此混沌的市场，什么样的交易所才能够真正的做到“公平，公正，公开”？什么样的交易所能够守护客户资金安全？其实，在如此熊市的情况下，交易所更应该做到苦修内功、厚积薄发。</p>
<p>无照经营<br>从年初到现在大家看到上万的项目和上千家的交易所都如雨后春笋般出现，很多交易所都说在海外有执照，注册在某地，属于合法合规的交易所，随后开始兜售平台币。当你真的想看一下他们执照的时候，他们却总是支支吾吾，说自己是代运营中心。</p>
<p>空气项目大本营<br>很多小的交易所为了流量和现金流，只要看到有意愿上币的项目方就可以免费挂牌，也不需要严格的审核，不管项目是否真的有落地和应用场景。</p>
<p>币市的代币只有字母的缩写和LOGO，导致很多对市场不熟悉的投资人巨额亏损。这就好比菜市场买菜，不懂行的消费者容易买到质量不好的菜(假设蔬菜外观良好)。</p>
<p>交易所运营不善<br>很多交易所的老板和投资人对区块链不了解，投资的初心也是为了盈利。因为大家都知道“赌场最赚钱”。当交易所系统搭建好之后，没有审核项目的团队或是没有专业的招商人员，有引进劣质项目的风险。</p>
<p>运营不善的交易所往往不了解怎么样去运营金融产品，到最后常常由于客户量少，没有交易深度，砸盘现象严重，客户失去信心而陷入僵局，要么就是没有防范羊毛党的机制，导致整个交易所关停。</p>
<p>风控不严谨<br>很多小交易所初心都是希望能够做得和一线交易所一样规范，他们也扎实去做运营，但是到最后为什么整个交易所还是走向了关闭？<br>主要就是整个风控没有跟上，导致整个资金流断裂，或者因为部分运营的风险未能及时发现。</p>
<p>外包带来的巨大隐患<br>很多交易所自己没有钱去开发自己的交易软件，更多的是把软件开发外包给外面的技术开发公司。一些公司图省事，交易所代码也是买来的，再找几个临时的开发人员修修改改，一个交易所就上线了。</p>
<p>而客户端方面，就连头部交易所的APP，也经常出现闪退，用户体验极差，一到关键时刻系统就出现bug。</p>
<p>于是，很多小的交易所运营了半年之后，纷纷关停服务器，交易所带着投资人的血汗钱消身匿迹。在这里也就不吐槽这些小的交易所。我们一起盘点一下现在的币圈“头部”的交易所，到底他们的运营状况如何。</p>
<p>二．大交易所鲜为人知的秘密</p>
<p>既是裁判员又是运动员，着急就拔电源的OKEX<br>OKEX交易所的徐明星最近又被送上热搜，部分投资人每天都情绪激动地堵在OK总部门口。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47631742-32d74400-db82-11e8-887b-77f6e7ecb224.png" alt="4"></p>
<p>因为OKCoin拔电源太厉害了，在没有监管的币市里，期货合约成为了庄家大肆清洗散户的手段，根本没有任何规矩可言。操纵币价、穿针、滑点、定点爆破，散户只能沦为这些非法操作的鱼肉，而交易所“配合性的瘫痪”令灾难更加不可抗拒。把投资人耍的团团转。造成投资人巨额亏损。</p>
<p>试问：一个既做运动员又做裁判员的交易所怎么样能够做到公平公正公开呢？</p>
<p>被盗，BTC被砸穿的币安<br>3月7号很多人都在睡梦中，早上起床一看BTC在币安暴跌了，随后漫天的帖子就传开了，曾经象征权威，交易额最大的币安被盗币了。<br>虽然币安官方并没有承认，但是最终K线是不会骗人的。有不少用户发现自己币安账户中持有的各种数字货币被市价即时币币交易成了 BTC。因为大量代币被市价抛售，导致绝大部分币种开始下跌，市场中不明真相的散户也纷纷加入了恐慌性抛售。当然，也出现了反向爆拉的币种——在上涨的币种里，VIA（维尔币）成为了黑客影响市场的新目标。黑客操纵的账号在1小时内用1万个比特币拉爆了VIA，市场一片哗然。</p>
<p>7月初，币安再度出现系统问题，网传币安被黑客再度光临，损失了7000个BTC，随后紧急维护。</p>
<p>币安在整个数字货币交易市场中举足轻重，为何频频被黑客光临？可见在币安客户的资产安全性并没有想象中那么高。</p>
<p>USDT的独立行情，火币PRO强制平仓</p>
<p>火币相对来说基本上负面的新闻相对较少，但是在今年5月12日，火币的USDT交易区发生了奇怪的事情：数字货币全线大幅下挫，当日下午2时许，火币Pro上的ONT、IOST、BTM、DTA等多个币种对USDT出现快速下跌，其中IOST在15分钟内暴跌超50%。</p>
<p>火币Pro上的异常暴跌，导致该平台上大量以USDT做现货杠杆交易的用户被强制爆仓，有投资者瞬间损失了价值35万元的USDT。<br><img src="https://user-images.githubusercontent.com/11883853/47631743-336fda80-db82-11e8-9fa5-d19944e8d693.png" alt="5"></p>
<p>“根本来不及操作，连打开电脑的时间都没有。”他说，他在火币Pro上只用了不到2倍的现货杠杆，但没想到这么低的杠杆都会被爆仓。</p>
<p>正常涨跌导致爆仓没啥说的，但这次四个币种同一时间段快速暴跌，很多人连提示短信都没收到，即使收到短信的也来不及操作，平台难辞其咎。</p>
<p>所以，在行情不佳的情况下，投资人应该考虑如何保本。而由于没有选对交易所导致人为事故，更是雪上加霜。如果把一些币放到来路不明的交易所，更可能会导致您血本无归。没有数字资产的安全这个1，后边有再多的0也是0。</p>
<p>三．逆势暖冬——币贝交易所</p>
<p>在整个行情趋熊的行情下，很多区块链企业都在缩减开支，投资人也更加保守，但币贝交易所却在资本寒冬中逆势而上，看来准备充分，信心十足，根据官方透露的信息，我们可以来看看币贝交易所的优势：<br>硬件——支撑交易的安全稳定<br><img src="https://user-images.githubusercontent.com/11883853/47631744-336fda80-db82-11e8-8d98-6b20300179e6.png" alt="6"><br>（单项传输关闸）<br>币贝组建了世界顶级的安全团队，并设立硅谷安全实验室，自主研发出单向传输光闸、意味着想要拔网线这样的操作也将无济于事，这样会让投资人的交易更安全。<br>简单说如果再拔网线电源线，你的交易一样会生成，OK只要敢用这样的设备基本上徐明星就要哭啦。</p>
<p>冷热分离——双重保障<br><img src="https://user-images.githubusercontent.com/11883853/47631747-34087100-db82-11e8-8576-84c03baf7ba1.png" alt="7"><br>币贝交易所采用了顶级安全加固的交易所系统+国家金融安全级别的冷钱包，确保交易所资产的绝对安全。这样能更好地保护客户的资产，投资人再也不用担心黑客入侵。</p>
<p>私钥安全保护措施——光电隔离<br>每一个区块链账户都有一个私钥，这个私钥决定了整个账户的资产安全。币贝针对于黑客频繁攻击交易所的痛点，设计了一套防御方案：光电隔离技术，黑客没有办法通过网路手段访问系统的服务端口；节点之间传输通过非对称密钥加密，可信任公钥通过离线方式配置进入离线签名机。机房则有着安全防护的设施，密码操作都在安全屋固定电脑上操作。同时机房配有视频监控。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47631751-34087100-db82-11e8-8909-36f6e29c612e.png" alt="8"></p>
<p>（系统架构）<br>有了物理的安全，也需要配套的社群激励机制和管理方案，才能保证用户在使用过程中体验最佳，同时在市场还未成熟时，团队核心人员需要对行业极其理解，而币贝的团队就满足这个条件。<br>币贝拥有世界级精英团队，管理团队来自华尔街、硅谷、伦敦证券交易所、港交所、IBM、BAT、汤森路透、火币等知名企业。作为“传统金融向数字金融” 进化的推动者，秉承公平、公正的原则，为全球价值投资者提供安全、稳定、高效、透明的数字金融服务。</p>
<p>合规合法——交易有保障<br>币贝交易所的注册地在塞舌尔，全球领先的数字金融交易所，旗下拥有两个科研公司。在服务器硬件、金融交易系统以及私钥管理和其它开发需求有着强有力的支持。</p>
<p>在目前熊市下，很多交易所纷纷倒闭，投资人不单单要看到眼前的利益，也要看到背后的风险，找一个正规的交易所保证交易所数字资产的安全，才有机会在牛市来临的时候乘风破浪。</p>
<p>币贝交易所可谓是全球最安全的交易所，为了让客户更好地享受到币贝交易所的服务，币贝推出了很多重磅福利：<br>10月25日-10月31日期间，充值用户每人赠送100美金ET；<br>10月25日-10月31日期间，充值价值超过20美金任一币种的，累计达到10万及以上充值用户，则共同瓜分价值100万美金等额的ET；<br>累计达到20万及以上充值用户，共同瓜分价值300万美金等额的ET；<br>累计达到30万及以上充值用户，共同瓜分价值666万美金等额的ET。<br>目前公测阶段，需要在电脑端操作，后期APP上线可手机端操作。金融大玩家和币圈小白都适用，值得一看！网址：www.exshell.com</p>
<p>四、币贝的社会使命感<br>除了对投资人友好，币贝也将用高科技整合大数据，对行业做出贡献。真正做到交易安全、私钥保存安全、数据安全。在服务和金融产品研发中，对标全球前五大金融交易所，运用成熟的金融数字化技术，为全球价值投资者提供更加前沿、高效的数字金融产品服务。</p>
<p>币贝未来将与全球数万家顶级的投资机构建立合作，定期发布币贝的经营报告和财报，为全球机构用户提供全方位的数字金融投资服务，让我们拭目以待吧！</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>全球首家数字金融交易所币贝（ExShell）高调上线 行业再掀风浪</title>
    <url>/2018/10/29/note/article1029/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>全球首家数字金融交易所币贝（ExShell）高调上线 行业再掀风浪</strong></p>
<p> 据悉，新加坡时间11月1日10:30，全球首家数字金融交易所币贝（ExShell）即将上线。10月25日-10月31日期间，用户充值即送100美金ET，累计达到10万及以上充值用户，则共同瓜分价值100万美金等额的ET；累计达到20万及以上充值用户，共同瓜分价值300万美金等额的ET；累计达到30万及以上充值用户，共同瓜分价值666万美金等额的ET。除此之外，币贝还将接连推出更多用户激励活动，包括：充值送ET、返还手续费、抽奖送ET等。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47600247-ced14600-d9f0-11e8-8cc0-3bb0089ec3c4.png" alt="1"></p>
<p>数字金融是世界关注的焦点，全球大部分国家都在借助区块链技术实现金融创新，为数据价值流通创造新的突破。区块链技术让资本市场嗅到了猎物的味道，数字金融交易所应运而生。<br>熊市行情低迷，交易所也面临着极大的考验，陷入了狼多肉少的困局。虽说币圈迎来了寒冬，区块链热度依然不减，交易所也处在机遇的风口。币贝上线就送千万美金，并选择在熊市入局，显然是有备而来。币贝此举无异于给低迷的市场打入一剂强心针，给万千韭菜重燃了梦想。<br>据了解，币贝是一家“弱中心化”管理模式的交易所，由全球数十个知名投资机构与数百个社群共同投资，公开透明。币贝拥有世界顶级的安全团队，并设立了硅谷安全实验室，自主研发出了单向传输光闸、加密二维码等交易技术，其金融安全防护系统具备国家级金融安全防护能力。<br>   币贝狂撒美金的背后是实力在支撑，从10月25日开始的充值即送100美金ET活动，足以说明诚意。早起的鸟儿有虫吃，先进场先得利，这个市场从来都是这样。<br>  从行业角度来看，币贝开发了丰富的金融产品，包括币币交易、法币交易、贝壳宝、机构账户、量化云、期货合约、多倍杠杆、指数、数据服务、数字资产借贷、数字资产理财……满足全球价值投资者不同投资需求。<br>在优胜劣汰、竞争激烈的交易所行业中，自带光环、集众多优势上线的全球首家数字金融交易所币贝，势必会拔得头筹，引领“传统金融转向数字金融”的未来大趋势。www.exshell.com</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>千万美金任性送 全球首家数字金融交易所——“币贝”即将上线</title>
    <url>/2018/10/27/note/article1027/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>千万美金任性送 全球首家数字金融交易所——“币贝”即将上线</strong></p>
<p> 币贝（ExShell）是全球领先的数字金融交易所，作为“传统金融向数字金融” 进化的推动者，秉承公平、公正的原则，为全球价值投资者提供安全、稳定、高效、透明的数字金融服务。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47600247-ced14600-d9f0-11e8-8cc0-3bb0089ec3c4.png" alt="1"></p>
<p>币贝开创了全新交易模式，对标全球前五大金融交易所的商业模式和金融产品，运用成熟的金融数字化技术，为全球价值投资者提供更加前沿、高效的数字金融产品服务；未来将与全球数万家顶级的投资机构建立合作，定期发布币贝经营报告和财报，为全球机构用户提供全方位的数字金融投资服务，包括美国、德国、日本、法国、英国、瑞士、新加坡等国家投资基金，以及桥水基金、3i集团、巴菲特基金、索罗斯量子基金、软银集团、高盛集团、摩根士丹利、花旗银行、摩根大通等公司旗下投资机构。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47600248-ced14600-d9f0-11e8-802d-664b87a260cc.png" alt="2"></p>
<p>币贝组建了世界顶级的安全团队，并设立硅谷安全实验室，自主研发出单向传输光闸、加密二维码等交易技术，其金融安全防护系统具备国家级金融安全防护能力。<br>币贝研发了高效的金融交易系统，每秒超过百万级的高效撮合系统，具备无限制的横向扩展能力；基于内存数据库的实时处理能力，随时提供最佳的交易体验；Hadoop、Elastic Search等大数据系统的分析能力，全面保障实时风控和交易所业务决策。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47600249-cf69dc80-d9f0-11e8-9397-65c05c595d7a.png" alt="3"></p>
<p>币贝是一家“弱中心化”管理模式的交易所，由全球数十个知名投资机构与数百个社群共同投资，并作为币贝的股东参与核心经营决策。币贝每季度召开全球股东大会，核心管理团队拥有20%的决策权，特许邀约股东、全球社群股东和独立董事会拥有80％的决策权。币贝获得顶级资本的信任和全球社群资源的支持，股东们的专业态度和全球资源将最大程度地帮助币贝快速成长。<br>币贝开发了丰富的金融产品，包括币币交易、法币交易、期货合约、多倍杠杆、指数、数据服务、数字资产借贷、数字资产理财……满足全球投资者丰富的投资需求。<br>币贝拥有世界级精英团队，管理团队来自华尔街、硅谷、伦敦证券交易所、港交所、IBM、BAT、汤森路透、火币等知名企业。<br>币贝坚持以“金融更高效，财富更自由”为使命，服务全球价值投资者，提供安全、稳定、高效、透明的数字金融服务。<br>新加坡时间11月1日，币贝即将在全球同步上线，10月25日开始，币贝将持续推出重磅福利活动，包括充值送100美金ET、用户最多可瓜分666万美金ET、开放交易24小时狂欢充值瓜分900万美金ET等超级奖励。更多惊喜，敬请期待。www.exshell.com</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>全民瓜分666万美金ET，全球首家数字金融交易所币贝今日开放充值</title>
    <url>/2018/10/25/note/article1025/</url>
    <content><![CDATA[<p>布链财经<br><a id="more"></a></p>
<p> <strong>全民瓜分666万美金ET，全球首家数字金融交易所币贝今日开放充值</strong></p>
<p> 据悉，全球首家数字金融交易所币贝（ExShell）在今日（10月25日）10:30开放充值功能，11月1日10：30全球同步上线。10月25日-10月31日期间，充值用户每人送100美金ET，再额外瓜分666万美金ET。近期将上线APP版，目前公测中，注册充值请在电脑端操作www.exshell.com</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47600250-cf69dc80-d9f0-11e8-92c7-a3b4bc7a7c5b.png" alt="asdasd"><br>（全球首家数字金融交易所币贝（ExShell）今日开放充值）</p>
<p>币贝（ExShell）是全球领先的数字金融交易所，作为“传统金融向数字金融” 进化的推动者，秉承公平、公正的原则，为全球价值投资者提供安全、稳定、高效、透明的数字金融服务。<br>币贝开创了全新交易模式，对标全球前五大金融交易所的商业模式和金融产品，运用成熟的金融数字化技术，为全球价值投资者提供更加前沿、高效的数字金融产品服务；未来将与全球数万家顶级的投资机构建立合作，定期发布币贝经营报告和财报，为全球机构用户提供全方位的数字金融投资服务，包括美国、德国、日本、法国、英国、瑞士、新加坡等国家投资基金，以及桥水基金、3i集团、巴菲特基金、索罗斯量子基金、软银集团、高盛集团、摩根士丹利、花旗银行、摩根大通等公司旗下投资机构。</p>
<p><img src="https://user-images.githubusercontent.com/11883853/47600251-cf69dc80-d9f0-11e8-87cd-231ef03bbd20.png" alt="asdasdfff"><br>（全球首家数字金融交易所币贝（ExShell）即将全球同步上线）</p>
<p>币贝组建了世界顶级的安全团队，并设立硅谷安全实验室，自主研发出单向传输光闸、加密二维码等交易技术，其金融安全防护系统具备国家级金融安全防护能力。<br>币贝研发了高效的金融交易系统，每秒超过百万级的高效撮合系统，具备无限制的横向扩展能力；基于内存数据库的实时处理能力，随时提供最佳的交易体验；Hadoop、Elastic Search等大数据系统的分析能力，全面保障实时风控和交易所业务决策。<br>币贝是一家“弱中心化”管理模式的交易所，由全球数十个知名投资机构与数百个社群共同投资，并作为币贝的股东参与核心经营决策。币贝获得顶级资本的信任和全球社群资源的支持，股东们的专业态度和全球资源将最大程度地帮助币贝快速成长。<br>币贝开发了丰富的金融产品，包括币币交易、法币交易、期货合约、多倍杠杆、指数、数据服务、数字资产借贷、数字资产理财……满足全球投资者丰富的投资需求。<br>币贝拥有世界级精英团队，管理团队来自华尔街、硅谷、伦敦证券交易所、港交所、IBM、BAT、汤森路透、火币等知名企业。<br>币贝坚持以“金融更高效，财富更自由”为使命，服务全球价值投资者，提供安全、稳定、高效、透明的数字金融服务。</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>ONO资本投资全球首档中韩区块链真人秀《比特币漂游记》</title>
    <url>/2018/10/19/ONO%E8%B5%84%E6%9C%AC%E6%8A%95%E8%B5%84%E5%85%A8%E7%90%83%E9%A6%96%E6%A1%A3%E4%B8%AD%E9%9F%A9%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9C%9F%E4%BA%BA%E7%A7%80%E3%80%8A%E6%AF%94%E7%89%B9%E5%B8%81%E6%BC%82%E6%B8%B8%E8%AE%B0%E3%80%8B/</url>
    <content><![CDATA[<p>布链财经<br>2018-10-19<br><a id="more"></a></p>
<p> <strong>ONO资本投资全球首档中韩区块链真人秀《比特币漂游记》</strong></p>
<p>韩媒BlockDaily 10月18日发布消息，ONO资本已投资全球首档中韩区块链真人秀微综艺《比特币漂游记》，11月爱奇艺全球首播、10月映客独家直播支持、ONO独家社群支持，全球100余家平台联合宣发。<br>该节目尚属全球首档中韩区块链真人秀微综艺，宣发集合全网各平台头部资源，千万顶级垂直流量曝光，成2018全网最大流量、最强曝光的区块链综艺节目。<br>据报道，《比特币漂游记》由BlockDaily联合区块链视频媒体链客时间共同担纲策划，爱奇艺金牌合作团队参与拍摄制作，Mixin钱包独家冠名。讲述分别来自中、韩两国的两位年轻小哥用比特币环游世界的爆笑囧途，第一季将在中国东北三省7大城市完成生存段位挑战。<br>接受采访时，诺舟集团董事长徐可女士被问到为什么投资该节目时表示：“《比特币漂游记》的策划和制作团队非常有意思，这档节目是媒体行业转型大众娱乐化的一次很好尝试。”</p>
]]></content>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>初心决定高度</title>
    <url>/2018/07/15/hexo%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    <content><![CDATA[<p>布链财经<br>2018.07.15<br><a id="more"></a></p>
<p>区块链的风口滋生的创业者数不胜数，根据初心大体可以归为2类。一类的初心是：干任何事情以自身利益出发，然后套个做事的幌子。而另一类的初心是：认真做事，然后顺便挣点钱。</p>
<p>这个环境下有太多太多的创业者标榜自己的第二类初心，确疯狂敛财。多到我都不敢统计，想起这种嘴脸尤其让人可恶，比之一锥子买卖，只割一次韭菜的创业者犹有过之而无所不及。</p>
<p>区块链的热风还在继续，昨晚喜欢软中华的男人频频刷屏。李老师的一席录音被广为传播，不得不让狂热币民深刻反思，币圈有所谓的价值投资吗 ？5月的公链之争随着EOS上线的跌跌撞撞，也淡出了人们的视线。整个熊市市场，加之从无所谓的价值投资，只要有流量，网红效应，共识的人多了 ，空气币也成为了价值币的环境下，币民改如何是从 ？</p>
<p>在这个浮躁的行业里面，大佬的初心决定行业的高度，群众的初心决定行业的热度。越是熊市的背景下，越能区分出2类创业者 。某些敛财创业者更是处处贬低别的数字货币进而获取热度，声称半个月研究透了EOS，得出EOS史上最大传销币的结论。然而这些创业者确基于EOS代码去做公链，去发币，且不说EOS到底是不是空气币，不得不说他们获得了热度，进入了人们的眼球。可是确也暴露出了丑恶的嘴脸，这类创业者类比老师教会了学生知识，学生学了点皮毛之后，就觉得老师不过如此，一文不值。</p>
<p>然而也有以真正做事为初心的创业者。Fcoin撬动整个区块链大蛋糕的交易所应运而生。它的具体模式不需要再过多介绍了。我们分析什么情况下能产出这种伟大构想，以自身利益为前提么？那必然不是，第一步让利的观念就不会出现在一类创业者脑海中，所以必然是二类创业者的杰作。有人说Fcoin”你想要分红，人家想要你的本金”。我们抛开FT分红属性，它就是一个平台币，与许许多多平台币一样目前就是个积分，就是个概念。各大平台币会暴涨暴跌，你的本金实时变化，你的本金不会因为你买了某个平台币而只赚不亏，每个有点热度的币都会有神秘资金控制走向，股市也不例外。小散无不时刻面临被割的风险。而有分红的平台币，你起码在暴跌的时候能挽回一点损失，长期持有或许会回本，加之各种透明属性，团队持有地址公示，锁仓三年。试问是平台要你的本金吗 ？哪家平台团队持币敢于公示，并在三年内不动一币？想要你本金的只是击鼓传花被吸引进来，幻想一夜暴富神话的贪性和不满足而已。或许FC也没预料到模式会这么火爆，前期给与私募比例，导致抛盘压力。没人能守得住十倍百倍的利润而不为所动。或许没有私募FT会是另一种表现吧。</p>
<p>越是熊市，市场趋于理性的时候，币民更多的去价值选择，明辨是非 。而非别人说它有价值，很多人说他有价值，自己就觉得有价值，被这种类比传销的手段所影响。回归回正初心，币民自己选择价值，大佬做事为始，区块链方能让人如沐春风。</p>
]]></content>
      <categories>
        <category>原创</category>
      </categories>
      <tags>
        <tag>原创</tag>
      </tags>
  </entry>
</search>
